<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1.0"/>
<title>SPY Edge v3.0</title>
<style>
@import url('https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@300;400;500;600;700&display=swap');
*,*::before,*::after{box-sizing:border-box;margin:0;padding:0}
body{font-family:'JetBrains Mono','Courier New',monospace;background:#09090f;color:#e2e8f0;min-height:100vh}
::-webkit-scrollbar{width:4px;height:4px}
::-webkit-scrollbar-track{background:#0f0f1a}
::-webkit-scrollbar-thumb{background:#334155;border-radius:2px}
input,select,textarea{font-family:inherit;background:#0f172a;border:1px solid #1e293b;color:#e2e8f0;border-radius:6px}
input:focus,select:focus,textarea:focus{outline:1px solid #10b981;border-color:#10b981}
button{font-family:inherit;cursor:pointer}
.btn-primary{background:#10b981;color:#000;font-weight:700;border:none;transition:all .15s}
.btn-primary:hover{background:#059669;transform:translateY(-1px)}
.btn-primary:disabled{opacity:.5;cursor:not-allowed;transform:none}
.btn-ghost{background:transparent;border:1px solid #334155;color:#94a3b8;transition:all .15s}
.btn-ghost:hover{border-color:#10b981;color:#10b981}
.btn-danger{background:transparent;border:1px solid #ef444433;color:#ef4444;transition:all .15s}
.btn-danger:hover{background:#ef444415}
.pulse{animation:pulse 2s infinite}
@keyframes pulse{0%,100%{opacity:1}50%{opacity:.4}}
.sig-card{cursor:pointer;transition:background .15s}
.sig-card:hover{background:#0f1929!important}
.flow-row:hover{background:#0f1520!important}
.tab-btn{background:none;border:none;border-bottom:2px solid transparent;color:#64748b;padding:11px 14px;font-size:11px;font-family:inherit;letter-spacing:1px;cursor:pointer;display:flex;align-items:center;gap:6px;white-space:nowrap}
.tab-btn:hover{color:#94a3b8}
.tab-btn.active{border-bottom-color:#10b981;color:#10b981}
.badge{font-size:10px;padding:2px 7px;border-radius:4px;border:1px solid;font-weight:700;display:inline-block}
.badge-call,.badge-bull,.badge-bullish{background:rgba(16,185,129,.15);color:#6ee7b7;border-color:rgba(16,185,129,.3)}
.badge-put,.badge-bear,.badge-bearish{background:rgba(239,68,68,.15);color:#fca5a5;border-color:rgba(239,68,68,.3)}
.badge-sweep{background:rgba(245,158,11,.15);color:#fcd34d;border-color:rgba(245,158,11,.3)}
.ftag{font-size:9px;padding:2px 6px;border-radius:3px;background:#0f172a;border:1px solid #1e293b;color:#475569;letter-spacing:.5px;display:inline-block;margin:2px 2px 0 0}
#setup-screen{display:flex;align-items:flex-start;justify-content:center;min-height:100vh;padding:30px 20px;overflow-y:auto}
#app{display:none;flex-direction:column;min-height:100vh}
.card{background:#0c0c1a;border:1px solid #1e293b;border-radius:8px}
.sl{font-size:11px;color:#475569;letter-spacing:2px}
.tog{width:36px;height:20px;border-radius:10px;position:relative;cursor:pointer;transition:background .2s;display:inline-block;flex-shrink:0}
.tog-thumb{position:absolute;top:2px;width:16px;height:16px;border-radius:50%;background:#fff;transition:left .2s}
.g2{display:grid;grid-template-columns:1fr 1fr;gap:16px}
.g3{display:grid;grid-template-columns:1fr 1fr 1fr;gap:16px}
.g4{display:grid;grid-template-columns:repeat(4,1fr);gap:12px}
.g6{display:grid;grid-template-columns:repeat(6,1fr);gap:12px}
.gsb{display:grid;grid-template-columns:300px 1fr;gap:20px}
.api-dot{width:7px;height:7px;border-radius:50%;display:inline-block}
</style>
</head>
<body>

<!-- â•â•â•â•â•â• SETUP â•â•â•â•â•â• -->
<div id="setup-screen">
<div style="width:620px;max-width:100%">
<div class="card" style="padding:36px">
  <div style="font-size:11px;color:#10b981;letter-spacing:3px;margin-bottom:4px;font-weight:700">â—ˆ SPY EDGE v3.0</div>
  <div style="font-size:20px;font-weight:700;color:#f1f5f9;margin-bottom:4px">Connect Your Data Sources</div>
  <div style="font-size:11px;color:#475569;margin-bottom:26px;line-height:1.7">Three signals: GEX Field Â· Trend Â· Conviction. APEX fires when 2-of-3 align with no opposing signal. Polygon required; Unusual Whales strongly recommended.</div>

  <div style="margin-bottom:16px">
    <div style="display:flex;justify-content:space-between;margin-bottom:5px">
      <label style="font-size:11px;font-weight:700;color:#10b981">POLYGON.IO â€” Real-Time Price <span style="color:#ef4444;font-size:10px">â˜… Required</span></label>
      <a href="https://polygon.io" target="_blank" style="font-size:10px;color:#06b6d4;text-decoration:none">polygon.io â†’</a>
    </div>
    <input id="k-poly" type="password" placeholder="Polygon paid-tier API key" style="width:100%;padding:9px 12px;font-size:12px"/>
    <div style="font-size:10px;color:#334155;margin-top:3px">Paid tier enables 5-second real-time refresh. Free tier falls back to 15s.</div>
  </div>

  <div style="margin-bottom:16px">
    <div style="display:flex;justify-content:space-between;margin-bottom:5px">
      <label style="font-size:11px;font-weight:700;color:#06b6d4">UNUSUAL WHALES â€” Live Options Flow <span style="color:#f59e0b;font-size:10px">â˜… Strongly recommended</span></label>
      <a href="https://unusualwhales.com" target="_blank" style="font-size:10px;color:#06b6d4;text-decoration:none">unusualwhales.com â†’</a>
    </div>
    <input id="k-uw" type="password" placeholder="Unusual Whales API key (blank = mock flow)" style="width:100%;padding:9px 12px;font-size:12px"/>
    <div style="font-size:10px;color:#334155;margin-top:3px">Filters to $500K+ prints only â€” block-level flow that actually moves the signal.</div>
  </div>

  <div style="margin-bottom:16px;padding:10px 12px;background:#0c2818;border:1px solid #10b98144;border-radius:6px">
    <div style="display:flex;align-items:center;gap:8px;margin-bottom:4px">
      <span style="font-size:11px;font-weight:700;color:#10b981">FLOW GEX â€” Auto-computed from live options flow</span>
      <span style="font-size:10px;color:#10b981;background:#10b98122;padding:1px 6px;border-radius:3px">â˜… No extra key needed</span>
    </div>
    <div style="font-size:10px;color:#94a3b8;line-height:1.6">Call wall, put wall &amp; flip level are computed directly from UW options flow â€” 7 DTE or less, strikes within 3% of price, $250K+ prints only. Updates every time flow refreshes. Manual override available in the GEX tab.</div>
  </div>

  <div style="margin-bottom:16px">
    <div style="display:flex;justify-content:space-between;margin-bottom:5px">
      <label style="font-size:11px;font-weight:700;color:#f59e0b">TRADIER â€” Real Options Chain + Live Delta Stream <span style="color:#475569;font-size:10px">Optional Â· Production key</span></label>
      <a href="https://developer.tradier.com" target="_blank" style="font-size:10px;color:#06b6d4;text-decoration:none">developer.tradier.com â†’</a>
    </div>
    <input id="k-trad" type="password" placeholder="Tradier production API key" style="width:100%;padding:9px 12px;font-size:12px;margin-bottom:6px"/>
    <input id="k-cfworker" type="text" placeholder="Cloudflare Worker URL (e.g. https://spy-edge-tradier-proxy.xxx.workers.dev)" style="width:100%;padding:9px 12px;font-size:12px"/>
    <div style="font-size:10px;color:#334155;margin-top:3px">Worker URL enables live tick-level cumulative delta stream. Real option chain used for backtest P&L.</div>
  </div>

  <div style="margin-bottom:22px">
    <div style="display:flex;justify-content:space-between;margin-bottom:5px">
      <label style="font-size:11px;font-weight:700;color:#fb923c">PUSHOVER â€” Push Notifications <span style="color:#475569;font-size:10px">Optional Â· $5 one-time</span></label>
      <a href="https://pushover.net" target="_blank" style="font-size:10px;color:#06b6d4;text-decoration:none">pushover.net â†’</a>
    </div>
    <div style="display:grid;grid-template-columns:1fr 1fr;gap:8px">
      <input id="k-ptoken" type="password" placeholder="App API Token" style="padding:9px 12px;font-size:12px"/>
      <input id="k-puser"  type="password" placeholder="User Key"      style="padding:9px 12px;font-size:12px"/>
    </div>
    <div style="font-size:10px;color:#334155;margin-top:3px">Push notification when: APEX fires Â· You hit ğŸ“± AM BRIEF button each morning.</div>
  </div>

  <div id="setup-err" style="display:none;font-size:11px;color:#ef4444;margin-bottom:12px;padding:9px 12px;background:#1a0a0a;border:1px solid #ef444433;border-radius:6px"></div>
  <button id="connect-btn" class="btn-primary" onclick="connectAll()" style="width:100%;padding:13px;border-radius:7px;font-size:13px;letter-spacing:1px">CONNECT &amp; LAUNCH â†’</button>
  <div style="text-align:center;font-size:10px;color:#334155;margin-top:10px">Keys saved in this browser â€” auto-fill next time. Clear with Disconnect button.</div>
</div>
</div>
</div>

<!-- â•â•â•â•â•â• APP â•â•â•â•â•â• -->
<div id="app">

  <!-- HEADER -->
  <div style="background:#0a0a14;border-bottom:1px solid #1e293b;padding:10px 20px;display:flex;align-items:center;justify-content:space-between;flex-shrink:0">
    <div style="display:flex;align-items:center;gap:13px">
      <span style="font-size:11px;color:#10b981;letter-spacing:3px;font-weight:700">â—ˆ SPY EDGE v1.6</span>
      <span style="width:1px;height:20px;background:#1e293b;display:inline-block"></span>
      <span id="hdr-price" style="font-size:22px;font-weight:700;color:#f1f5f9;letter-spacing:-1px">$â€”â€”â€”</span>
      <span id="hdr-change" style="font-size:12px;color:#10b981"></span>
      <div id="hdr-ohlv" style="font-size:10px;color:#334155;display:flex;gap:10px"></div>
      <span id="data-badge" style="font-size:9px;padding:2px 8px;border-radius:3px;font-weight:700;letter-spacing:1px;background:#f59e0b22;border:1px solid #f59e0b55;color:#f59e0b">â—Œ DEMO</span>
      <div id="api-dots" style="display:flex;gap:8px;font-size:10px"></div>
    </div>
    <div style="display:flex;align-items:center;gap:8px">
      <span id="hdr-time" style="font-size:10px;color:#334155"></span>
      <div id="hdr-err" style="display:none;font-size:10px;color:#ef4444;max-width:200px;overflow:hidden;text-overflow:ellipsis;white-space:nowrap"></div>
      <button class="btn-ghost" onclick="sendAMBrief()" style="font-size:11px;padding:5px 11px;border-radius:4px" title="Send pre-market push notification">ğŸ“± AM BRIEF</button>
      <button class="btn-ghost" onclick="openSettings()" style="font-size:11px;padding:5px 11px;border-radius:4px">âš™</button>
      <button class="btn-ghost" id="live-btn" onclick="toggleLive()" style="font-size:11px;padding:5px 12px;border-radius:4px;display:flex;align-items:center;gap:6px">
        <span id="live-dot" style="width:6px;height:6px;border-radius:50%;background:#475569;display:inline-block"></span>
        <span id="live-lbl">PAUSED</span>
      </button>
      <button class="btn-ghost" onclick="refresh()" style="font-size:11px;padding:5px 10px;border-radius:4px">â†»</button>
      <button class="btn-ghost" onclick="disconnect()" style="font-size:11px;padding:5px 10px;border-radius:4px;color:#334155" title="Disconnect">â‹</button>
    </div>
  </div>

  <!-- STATUS BAR -->
  <div style="background:#070710;border-bottom:1px solid #1a1a2e;padding:6px 20px;display:flex;gap:16px;font-size:11px;flex-shrink:0;overflow-x:auto;align-items:center">
    <span style="color:#475569">GEX</span><span id="sb-regime" style="font-weight:700">â€”</span><span id="sb-flip" style="color:#334155;font-size:10px"></span>
    <span style="color:#1e293b">â”‚</span>
    <span style="color:#475569">8E</span><span id="sb-e8" style="color:#06b6d4">â€”</span>
    <span style="color:#475569">21E</span><span id="sb-e21" style="color:#a78bfa">â€”</span>
    <span style="color:#475569">VWAP</span><span id="sb-vwap" style="color:#64748b">â€”</span>
    <span style="color:#1e293b">â”‚</span>
    <span style="color:#475569">FLOW</span><span id="sb-bias">â€”</span>
    <span style="color:#475569">CALLS</span><span id="sb-calls" style="color:#10b981">â€”</span>
    <span style="color:#475569">PUTS</span><span id="sb-puts" style="color:#ef4444">â€”</span>
    <span style="color:#1e293b">â”‚</span>
    <span style="color:#475569">VIX</span><span id="sb-vix" style="color:#f59e0b">â€”</span>
    <span style="color:#475569">STAGED</span><span id="sb-staged" style="color:#475569;font-weight:700">0</span>
    <span style="color:#1e293b">â”‚</span>
    <span id="sb-apex" style="font-size:10px;color:#334155">APEX: awaiting scan</span>
  </div>

  <!-- TABS -->
  <div style="border-bottom:1px solid #1e293b;display:flex;padding:0 20px;flex-shrink:0;overflow-x:auto">
    <button class="tab-btn active" id="tab-signals"  onclick="switchTab('signals')">âš¡ SIGNALS <span id="cnt-signals" style="background:#10b981;color:#000;border-radius:10px;padding:1px 6px;font-size:10px;font-weight:700;display:none"></span></button>
    <button class="tab-btn"        id="tab-flow"     onclick="switchTab('flow')">ğŸŒŠ FLOW</button>
    <button class="tab-btn"        id="tab-gex"      onclick="switchTab('gex')">âš™ GEX</button>
    <button class="tab-btn"        id="tab-backtest" onclick="switchTab('backtest')">ğŸ“Š BACKTEST</button>
    <button class="tab-btn"        id="tab-orders"   onclick="switchTab('orders')">ğŸ“‹ ORDERS <span id="cnt-orders" style="background:#1e293b;color:#64748b;border-radius:10px;padding:1px 6px;font-size:10px;font-weight:700">0</span></button>
    <button class="tab-btn"        id="tab-summary"  onclick="switchTab('summary')">ğŸ“ˆ EVENING SUMMARY <span id="sum-badge" style="display:none;background:#a855f733;color:#a855f7;border:1px solid #a855f755;border-radius:10px;padding:1px 6px;font-size:10px;font-weight:700"></span></button>
  </div>

  <!-- CONTENT -->
  <div style="padding:20px;flex:1;overflow-y:auto">

    <!-- SIGNALS -->
      <div id="pane-signals">
      <div class="card" style="padding:12px 16px;margin-bottom:14px;display:flex;align-items:center;justify-content:space-between;gap:16px;flex-wrap:wrap">
        <div style="display:flex;align-items:center;gap:14px;flex-wrap:wrap">
          <span class="sl">APEX ENGINE</span>
          <span style="font-size:10px;color:#334155">GEX Gate (required) Â· Momentum booster (0â€“40) Â· Flow booster (0â€“40) Â· Threshold 100+</span>
          <span style="font-size:10px;color:#475569">Blackout: 9:30â€“10am Â· 3:30â€“4pm ET</span>
        </div>
        <button class="btn-primary" onclick="refresh()" style="padding:6px 16px;border-radius:6px;font-size:11px;letter-spacing:1px">SCAN NOW</button>
      </div>
      <div id="signals-list"><div style="text-align:center;padding:60px;color:#334155"><div style="font-size:36px;margin-bottom:12px">â—ˆ</div><div>Click SCAN NOW or enable LIVE</div></div></div>
    </div>

    <!-- FLOW -->
    <div id="pane-flow" style="display:none">
      <div style="display:flex;align-items:center;justify-content:space-between;margin-bottom:14px">
        <div style="display:flex;align-items:center;gap:10px">
          <div class="sl">OPTIONS FLOW</div>
          <span id="flow-src" style="font-size:9px;padding:2px 8px;border-radius:3px;background:#1e293b;color:#64748b;border:1px solid #334155">MOCK DATA</span>
        </div>
        <span id="flow-updated" style="font-size:10px;color:#334155"></span>
      </div>
      <div class="g4" style="margin-bottom:14px" id="flow-metrics"></div>
      <div class="card" style="overflow:hidden">
        <div style="display:grid;grid-template-columns:70px 55px 65px 60px 100px 65px 90px 75px;padding:9px 16px;border-bottom:1px solid #1e293b;font-size:10px;color:#475569;letter-spacing:1px">
          <span>TIME</span><span>TYPE</span><span>STRIKE</span><span>EXP</span><span>PREMIUM</span><span>SIZE</span><span>SENTIMENT</span><span>SWEEP</span>
        </div>
        <div id="flow-rows"></div>
      </div>
    </div>

    <!-- GEX -->
    <div id="pane-gex" style="display:none">
      <div style="display:flex;align-items:center;justify-content:space-between;margin-bottom:14px;flex-wrap:wrap;gap:10px">
        <div style="display:flex;align-items:center;gap:10px">
          <div class="sl">GAMMA EXPOSURE</div>
          <span id="gex-src" style="font-size:9px;padding:2px 8px;border-radius:3px;background:#1e293b;color:#64748b;border:1px solid #334155">MANUAL</span>
          <span id="gex-next" style="font-size:10px;color:#334155"></span>
          <button class="btn-ghost" onclick="fetchUWGex(true).then(()=>renderGEX())" style="font-size:9px;padding:2px 8px;border-radius:3px;letter-spacing:1px">â†» RETRY</button>
        </div>
        <div style="display:flex;gap:8px;align-items:center">
          <span style="font-size:10px;color:#475569">Manual:</span>
          <input id="gex-flip-in"  type="number" placeholder="Flip"      style="width:76px;padding:5px 8px;font-size:11px" value="684"/>
          <input id="gex-cwall-in" type="number" placeholder="Call wall" style="width:76px;padding:5px 8px;font-size:11px" value="700"/>
          <input id="gex-pwall-in" type="number" placeholder="Put wall"  style="width:76px;padding:5px 8px;font-size:11px" value="670"/>
          <button class="btn-ghost" onclick="applyManualGEX()" style="font-size:11px;padding:5px 12px;border-radius:4px">APPLY</button>
        </div>
      </div>

      <!-- â”€â”€ TRADIER GEX DIAGNOSTIC â”€â”€ -->
      <div class="card" style="padding:18px;margin-bottom:14px;border:1px solid #f59e0b44;background:#0f0900">
        <div style="display:flex;align-items:center;justify-content:space-between;margin-bottom:12px">
          <div>
            <div style="font-size:9px;color:#f59e0b;letter-spacing:2px;font-weight:700">TRADIER CHAIN DIAGNOSTIC</div>
            <div style="font-size:10px;color:#475569;margin-top:2px">Tests whether Tradier production key returns OI + Greeks needed for real GEX computation</div>
          </div>
          <button onclick="runTradierGEXTest()" style="padding:8px 18px;background:#f59e0b22;border:1px solid #f59e0b55;border-radius:5px;color:#f59e0b;font-size:11px;font-weight:700;letter-spacing:1px;cursor:pointer">â–¶ RUN TEST</button>
        </div>
        <div id="tradier-gex-result" style="font-size:11px;color:#475569;line-height:1.8">Press RUN TEST to check Tradier options chain access.</div>
      </div>

      <div class="g2">
        <div class="card" style="padding:20px">
          <div class="sl" style="margin-bottom:12px">KEY LEVELS &nbsp;Â·&nbsp; SPY <span id="gex-price" style="color:#f1f5f9;font-weight:700">â€”</span></div>
          <div id="gex-levels"></div>
        </div>
        <div style="display:flex;flex-direction:column;gap:12px">
          <div class="card" style="padding:18px">
            <div class="sl" style="margin-bottom:8px">GEX REGIME</div>
            <div id="gex-regime" style="font-size:24px;font-weight:700;margin-bottom:6px;color:#10b981">â€”</div>
            <div id="gex-desc" style="font-size:11px;color:#64748b;line-height:1.7"></div>
          </div>
          <div class="card" style="padding:18px">
            <div class="sl" style="margin-bottom:10px">KEY DISTANCES</div>
            <div id="gex-dist"></div>
          </div>
          <div class="card" style="padding:18px;margin-top:14px">
            <div id="dp-levels"><div style="font-size:11px;color:#475569;padding:4px 0">Dark pool levels load on connect.</div></div>
          </div>
        </div>
      </div>
    </div>

    <!-- BACKTEST -->
    <div id="pane-backtest" style="display:none">
      <div class="gsb">
        <div class="card" style="padding:20px;height:fit-content">
          <div class="sl" style="margin-bottom:14px">BACKTEST CONFIG</div>
          <div style="margin-bottom:10px"><label style="font-size:10px;color:#64748b;display:block;margin-bottom:4px">Start Date</label><input type="date" id="bt-start" value="2026-01-01" style="width:100%;padding:8px 10px;font-size:12px"/></div>
          <div style="margin-bottom:10px"><label style="font-size:10px;color:#64748b;display:block;margin-bottom:4px">End Date</label><input type="date" id="bt-end" value="2026-02-21" style="width:100%;padding:8px 10px;font-size:12px"/></div>
          <div style="margin-bottom:10px"><label style="font-size:10px;color:#64748b;display:block;margin-bottom:4px">Min Confidence %</label><input type="number" id="bt-conf" value="82" style="width:100%;padding:8px 10px;font-size:12px"/></div>
          <div style="margin-bottom:10px"><label style="font-size:10px;color:#64748b;display:block;margin-bottom:4px">Target % on option</label><input type="number" id="bt-tpct" value="20" style="width:100%;padding:8px 10px;font-size:12px"/></div>
          <div style="margin-bottom:16px"><label style="font-size:10px;color:#64748b;display:block;margin-bottom:4px">Stop % on option</label><input type="number" id="bt-spct" value="15" style="width:100%;padding:8px 10px;font-size:12px"/></div>
          <div style="padding:12px;background:#080814;border-radius:8px;border:1px solid #1e293b;margin-bottom:14px">
            <div style="display:flex;align-items:center;justify-content:space-between;margin-bottom:6px">
              <span style="font-size:12px;color:#f1f5f9;font-weight:600">â˜… APEX Only Mode</span>
              <div class="tog" id="tog-apex-bt" onclick="toggleApexBT()" style="background:#1e293b"><div class="tog-thumb" style="left:2px"></div></div>
            </div>
            <div style="font-size:10px;color:#475569;line-height:1.6">ON = only simulate trades where ALL rules align.<br>OFF = all individually active rules.</div>
          </div>
          <div id="tradier-note" style="display:none;padding:8px;background:#0a1000;border:1px solid #f59e0b33;border-radius:6px;font-size:10px;color:#f59e0b;margin-bottom:12px">â— Tradier connected â€” real option chain P&L active</div>
          <div style="margin-bottom:14px"><div class="sl" style="margin-bottom:8px">Active Rules</div><div id="bt-checks"></div></div>
          <button class="btn-primary" onclick="runBacktest()" id="bt-run" style="width:100%;padding:10px;border-radius:6px;font-size:12px;letter-spacing:1px">â–¶ RUN BACKTEST</button>
        </div>
        <div id="bt-results"><div style="display:flex;align-items:center;justify-content:center;height:300px;flex-direction:column;gap:12px;color:#475569"><div style="font-size:36px">ğŸ“Š</div><div>Configure and run backtest</div></div></div>
      </div>
    </div>

    <!-- ORDERS -->
    <div id="pane-orders" style="display:none">
      <div id="orders-wrap" style="display:grid;grid-template-columns:1fr;gap:20px">
        <div><div class="sl" style="margin-bottom:14px">STAGED ORDERS â€” ENTER IN WEBULL</div><div id="orders-list"><div style="text-align:center;padding:60px;color:#334155"><div style="font-size:36px;margin-bottom:12px">ğŸ“‹</div><div>No staged orders</div></div></div></div>
        <div id="order-form" style="display:none"></div>
      </div>
    </div>

    <!-- EVENING SUMMARY -->
    <div id="pane-summary" style="display:none">
      <div style="display:flex;align-items:center;justify-content:space-between;margin-bottom:16px">
        <div>
          <div style="font-size:15px;font-weight:700;color:#a855f7;margin-bottom:3px">â˜… APEX Evening Summary</div>
          <div style="font-size:11px;color:#475569">Auto-logged every fire & near-miss. Persists by trading date. Export each evening.</div>
        </div>
        <div style="display:flex;gap:8px">
          <button class="btn-ghost" onclick="sendSummSMS()" style="font-size:11px;padding:7px 14px;border-radius:6px">ğŸ“± TEXT SUMMARY</button>
          <button class="btn-ghost" onclick="exportSummary()" style="font-size:11px;padding:7px 14px;border-radius:6px">â¬‡ EXPORT</button>
          <button class="btn-danger" onclick="clearToday()" style="font-size:11px;padding:7px 14px;border-radius:6px">ğŸ—‘ CLEAR TODAY</button>
        </div>
      </div>
      <div class="g6" style="margin-bottom:16px" id="sum-kpis"></div>
      <div class="g3" style="margin-bottom:16px">
        <div class="card" style="padding:16px;border-top:2px solid #a855f7">
          <div style="display:flex;align-items:center;justify-content:space-between;margin-bottom:10px"><div class="sl" style="color:#a855f7">APEX FIRE LOG</div><span id="sum-fire-cnt" style="font-size:10px;color:#475569"></span></div>
          <div id="sum-fires" style="max-height:400px;overflow-y:auto"></div>
        </div>
        <div class="card" style="padding:16px;border-top:2px solid #ef4444">
          <div class="sl" style="color:#ef4444;margin-bottom:8px">FALSE POSITIVE ANALYSIS</div>
          <div style="font-size:10px;color:#475569;margin-bottom:10px">Signals on losing trades â€” ranked by frequency</div>
          <div id="sum-fp" style="margin-bottom:12px"></div>
          <div id="sum-fp-txt" style="font-size:10px;color:#334155;padding:10px;background:#080814;border-radius:6px;line-height:1.7"></div>
        </div>
        <div class="card" style="padding:16px;border-top:2px solid #f59e0b">
          <div class="sl" style="color:#f59e0b;margin-bottom:8px">APEX BLOCKERS</div>
          <div style="font-size:10px;color:#475569;margin-bottom:10px">Rules that most often prevent APEX from firing</div>
          <div id="sum-bl" style="margin-bottom:12px"></div>
          <div id="sum-bl-txt" style="font-size:10px;color:#334155;padding:10px;background:#080814;border-radius:6px;line-height:1.7"></div>
        </div>
      </div>
      <div class="card" style="padding:22px;border:1px solid #a855f744;background:linear-gradient(135deg,#0a0514,#080814)">
        <div style="display:flex;align-items:center;gap:10px;margin-bottom:14px">
          <span style="font-size:18px">ğŸ“‹</span>
          <div style="font-size:14px;font-weight:700;color:#a855f7">Executive Summary</div>
          <span id="sum-date" style="font-size:11px;color:#475569;margin-left:auto"></span>
        </div>
        <div id="sum-text" style="font-size:11px;color:#94a3b8;line-height:2;white-space:pre-wrap;font-family:'JetBrains Mono',monospace"></div>
        <div style="border-top:1px solid #1e293b;margin-top:16px;padding-top:16px">
          <div class="sl" style="margin-bottom:10px">LOG APEX TRADE OUTCOME</div>
          <div style="display:grid;grid-template-columns:1fr 1fr 1fr auto;gap:10px;align-items:end">
            <div><label style="font-size:10px;color:#64748b;display:block;margin-bottom:4px">APEX Signal</label><select id="out-sel" style="width:100%;padding:7px 10px;font-size:11px;border-radius:6px"></select></div>
            <div><label style="font-size:10px;color:#64748b;display:block;margin-bottom:4px">Outcome</label>
              <select id="out-outcome" style="width:100%;padding:7px 10px;font-size:11px;border-radius:6px">
                <option value="win">âœ… WIN (+20% target hit)</option>
                <option value="loss">âŒ LOSS (-15% stop hit)</option>
                <option value="scratch">â¡ SCRATCH (manual exit)</option>
              </select>
            </div>
            <div><label style="font-size:10px;color:#64748b;display:block;margin-bottom:4px">Notes</label><input type="text" id="out-notes" placeholder="what happened..." style="width:100%;padding:7px 10px;font-size:11px;border-radius:6px"/></div>
            <button class="btn-primary" onclick="logOutcome()" style="padding:8px 16px;border-radius:6px;font-size:11px;white-space:nowrap;height:34px">LOG â†’</button>
          </div>
        </div>
      </div>
    </div>

  </div><!-- /content -->

  <!-- SETTINGS MODAL -->
  <div id="settings-modal" style="display:none;position:fixed;inset:0;background:#00000099;z-index:200;align-items:center;justify-content:center">
    <div class="card" style="width:500px;padding:30px;max-height:88vh;overflow-y:auto">
      <div style="display:flex;align-items:center;justify-content:space-between;margin-bottom:18px">
        <div style="font-size:14px;font-weight:700;color:#f1f5f9">âš™ Settings & API Status</div>
        <button class="btn-ghost" onclick="closeSettings()" style="padding:4px 10px;border-radius:4px;font-size:12px">âœ•</button>
      </div>
      <div id="settings-body"></div>
    </div>
  </div>

  <!-- FOOTER -->
  <div style="border-top:1px solid #1a1a2e;padding:8px 20px;font-size:10px;color:#1e293b;display:flex;justify-content:space-between;flex-shrink:0">
    <span>SPY EDGE v1.6 Â· Polygon Â· Unusual Whales ($250K+ flow + GEX) Â· Tradier Â· Pushover Â· Not financial advice</span>
    <span id="footer-status">â—Œ Demo mode</span>
  </div>
</div>

<script>
/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   PARAMETERS â€” edit these freely, logic is below
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
const P = {
  // â”€â”€ MOMENTUM
  MOM_EMA_TOUCH: 0.40,
  MOM_EMA_STOP: 0.50, MOM_EMA_TGT: 2.50,
  // â”€â”€ GEX GATE â€” required gate, gravitational magnet model
  GEX_MAJOR_SIG: 60,         // â‰¥60 = major level (primary magnet / wall)
  GEX_MOD_SIG:   25,         // 25â€“59 = moderate (respect but not primary)
  GEX_AT_LEVEL:  0.75,       // â‰¤$0.75 from major = "at level"
  GEX_APPROACH:  3.00,       // $0.75â€“$3.00 = "approach zone" (entry trigger)
  GEX_CLR_LOOKBACK: 6,       // lookback candles for moderate-level clearance check
  GEX_CLR_CANDLES: 2,        // consecutive closes needed to confirm level cleared
  GEX_SUPPORT_PROX: 0.75,    // within $0.75 = counts as support touch
  GEX_CONT_MAJOR_AHEAD: 4.0, // Rule 1/3: major must be within $4 ahead for continuation
  GEX_CONT_MOD_AHEAD: 4.0,   // Rule 2: moderate within $4 of last support level
  GEX_CONT_MAJ_FROM_MOD: 6.0,// Rule 2: major within $6 of last moderate support level
  GEX_ABS_MIN_PREM: 15000000,// $15M absolute minimum premium for minor levels to count
  LVL_STOP: 0.75, LVL_TGT: 3.00,
  // â”€â”€ DEX â€” sub-booster inside GEX Gate
  DEX_STRIKE_PCT: 0.03, DEX_MIN_PREM: 100000, DEX_STRONG: 0.60,
  // â”€â”€ FLOW BOOSTER
  FLOW_SWEEP_MIN: 250000,
  FLOW_MOM_THRESH: 0.65,
  FLOW_SM_MIN_PRINTS: 2, FLOW_SM_MINS: 15,
  FLOW_W_0DTE: 10, FLOW_W_1DTE: 8, FLOW_W_2DTE: 5, FLOW_W_3DTE: 3, FLOW_W_7DTE: 1,
  FLOW_DECAY_TODAY_H1: 100, FLOW_DECAY_TODAY_H2: 150,
  FLOW_DECAY_YESTERDAY: 20, FLOW_DECAY_3D: 5, FLOW_DECAY_7D: 1, FLOW_DECAY_30D: 0.2,
  FLOW_STOP: 1.00, FLOW_TGT: 2.50,
  // â”€â”€ GEX defaults (updated at session start; flow GEX overwrites these)
  GEX_FLIP: 565.00, GEX_CWALL: 575.00, GEX_PWALL: 555.00,
  // â”€â”€ DARK POOL
  DP_MIN_PREMIUM: 1000000, DP_PROX: 0.75, DP_LOOKBACK_DAYS: 5,
  // â”€â”€ FLOW GEX PROXY â€” 0DTE primary
  FLOW_GEX_STRIKE_PCT: 0.03, FLOW_GEX_MIN_PREM: 250000,
  FLOW_GEX_0DTE_MIN: 1, FLOW_GEX_1DTE_MIN: 1, FLOW_GEX_LAST_HOUR_START: 15,
  // â”€â”€ APEX â€” GEX gate + boosters
  APEX_CONF: 100,            // composite â‰¥100 to fire (gate score + booster pts)
  APEX_MOM_MAX: 40,          // max Momentum booster contribution
  APEX_FLOW_MAX: 40,         // max Flow booster contribution
  APEX_VEL_MAX: 30,          // max Velocity booster contribution
  APEX_PATH_MAX: 15,         // max Path cleanliness contribution
  // Regime-adjusted thresholds â€” range days demand much higher conviction
  APEX_CONF_TRENDING: 100,
  APEX_CONF_MIXED: 112,
  APEX_CONF_RANGE: 128,
  // Blackout windows (ET minutes from midnight): no APEX during these periods
  APEX_BO_AM_START: 9*60+30, APEX_BO_AM_END: 10*60,     // 9:30â€“10:00am
  APEX_BO_PM_START: 15*60+30, APEX_BO_PM_END: 16*60,    // 3:30â€“4:00pm
  APEX_TGT_MOVE: 4.00, APEX_STOP_BUF: 0.75,
  APEX_TGT_PCT: 20, APEX_STOP_PCT: 15,
  // â”€â”€ DAY-TYPE CLASSIFIER
  DAY_VWAP_SLOPE_CANDLES: 12, // 12 Ã— 5m = 60 min VWAP slope window
  DAY_ATR_RANGE_THRESH: 0.75, // >75% of session ATR used non-directionally by noon = range
  DAY_MIN_CANDLES: 14,        // need â‰¥14 5m candles (70 min) before classifying
  DAY_TREND_THRESH: 60,       // score â‰¥60 = TRENDING
  DAY_RANGE_THRESH: 38,       // score â‰¤38 = RANGE, else MIXED
  // â”€â”€ VELOCITY SCORER
  VEL_VOL_MULT: 1.5,          // current candle volume â‰¥1.5Ã— session avg = fuel
  VEL_AM_START: 10*60,        // 10:00am ET
  VEL_AM_END:   11*60,        // 11:00am ET  (best velocity window)
  VEL_PM_START: 14*60,        // 2:00pm ET
  VEL_PM_END:   14*60+45,     // 2:45pm ET   (secondary window)
  // â”€â”€ PATH CLEANLINESS
  PATH_LOOK_DIST: 4.00,       // check for levels this far toward target
  // â”€â”€ GRAB DETECTION
  GRAB_BODY_THRESH: 0.60,     // wick > 60% of total range = probable grab candle
  GRAB_VOL_RATIO:   0.60,     // follow-through vol < 60% of approach avg = suspect
  GRAB_INVALIDATE:  0.30,     // price returns $0.30 past cleared level = invalidate
  // â”€â”€ TRADIER STREAMING DELTA
  DELTA_TICK_WINDOW: 120,     // rolling window of ticks to track (last 120 prints)
  DELTA_SURGE_THRESH: 0.72,   // â‰¥72% same-direction ticks = surge
  DELTA_SURGE_MIN_TICKS: 30,  // need â‰¥30 ticks before scoring surge
  DELTA_SURGE_MAX: 25,        // max delta imbalance contribution to composite
  DELTA_STALL_THRESH: 0.52,   // delta flips back inside 52% = stall signal
  // â”€â”€ GAMMA FLIP TRANSITION
  GEX_FLIP_LOOKBACK: 8,       // candles to look back for recent flip event
  GEX_FLIP_BONUS: 18,         // gate score bonus when price breaks gamma flip level
  GEX_FLIP_DECAY: 3,          // bonus decays by this amount per candle after flip
  // â”€â”€ VWAP GATE (alternative when GEX in Float)
  VWAP_GATE_PROX: 0.35,       // within $0.35 of VWAP = testing it
  VWAP_GATE_MAX: 65,          // max VWAP gate score (weaker anchor than GEX wall)
  VWAP_GATE_MIN: 40,          // minimum score to activate VWAP gate
  VWAP_DELTA_BOOST: 15,       // delta surge at VWAP adds this to gate score
  SMS_APEX: true, LIVE_MS: 5000, FLOW_MS: 10000,
  // â”€â”€ LEGACY compat
  SWEEP_MIN_PREM: 250000, GEX_DIST: 1.50,
  DP_EMA_BOOST: 5, DP_ORB_BOOST: 5, GEX_REGIME_BOOST: 5,
  HVN_EMA_ALIGN_BOOST: 5, ORB_WINDOW_MINS: 90, GEX_INTERVAL_MIN: 30,
};

// â”€â”€ API KEYS & CONNECTION STATE
let K = { poly:'', uw:'', sg:'', trad:'', ptoken:'', puser:'', cfWorker:'' };
let CON = { poly:false, uw:false, sg:false, trad:false, push:false, stream:false };

// â”€â”€ STREAMING DELTA STATE
let deltaTicks=[];          // rolling window of {price, dir, ts}
let deltaRunning=0;         // cumulative delta: +1 per uptick, -1 per downtick
let deltaLastPrice=0;       // last trade price for uptick/downtick determination
let deltaInflection=null;   // {dir, strength, ts} â€” most recent surge detection
let tradierSessionId=null;  // SSE session token
let tradierSSE=null;        // EventSource instance
let deltaConnectAttempts=0; // reconnect counter

// â”€â”€ GAMMA FLIP STATE
let prevPosGEX=null;        // previous scan's posGEX state for flip detection
let gexFlipEvents=[];       // [{ts, price, toPos, candle}] â€” session flip log

// â”€â”€ APP STATE
let src='mock', live=false;
let liveIv=null, flowIv=null, gexIv=null, candleIv=null;
let c5=[], c15=[];
let price=587.13, chg=0, meta={};
let uwFlow=[], sgGEX=null, dpLevels=[];
let sigs=[], orders=[], selSig=null, tab='signals';
let rules={ ema:true, sw:true, dd:true };
let apexBT=false, lastGEXt=0;
let currentMom={}, currentLvl={}, currentFlow={}, currentVWAP=null;

// â”€â”€ MOCK DATA
const MOCK_FLOW=[
  {time:'09:32',type:'CALL',strike:590,expiry:'02/27',premium:712000,size:2300,sentiment:'bullish',sweep:true},
  {time:'09:51',type:'PUT', strike:585,expiry:'02/27',premium:521000,size:1700,sentiment:'bearish',sweep:true},
  {time:'10:04',type:'CALL',strike:592,expiry:'02/28',premium:843000,size:2800,sentiment:'bullish',sweep:true},
  {time:'10:22',type:'PUT', strike:583,expiry:'02/27',premium:156000,size:500, sentiment:'bearish',sweep:false},
  {time:'10:38',type:'CALL',strike:588,expiry:'03/06',premium:921000,size:3100,sentiment:'bullish',sweep:true},
  {time:'10:55',type:'PUT', strike:580,expiry:'02/27',premium:677000,size:2200,sentiment:'bearish',sweep:true},
  {time:'11:08',type:'CALL',strike:595,expiry:'03/06',premium:512000,size:1700,sentiment:'bullish',sweep:false},
  {time:'11:24',type:'CALL',strike:590,expiry:'02/27',premium:888000,size:2900,sentiment:'bullish',sweep:true},
];
function mockGEX(){ return { flipLevel:P.GEX_FLIP, keyLevels:[
  {price:P.GEX_CWALL,       gex:2.8,  type:'call wall'},
  {price:P.GEX_FLIP+6,      gex:1.5,  type:'resistance'},
  {price:price,              gex:0.3,  type:'current'},
  {price:P.GEX_FLIP,        gex:0,    type:'gamma flip'},
  {price:P.GEX_FLIP-6,      gex:-1.3, type:'support'},
  {price:P.GEX_PWALL,       gex:-2.5, type:'put wall'},
]};}
const getFlow=()=> uwFlow.length ? uwFlow : MOCK_FLOW;
const getGEX =()=> sgGEX || mockGEX();

function genCandles(base,n,iv){ const c=[]; let p=base,now=Date.now(); for(let i=n;i>=0;i--){const o=p,ch=(Math.random()-.48)*1.8,cl=Math.max(o+ch,base*.95); c.push({t:now-i*iv*1000,o,h:Math.max(o,cl)+Math.random()*.5,l:Math.min(o,cl)-Math.random()*.5,c:cl,v:Math.floor(700000+Math.random()*500000)}); p=cl;} return c; }

// â”€â”€ MATH
function ema(cs,n){const k=2/(n+1);let e=cs[0].c;return cs.map((c,i)=>({t:c.t,v:i?e=c.c*k+e*(1-k):e}));}
function vwap(cs){let tv=0,vv=0;return cs.map(c=>{const tp=(c.h+c.l+c.c)/3;tv+=tp*c.v;vv+=c.v;return{t:c.t,v:tv/vv}});}
function hvn(cs){const bs=0.25,b={};cs.forEach(c=>{const lo=Math.floor(c.l/bs)*bs,hi=Math.ceil(c.h/bs)*bs;for(let p=lo;p<=hi;p=parseFloat((p+bs).toFixed(2)))b[p]=(b[p]||0)+c.v});return Object.entries(b).map(([p,v])=>({price:+p,vol:v})).sort((a,z)=>z.vol-a.vol).slice(0,6).map(n=>n.price);}
function orb(cs){const o=cs.slice(0,P.ORB_CANDLES);if(o.length<P.ORB_CANDLES)return null;const h=Math.max(...o.map(c=>c.h)),l=Math.min(...o.map(c=>c.l));return{high:h,low:l,mid:(h+l)/2};}
function delta(cs,fl){const r=cs.slice(-P.DELTA_LOOKBACK),up=r.at(-1).c>r[0].c,dn=r.at(-1).c<r[0].c,cd=fl.filter(f=>f.type==='CALL').reduce((a,b)=>a+b.premium,0),pd=fl.filter(f=>f.type==='PUT').reduce((a,b)=>a+b.premium,0);return{bull:dn&&cd>pd*P.DELTA_RATIO,bear:up&&pd>cd*P.DELTA_RATIO,cd,pd};}
function fibs(cs){
  const lookback=cs.slice(-40);
  const hi=Math.max(...lookback.map(c=>c.h)), lo=Math.min(...lookback.map(c=>c.l)), rng=hi-lo;
  return [lo+rng*0.382,lo+rng*0.500,lo+rng*0.618,hi-rng*0.382,hi-rng*0.500,hi-rng*0.618];
}
function nearFib(fibLevels,p){return fibLevels.some(f=>Math.abs(p-f)<P.FIB_PROX);}

// RSI â€” 14-period on 5m candles
function rsi(cs,n=P.RSI_PERIOD){
  if(cs.length<n+1) return 50;
  let gains=0,losses=0;
  for(let i=cs.length-n;i<cs.length;i++){
    const d=cs[i].c-cs[i-1].c;
    if(d>0) gains+=d; else losses+=Math.abs(d);
  }
  const ag=gains/n, al=losses/n;
  return al===0?100:100-(100/(1+ag/al));
}

// Volume filter â€” current 5m candle vs avg of last N x 5m candles
// Only applied between P.RSI_HOUR_START and P.RSI_HOUR_END ET
function volRising(c5){
  const etH=new Date(new Date().toLocaleString('en-US',{timeZone:'America/New_York'})).getHours();
  if(etH<P.RSI_HOUR_START||etH>=P.RSI_HOUR_END) return true;
  if(c5.length<P.VOL_LOOKBACK_5M+1) return true;
  const recent=c5.slice(-(P.VOL_LOOKBACK_5M+1),-1); // last N completed 5m candles
  const avg=recent.reduce((a,c)=>a+c.v,0)/recent.length;
  const cur=c5.at(-1).v;
  return cur>=avg*P.VOL_MIN_RATIO;
}


// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  v1.7 THREE-SIGNAL ENGINE
//  Signal 1: MOMENTUM    â€” EMA trend + 5m retest
//  Signal 2: LEVEL REACT â€” GEX-physics-aware level reaction
//  Signal 3: FLOW CONV   â€” sweeps + clustering + momentum ratio
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  GEX â€” Real chain data from Tradier (OI Ã— gamma per strike)
//  Replaces flow-print proxy with structural dealer obligation data
//  History: last 6 snapshots (30 min at 5-min intervals)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
let gexHistory=[];          // [{ts, flip, cwall, pwall, netGEX, byStrike}]
let gexLastRefresh=null;
let gexDataValid=false;
let gexChainFetching=false; // prevent concurrent fetches

// Velocity: compare current snapshot to one ~15 min ago
function gexShiftVelocity(){
  if(gexHistory.length<2) return{flipV:0,cwallV:0,pwallV:0,flipDir:null,minutes:0,meaningful:false};
  const cur=gexHistory.at(-1);
  // Find snapshot closest to 15 min ago
  const target=cur.ts-15*60*1000;
  const old=gexHistory.reduce((best,s)=>Math.abs(s.ts-target)<Math.abs(best.ts-target)?s:best,gexHistory[0]);
  const minutes=(cur.ts-old.ts)/(60*1000);
  if(minutes<3) return{flipV:0,cwallV:0,pwallV:0,flipDir:null,minutes:0,meaningful:false};
  const flipV=cur.flip-old.flip;       // + = flip moving up (bullish shift)
  const cwallV=cur.cwall-old.cwall;    // + = call wall rising
  const pwallV=cur.pwall-old.pwall;    // + = put wall rising
  const meaningful=Math.abs(flipV)>=1.0||Math.abs(cwallV)>=1.0||Math.abs(pwallV)>=1.0;
  // flipDir: is flip migrating toward or away from price?
  const flipDir=flipV===0?null:flipV>0?'UP':'DOWN';
  return{flipV,cwallV,pwallV,flipDir,minutes:Math.round(minutes),meaningful};
}

// Legacy alias â€” scoreGEXField uses vel.callV/putV in wall compression check
function gexWallVelocity(){
  const v=gexShiftVelocity();
  return{callV:v.cwallV,putV:v.pwallV};
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  SIGNAL 2: TREND â€” Three regimes, no penalties
//
//  ESTABLISHED: 15m 8/21 EMA stack confirmed + 5m aligned 2+ candles
//  LEADING:     Price through both 15m EMA values + EMAs converging
//               within $1 + 5m confirmed cross 2+ candles
//  NEUTRAL:     Neither condition met
//
//  Key insight: Price position is real-time. EMA lines lag.
//  LEADING catches V-recoveries before the 15m line catches up.
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function scoreTrend(c5, c15){
  const nil={active:false,regime:'NEUTRAL',direction:null,score:0,
    detail:'Insufficient data â€” need 10+ candles on both timeframes',
    candles15:c15.length,ema8_15:0,ema21_15:0};
  if(c5.length<10||c15.length<10) return nil;

  // â”€â”€ 15m EMA values
  const e8b=ema(c15,8), e21b=ema(c15,21);
  const e8bv=e8b.at(-1).v, e21bv=e21b.at(-1).v;
  const e8bPrev=e8b.at(-2)?.v??e8bv, e21bPrev=e21b.at(-2)?.v??e21bv;
  const e8bPrev2=e8b.at(-3)?.v??e8bPrev, e21bPrev2=e21b.at(-3)?.v??e21bPrev;
  const L15=c15.at(-1);

  // 15m EMA cross states
  const bull15Stack=e8bv>e21bv;
  const bear15Stack=e8bv<e21bv;
  const bull15Cross=e8bPrev<=e21bPrev&&e8bv>e21bv; // fresh bull cross this candle
  const bear15Cross=e8bPrev>=e21bPrev&&e8bv<e21bv; // fresh bear cross this candle

  // 15m EMA gap â€” convergence metrics
  const gapNow=Math.abs(e8bv-e21bv);
  const gapPrev2=Math.abs(e8bPrev2-e21bPrev2);
  const converging=gapNow<gapPrev2; // gap is shrinking over last 2 candles

  // â”€â”€ 5m EMA values
  const e8_5=ema(c5,8), e21_5=ema(c5,21);
  const e8_5v=e8_5.at(-1).v, e21_5v=e21_5.at(-1).v;
  const L5=c5.at(-1), P1_5=c5.at(-2)||L5, P2_5=c5.at(-3)||P1_5;

  // 5m confirmed cross: last 2 candle closes both on same side of both EMAs
  const fiveBull2=L5.c>e8_5v&&e8_5v>e21_5v&&P1_5.c>e8_5.at(-2)?.v&&P1_5.c>e21_5.at(-2)?.v;
  const fiveBear2=L5.c<e8_5v&&e8_5v<e21_5v&&P1_5.c<e8_5.at(-2)?.v&&P1_5.c<e21_5.at(-2)?.v;

  // â”€â”€ Stack persistence â€” how many consecutive 15m candles has the stack been in current direction?
  // Counts backward through all available EMA history until the stack flips.
  // A sustained trend scores ESTABLISHED even with a compressed gap (EMAs converged after a long move).
  const e8All=ema(c15,8), e21All=ema(c15,21);
  let bullPersist=0, bearPersist=0;
  for(let i=e8All.length-1;i>=0;i--){
    if(e8All[i].v>e21All[i].v) bullPersist++; else break;
  }
  for(let i=e8All.length-1;i>=0;i--){
    if(e8All[i].v<e21All[i].v) bearPersist++; else break;
  }
  const PERSIST_MIN=3; // 3+ consecutive 15m candles = 45+ minutes of sustained stack

  // â”€â”€ ESTABLISHED requires:
  //   â€¢ EMA stack confirmed in direction
  //   â€¢ Price on correct side of 8 EMA
  //   â€¢ 5m confirmed (2+ closes)
  //   â€¢ EITHER: gap â‰¥ $0.50 (fresh/strong cross)
  //      OR: stack persisted 3+ candles (sustained trend, gap may be compressed)
  const establishedBull=bull15Stack&&(gapNow>=0.50||bullPersist>=PERSIST_MIN)&&L15.c>e8bv&&fiveBull2;
  const establishedBear=bear15Stack&&(gapNow>=0.50||bearPersist>=PERSIST_MIN)&&L15.c<e8bv&&fiveBear2;

  // 15m price position (real-time, not lagging EMA lines)
  const priceAboveBoth15=L15.c>e8bv&&L15.c>e21bv;
  const priceBelowBoth15=L15.c<e8bv&&L15.c<e21bv;

  const synthTag=c15.at(-1)?.synthetic?' [synth]':'';
  const emaStr=`15m(${c15.length}) 8/${e8bv.toFixed(2)} 21/${e21bv.toFixed(2)} gap $${gapNow.toFixed(2)}${synthTag}`;

  // â”€â”€ ESTABLISHED BULL
  if(establishedBull){
    const fresh=bull15Cross||e8b.slice(-3).some((v,i,a)=>i>0&&a[i-1].v<=e21b.at(-(3-i))?.v&&v.v>e21b.at(-(3-i))?.v);
    const score=fresh?92:82;
    const persistStr=bullPersist>=PERSIST_MIN?` Â· ${bullPersist} candles sustained`:'';
    return{active:true,regime:'ESTABLISHED',direction:'CALL',score,
      detail:`15m bullish stack${bull15Cross?' Â· fresh cross':''}${fresh&&!bull15Cross?' Â· recent cross':''}${persistStr} Â· 5m confirmed Â· ${emaStr}`,
      candles15:c15.length,ema8_15:e8bv,ema21_15:e21bv,gapNow,converging,bullPersist,bearPersist};
  }
  // â”€â”€ ESTABLISHED BEAR
  if(establishedBear){
    const fresh=bear15Cross||e8b.slice(-3).some((v,i,a)=>i>0&&a[i-1].v>=e21b.at(-(3-i))?.v&&v.v<e21b.at(-(3-i))?.v);
    const score=fresh?92:82;
    const persistStr=bearPersist>=PERSIST_MIN?` Â· ${bearPersist} candles sustained`:'';
    return{active:true,regime:'ESTABLISHED',direction:'PUT',score,
      detail:`15m bearish stack${bear15Cross?' Â· fresh cross':''}${fresh&&!bear15Cross?' Â· recent cross':''}${persistStr} Â· 5m confirmed Â· ${emaStr}`,
      candles15:c15.length,ema8_15:e8bv,ema21_15:e21bv,gapNow,converging,bullPersist,bearPersist};
  }

  // â”€â”€ LEADING BULL: price reclaimed both 15m EMA values, EMAs converging within $1, 5m confirmed
  if(priceAboveBoth15&&gapNow<1.00&&converging&&fiveBull2){
    const score=Math.round(60+Math.min(15,(1.00-gapNow)*15));
    return{active:true,regime:'LEADING',direction:'CALL',score,
      detail:`Price through both 15m EMAs Â· gap $${gapNow.toFixed(2)} converging Â· 5m confirmed Â· ${emaStr}`,
      candles15:c15.length,ema8_15:e8bv,ema21_15:e21bv,gapNow,converging};
  }
  // â”€â”€ LEADING BEAR
  if(priceBelowBoth15&&gapNow<1.00&&converging&&fiveBear2){
    const score=Math.round(60+Math.min(15,(1.00-gapNow)*15));
    return{active:true,regime:'LEADING',direction:'PUT',score,
      detail:`Price below both 15m EMAs Â· gap $${gapNow.toFixed(2)} converging Â· 5m confirmed Â· ${emaStr}`,
      candles15:c15.length,ema8_15:e8bv,ema21_15:e21bv,gapNow,converging};
  }

  // â”€â”€ NEUTRAL â€” describe why
  let reason='';
  if(bull15Stack&&gapNow<0.50&&bullPersist<PERSIST_MIN)
    reason=`15m bullish stack Â· gap $${gapNow.toFixed(2)} Â· only ${bullPersist} candle${bullPersist!==1?'s':''} (need $0.50 gap OR ${PERSIST_MIN}+ candles)`;
  else if(bear15Stack&&gapNow<0.50&&bearPersist<PERSIST_MIN)
    reason=`15m bearish stack Â· gap $${gapNow.toFixed(2)} Â· only ${bearPersist} candle${bearPersist!==1?'s':''} (need $0.50 gap OR ${PERSIST_MIN}+ candles)`;
  else if(bull15Stack&&L15.c<=e8bv)
    reason=`15m bullish stack but price $${L15.c.toFixed(2)} below 8 EMA $${e8bv.toFixed(2)} â€” below stack, not ESTABLISHED`;
  else if(bear15Stack&&L15.c>=e8bv)
    reason=`15m bearish stack but price $${L15.c.toFixed(2)} above 8 EMA $${e8bv.toFixed(2)} â€” above stack, not ESTABLISHED`;
  else if(bull15Stack&&!fiveBull2)
    reason=`15m bullish stack${bullPersist>=PERSIST_MIN?' Â· '+bullPersist+' candles':''} Â· 5m not yet confirmed (need 2 closes above EMAs)`;
  else if(bear15Stack&&!fiveBear2)
    reason=`15m bearish stack${bearPersist>=PERSIST_MIN?' Â· '+bearPersist+' candles':''} Â· 5m not yet confirmed`;
  else if(gapNow>=1.00)
    reason=`15m EMAs $${gapNow.toFixed(2)} apart â€” too wide for LEADING (need <$1.00)`;
  else if(!converging)
    reason='15m EMAs diverging â€” rotation not confirmed yet';
  else
    reason='EMA structure mixed â€” no clear regime';

  return{active:false,regime:'NEUTRAL',direction:null,score:0,
    detail:`Neutral â€” ${reason} Â· ${emaStr}`,
    candles15:c15.length,ema8_15:e8bv,ema21_15:e21bv,gapNow,converging};
}



// â”€â”€ BLACKOUT HELPER â€” APEX never fires in pre-10am or post-3:30pm windows
function isBlackout(){
  const et=new Date(new Date().toLocaleString('en-US',{timeZone:'America/New_York'}));
  const m=et.getHours()*60+et.getMinutes();
  return (m>=P.APEX_BO_AM_START&&m<P.APEX_BO_AM_END)||(m>=P.APEX_BO_PM_START&&m<P.APEX_BO_PM_END);
}
function blackoutLabel(){
  const et=new Date(new Date().toLocaleString('en-US',{timeZone:'America/New_York'}));
  const m=et.getHours()*60+et.getMinutes();
  if(m>=P.APEX_BO_AM_START&&m<P.APEX_BO_AM_END) return'BUILDING (pre-10am)';
  if(m>=P.APEX_BO_PM_START&&m<P.APEX_BO_PM_END) return'CLOSED (post-3:30pm)';
  return null;
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  GEX GATE â€” CONTINUATION ARCHITECTURE
//  Session state tracks confirmed cleared/support levels so the gate
//  can recognise trend continuation, not just static level proximity.
//
//  LEVEL TIERS (session-relative, normalised to dominant = 100)
//    Major    â‰¥60  : call/put walls, gamma flip, large DP clusters
//    Moderate 25â€“59: meaningful S/R with institutional footprint
//    Minor    <25  : noise â€” ignored UNLESS absolutePremium â‰¥ $15M
//
//  CONTINUATION RULES
//    Rule 1 â€” Major cleared as support, NOTHING within $4 ahead â†’ FLOAT
//    Rule 2 â€” Moderate cleared/absorbed, moderate/major within $4
//             AND major within $6 of that moderate â†’ STEPPING_STONE
//    Rule 3 â€” Major cleared as support, another major within $4 ahead
//             â†’ MAJOR_TO_MAJOR (highest conviction)
//
//  CLEARANCE CONFIRMATION (liquidity grab filter)
//    A level is "confirmed cleared" only when 2+ consecutive candle
//    closes are on the far side AND clearance candles are larger-bodied
//    than approach candles (momentum, not exhaustion).
//
//  DEX runs at every stage â€” at cleared level it confirms support
//  character; in continuation it evaluates dealer positioning at
//  the destination major (approach vs through-break modes).
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// Session-persistent state â€” reset at session start via resetGEXState()
let gexLevelState={
  clearedMajors:[],    // [{price,type,side,confirmedAt,refPrice,sig}]
  clearedModerates:[], // [{price,type,side,confirmedAt,refPrice,sig}]
  supportAnchors:[],   // [{price,type,tier,side,lastSeenAt}]
  lastResetDate:'',
};
function resetGEXState(){
  const d=new Date().toLocaleDateString('en-US',{timeZone:'America/New_York'});
  if(gexLevelState.lastResetDate!==d){
    gexLevelState={clearedMajors:[],clearedModerates:[],supportAnchors:[],lastResetDate:d};
  }
}

// Returns true if last N candles all closed on far side of levelPrice in dir
function isConfirmedClear(c5,levelPrice,dir,n=2){
  const recent=c5.slice(-n);
  if(recent.length<n) return false;
  return dir==='CALL'?recent.every(cn=>cn.c>levelPrice):recent.every(cn=>cn.c<levelPrice);
}

// Returns true if clearance candles are larger-bodied than approach (momentum, not grab)
function isDecisiveClear(c5,n=2){
  const clearCandles=c5.slice(-n);
  const approachCandles=c5.slice(-(n+3),-n);
  if(!approachCandles.length) return true; // can't check, assume ok
  const avgClear=clearCandles.reduce((a,cn)=>a+Math.abs(cn.c-cn.o),0)/clearCandles.length;
  const avgApproach=approachCandles.reduce((a,cn)=>a+Math.abs(cn.c-cn.o),0)/approachCandles.length;
  return avgClear>=avgApproach*0.7; // clearance candles at least 70% size of approach
}

// Returns true if price touched this level as support/resistance within lookback candles
function isSupportTouch(c5,levelPrice,dir,lookback=6){
  const recent=c5.slice(-lookback);
  return recent.some(cn=>{
    const dist=Math.abs(cn.l-levelPrice); // bull: wick low near level
    const distH=Math.abs(cn.h-levelPrice); // bear: wick high near level
    return dir==='CALL'?(dist<=P.GEX_SUPPORT_PROX&&cn.c>levelPrice):
                        (distH<=P.GEX_SUPPORT_PROX&&cn.c<levelPrice);
  });
}

function scoreGEXGate(c5,gx,fl){
  resetGEXState();
  const nil={active:false,direction:null,gateScore:0,score:0,zone:'NO_DATA',
    detail:'GEX data building',subItems:['Waiting for 0DTE flow data'],
    entry:price,target:price,stop:price,levelName:'â€”'};
  if(!gx||!gx.keyLevels||c5.length<5) return nil;

  const L=c5.at(-1),prev=c5.at(-2);
  const vel=gexWallVelocity();
  const posGEX=L.c>gx.flipLevel;
  const dex=fl&&fl.length?computeDEX(fl):{direction:null,strong:false,detail:'No data'};

  // â”€â”€ BUILD NORMALISED LEVEL HIERARCHY â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  const raw=[];
  for(const kl of gx.keyLevels){
    if(kl.type==='current') continue;
    raw.push({price:kl.price,type:kl.type,gexVal:kl.gex,
      rawSig:Math.round(Math.abs(kl.gex)/2.8*100),prem:0,
      dist:Math.abs(L.c-kl.price),side:kl.price>L.c?'above':'below'});
  }
  for(const dp of dpLevels.slice(0,6))
    raw.push({price:dp.price,type:`DP $${(dp.totalPremium/1e6).toFixed(0)}M`,gexVal:0,
      rawSig:Math.min(80,Math.round(dp.totalPremium/2e6*100)),prem:dp.totalPremium,
      dist:Math.abs(L.c-dp.price),side:dp.price>L.c?'above':'below'});
  for(const h of hvn(c5))
    raw.push({price:h,type:'HVN',gexVal:0,rawSig:40,prem:0,
      dist:Math.abs(L.c-h),side:h>L.c?'above':'below'});

  if(!raw.length) return nil;
  const maxSig=Math.max(...raw.map(l=>l.rawSig),1);
  const allLevels=raw.map(l=>({...l,
    sig:Math.round(l.rawSig/maxSig*100),
    tier:l.rawSig/maxSig>=0.60?'major':l.rawSig/maxSig>=0.25?'moderate':'minor',
  })).filter(l=>{
    if(l.tier==='minor'&&l.prem>0&&l.prem<P.GEX_ABS_MIN_PREM) return false; // absolute minor floor
    return l.dist<18;
  }).sort((a,b)=>a.dist-b.dist);

  const majors=allLevels.filter(l=>l.tier==='major');
  const moderates=allLevels.filter(l=>l.tier==='moderate');

  // â”€â”€ UPDATE SESSION STATE â€” clearances and support touches â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // Check all known levels for new confirmed clearances this scan
  for(const lv of allLevels){
    // Clearance check: both CALL and PUT directions
    for(const dir of['CALL','PUT']){
      const cleared=isConfirmedClear(c5,lv.price,dir,P.GEX_CLR_CANDLES);
      const decisive=cleared&&isDecisiveClear(c5,P.GEX_CLR_CANDLES);
      if(!cleared||!decisive) continue;

      if(lv.tier==='major'){
        const already=gexLevelState.clearedMajors.find(m=>Math.abs(m.price-lv.price)<0.5&&m.dir===dir);
        if(!already) gexLevelState.clearedMajors.push({...lv,dir,confirmedAt:Date.now(),refPrice:L.c});
      } else if(lv.tier==='moderate'){
        const already=gexLevelState.clearedModerates.find(m=>Math.abs(m.price-lv.price)<0.5&&m.dir===dir);
        if(!already) gexLevelState.clearedModerates.push({...lv,dir,confirmedAt:Date.now(),refPrice:L.c});
      }
    }
    // Support touch check
    for(const dir of['CALL','PUT']){
      if(isSupportTouch(c5,lv.price,dir)){
        const already=gexLevelState.supportAnchors.find(s=>Math.abs(s.price-lv.price)<0.5&&s.dir===dir);
        if(!already) gexLevelState.supportAnchors.push({...lv,dir,lastSeenAt:Date.now()});
        else already.lastSeenAt=Date.now();
      }
    }
  }
  // Expire old state entries (older than 4 hours)
  const expiry=4*60*60*1000;
  gexLevelState.clearedMajors=gexLevelState.clearedMajors.filter(m=>Date.now()-m.confirmedAt<expiry);
  gexLevelState.clearedModerates=gexLevelState.clearedModerates.filter(m=>Date.now()-m.confirmedAt<expiry);
  gexLevelState.supportAnchors=gexLevelState.supportAnchors.filter(s=>Date.now()-s.lastSeenAt<expiry);

  // â”€â”€ HELPER: levels in direction from a reference price â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  const levelsAhead=(refP,dir,tiers=['major','moderate'])=>
    allLevels.filter(lv=>tiers.includes(lv.tier)&&(dir==='CALL'?lv.price>refP:lv.price<refP));
  const nearestAhead=(refP,dir,tiers)=>{
    const ahead=levelsAhead(refP,dir,tiers);
    return ahead.length?ahead.reduce((a,b)=>Math.abs(b.price-refP)<Math.abs(a.price-refP)?b:a):null;
  };
  const distFromRef=(lv,refP)=>Math.abs(lv.price-refP);

  // â”€â”€ CONTINUATION MODE CHECK â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // Look for cleared majors behind price that have support anchor character
  const contDir=posGEX?null:null; // will be set below
  let contMode=null; // 'MAJOR_TO_MAJOR'|'STEPPING_STONE'|null

  // Find cleared major that is now BEHIND current price (used as support)
  const anchoredMajor=gexLevelState.clearedMajors.find(cm=>{
    const behindBull=cm.dir==='CALL'&&cm.price<L.c&&(L.c-cm.price)>0.5;
    const behindBear=cm.dir==='PUT'&&cm.price>L.c&&(cm.price-L.c)>0.5;
    return behindBull||behindBear;
  });

  // Find cleared moderate that is now BEHIND current price (stepping stone)
  const anchoredModerate=gexLevelState.clearedModerates.find(cm=>{
    const behindBull=cm.dir==='CALL'&&cm.price<L.c&&(L.c-cm.price)>0.5;
    const behindBear=cm.dir==='PUT'&&cm.price>L.c&&(cm.price-L.c)>0.5;
    return behindBull||behindBear;
  });

  let contAnchor=null, contDirection=null, contLabel='', gs=0, items=[];

  if(anchoredMajor){
    contDirection=anchoredMajor.dir;
    const refP=anchoredMajor.refPrice; // price when cleared

    // What's ahead of current price in continuation direction?
    const nextMajor=nearestAhead(L.c,contDirection,['major']);
    const nextModerate=nearestAhead(L.c,contDirection,['moderate']);

    // RULE 3 â€” Major ahead within $4 of current price â†’ MAJOR_TO_MAJOR
    if(nextMajor&&distFromRef(nextMajor,L.c)<=P.GEX_CONT_MAJOR_AHEAD){
      contMode='MAJOR_TO_MAJOR';
      contAnchor=anchoredMajor;
      contLabel=`Major-to-major: ${anchoredMajor.type} support â†’ ${nextMajor.type}`;
      const distToNext=distFromRef(nextMajor,L.c);
      const pct=Math.max(0,1-distToNext/P.GEX_CONT_MAJOR_AHEAD);
      gs=Math.round(55+pct*25+anchoredMajor.sig*0.10+nextMajor.sig*0.10);
      items.push(`${contLabel} $${nextMajor.price.toFixed(2)} Â· ${distToNext.toFixed(2)} away`);

      // DEX at destination major â€” approach vs through-break mode
      if(dex.direction&&dex.strong){
        const dexResists=(contDirection==='CALL'&&dex.direction==='PUT')||(contDirection==='PUT'&&dex.direction==='CALL');
        if(dexResists){
          // Dealers resist at destination â€” approach mode, expect reaction
          gs-=5;
          items.push(`DEX: dealers resist at ${nextMajor.type} â€” approach mode, watch for reaction`);
        } else {
          // Dealers must accelerate through â€” through-break mode
          gs+=15;
          items.push(`DEX: dealers forced through ${nextMajor.type} â€” breakout mode`);
        }
      }

      // 1DTE
      if(gx.agreement==='agree'){gs+=8;items.push('1DTE agrees with continuation');}
      else if(gx.agreement==='disagree'){gs-=10;items.push('âš  1DTE disagrees â€” tomorrow conflicts');}

    // RULE 1 â€” Nothing useful within $4 â†’ FLOAT (no trigger)
    } else if(!nextMajor||(nextModerate&&distFromRef(nextModerate,L.c)>P.GEX_CONT_MOD_AHEAD)){
      // Nothing within striking distance â€” float, no continuation trigger
      gs=Math.min(25,Math.round(anchoredMajor.sig*0.20));
      const nearLabel=nextMajor?`nearest major $${nextMajor.price.toFixed(0)} $${distFromRef(nextMajor,L.c).toFixed(1)} away`:'no major ahead';
      return{active:false,direction:contDirection,gateScore:gs,score:gs,zone:'FLOAT',
        detail:`Float â€” ${anchoredMajor.type} support behind, ${nearLabel} Â· no trigger`,
        subItems:[
          `Cleared major support: ${anchoredMajor.type} $${anchoredMajor.price.toFixed(2)}`,
          `Rule 1: nothing within $${P.GEX_CONT_MAJOR_AHEAD} ahead â€” no continuation trigger`,
          nearLabel,
        ],
        entry:L.c,target:contDirection==='CALL'?L.c+P.LVL_TGT:L.c-P.LVL_TGT,
        stop:contDirection==='CALL'?L.c-P.LVL_STOP:L.c+P.LVL_STOP,
        levelName:anchoredMajor.type,posGEX,levels:allLevels,majors,moderates};

    } else if(nextModerate&&distFromRef(nextModerate,L.c)<=P.GEX_CONT_MOD_AHEAD){
      // Moderate ahead but no major within $4 â€” check major within $6 of the moderate
      const majorNearModerate=nearestAhead(nextModerate.price,contDirection,['major']);
      if(majorNearModerate&&distFromRef(majorNearModerate,nextModerate.price)<=P.GEX_CONT_MAJ_FROM_MOD){
        // Treat as stepping stone to major
        contMode='STEPPING_STONE';
        contAnchor=anchoredMajor;
        contLabel=`Stepping stone: ${anchoredMajor.type} â†’ ${nextModerate.type} â†’ ${majorNearModerate.type}`;
        const distToMod=distFromRef(nextModerate,L.c);
        const pct=Math.max(0,1-distToMod/P.GEX_CONT_MOD_AHEAD);
        gs=Math.round(42+pct*18+anchoredMajor.sig*0.08+majorNearModerate.sig*0.08);
        items.push(`${contLabel}`);
        items.push(`Next moderate: $${nextModerate.price.toFixed(2)} Â· major destination: $${majorNearModerate.price.toFixed(2)}`);
        if(dex.direction&&dex.strong){
          if(dex.direction===contDirection){gs+=10;items.push('DEX confirms continuation direction');}
          else{gs-=8;items.push('âš  DEX contradicts continuation â€” reduced confidence');}
        }
        if(gx.agreement==='agree'){gs+=8;items.push('1DTE agrees');}
        else if(gx.agreement==='disagree'){gs-=10;items.push('âš  1DTE disagrees');}
      } else {
        // Moderate ahead but no major within $6 of it â€” float
        gs=Math.min(20,Math.round(anchoredMajor.sig*0.15));
        return{active:false,direction:contDirection,gateScore:gs,score:gs,zone:'FLOAT',
          detail:`Float â€” moderate ahead but no major within $${P.GEX_CONT_MAJ_FROM_MOD} Â· no trigger`,
          subItems:[
            `Cleared major: ${anchoredMajor.type} $${anchoredMajor.price.toFixed(2)} support`,
            `Moderate ${nextModerate.type} $${nextModerate.price.toFixed(2)} ahead but no supporting major`,
            `Rule 1: structure insufficient for continuation trigger`,
          ],
          entry:L.c,target:contDirection==='CALL'?L.c+P.LVL_TGT:L.c-P.LVL_TGT,
          stop:contDirection==='CALL'?L.c-P.LVL_STOP:L.c+P.LVL_STOP,
          levelName:anchoredMajor.type,posGEX,levels:allLevels,majors,moderates};
      }
    }

  } else if(anchoredModerate&&!anchoredMajor){
    // RULE 2 â€” Moderate cleared as support, check for structure ahead
    contDirection=anchoredModerate.dir;
    const nextMajInRange=nearestAhead(anchoredModerate.price,contDirection,['major']);
    const nextModInRange=nearestAhead(L.c,contDirection,['moderate','major']);

    const majWithin6=nextMajInRange&&distFromRef(nextMajInRange,anchoredModerate.price)<=P.GEX_CONT_MAJ_FROM_MOD;
    const modOrMajWithin4=nextModInRange&&distFromRef(nextModInRange,L.c)<=P.GEX_CONT_MOD_AHEAD;

    if(majWithin6&&modOrMajWithin4){
      contMode='STEPPING_STONE';
      contAnchor=anchoredModerate;
      contLabel=`Moderate support: ${anchoredModerate.type} â†’ ${nextModInRange.type}`;
      const distToNext=distFromRef(nextModInRange,L.c);
      const pct=Math.max(0,1-distToNext/P.GEX_CONT_MOD_AHEAD);
      gs=Math.round(38+pct*16+anchoredModerate.sig*0.08+(nextMajInRange?nextMajInRange.sig*0.08:0));
      items.push(`Rule 2 â€” ${contLabel}`);
      items.push(`Next level: $${nextModInRange.price.toFixed(2)} Â· major within $6: $${nextMajInRange?nextMajInRange.price.toFixed(2):'none'}`);
      if(dex.direction&&dex.strong){
        if(dex.direction===contDirection){gs+=10;items.push('DEX confirms direction');}
        else{gs-=8;items.push('âš  DEX contradicts');}
      }
      if(gx.agreement==='agree'){gs+=8;items.push('1DTE agrees');}
      else if(gx.agreement==='disagree'){gs-=10;items.push('âš  1DTE disagrees');}
    }
  }

  // â”€â”€ CONTINUATION RESULT â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  if(contMode&&contDirection&&gs>0){
    // Minor/moderate scoring: only count if major exists within $4 in direction
    const majAheadForMinors=nearestAhead(L.c,contDirection,['major']);
    const majClose=majAheadForMinors&&distFromRef(majAheadForMinors,L.c)<=P.GEX_CONT_MAJOR_AHEAD;
    const lookbackC=c5.slice(-(P.GEX_CLR_LOOKBACK+1),-1);
    const oldP2=lookbackC.length?lookbackC[0].c:L.c;
    const absorbedModeratesAhead=moderates.filter(m=>{
      if(!majClose) return false; // no major ahead = ignore minor/moderate
      return contDirection==='CALL'?(oldP2<m.price&&L.c>m.price):(oldP2>m.price&&L.c<m.price);
    });
    if(absorbedModeratesAhead.length){
      gs+=12;
      items.push(`Absorbed ${absorbedModeratesAhead.length} moderate level${absorbedModeratesAhead.length>1?'s':''} en route â€” momentum confirmed`);
    }

    // Significance bonus for anchor
    if(contAnchor&&contAnchor.sig>=80) items.push(`Anchor dominance (sig ${contAnchor.sig})`);

    // Wall velocity
    if(contDirection==='CALL'&&vel.callV<-0.5){gs+=8;items.push(`Call wall compressing $${vel.callV.toFixed(1)}`);}
    if(contDirection==='PUT'&&vel.putV>0.5){gs+=8;items.push(`Put wall compressing +$${vel.putV.toFixed(1)}`);}

    if(gx.source) items.push(`GEX source: ${gx.source}`);
    gs=Math.min(gs,100);
    const active=gs>=45;
    const zoneLabel=contMode==='MAJOR_TO_MAJOR'?'MAJOR_TO_MAJOR':'STEPPING_STONE';
    return{active,direction:contDirection,gateScore:gs,score:gs,zone:zoneLabel,
      detail:`${contLabel} Â· ${posGEX?'Pos':'Neg'} GEX${dex.strong?' Â· DEX '+dex.direction:''}`,
      subItems:items,entry:L.c,
      target:contDirection==='CALL'?L.c+P.LVL_TGT:L.c-P.LVL_TGT,
      stop:contDirection==='CALL'?L.c-P.LVL_STOP:L.c+P.LVL_STOP,
      levelName:contAnchor?contAnchor.type:'â€”',posGEX,isBreakout:false,dex,
      contMode,contAnchor,levels:allLevels,majors,moderates};
  }

  // â”€â”€ STATIC ZONE LOGIC (no cleared anchor â€” original APPROACH/AT_LEVEL) â”€â”€
  const nm=majors.length?majors.reduce((a,b)=>a.dist<b.dist?a:b):null;

  if(!nm||nm.dist>P.GEX_APPROACH){
    // FLOAT â€” gravitational pull only
    let bullPull=0,bearPull=0;
    for(const m of majors){const p=m.sig/Math.max(m.dist*m.dist,0.1);m.side==='above'?bullPull+=p:bearPull+=p;}
    const net=bullPull-bearPull;
    const pullDir=net>2?'CALL':net<-2?'PUT':null;
    const pullScore=Math.min(30,Math.round(Math.abs(net)*0.4));
    const nearLabel=nm?`${nm.type} $${nm.price.toFixed(0)} $${nm.dist.toFixed(1)} away`:'no major levels';
    return{active:false,direction:pullDir,gateScore:pullScore,score:pullScore,zone:'FLOAT',
      detail:`Float â€” ${nearLabel} Â· ${pullDir?pullDir+' bias':'neutral gravity'}`,
      subItems:[`Nearest major: ${nearLabel}`,
        pullDir?`Net gravitational pull: ${pullDir} (${net.toFixed(1)})`:'Balanced level gravity â€” no clear pull',
        `Majors: ${majors.length} Â· Moderates: ${moderates.length}`,
      ],
      entry:L.c,target:pullDir==='CALL'?L.c+P.LVL_TGT:L.c-P.LVL_TGT,
      stop:pullDir==='CALL'?L.c-P.LVL_STOP:L.c+P.LVL_STOP,
      levelName:nm?nm.type:'â€”',posGEX,levels:allLevels,majors,moderates};
  }

  // APPROACH or AT_LEVEL
  const zone=nm.dist<=P.GEX_AT_LEVEL?'AT_LEVEL':'APPROACH';
  let dir,modeLabel,isBreakout=false;
  if(zone==='APPROACH'){
    dir=nm.side==='above'?'CALL':'PUT';
    modeLabel=`Approaching ${nm.type}`;
  } else {
    if(posGEX){dir=nm.side==='above'?'PUT':'CALL';modeLabel=`Pos GEX fade â€” ${nm.type}`;isBreakout=false;}
    else{dir=nm.side==='above'?'CALL':'PUT';modeLabel=`Neg GEX breakout â€” ${nm.type}`;isBreakout=true;}
  }

  let gs2=0; const items2=[];

  if(zone==='AT_LEVEL'){
    gs2+=50+Math.round((P.GEX_AT_LEVEL-nm.dist)/P.GEX_AT_LEVEL*20);
    items2.push(`${modeLabel} $${nm.price.toFixed(2)} Â· sig ${nm.sig}`);
    const abLvl=L.c>nm.price;
    const rejecting=abLvl?(L.h>nm.price&&L.c<nm.price&&L.c<prev.c):(L.l<nm.price&&L.c>nm.price&&L.c>prev.c);
    const breaking=abLvl?(L.c>nm.price&&prev.c<nm.price):(L.c<nm.price&&prev.c>nm.price);
    if(rejecting){gs2+=20;items2.push('Rejection candle confirmed (dealer selling)');}
    else if(breaking){gs2+=20;items2.push('Level broken â€” dealer acceleration expected');}
    else items2.push(posGEX?'Touching â€” watching for rejection candle':'Pressing â€” watching for break candle');
  } else {
    const pct=(P.GEX_APPROACH-nm.dist)/P.GEX_APPROACH;
    gs2+=Math.round(20+pct*35+nm.sig*0.15);
    items2.push(`${modeLabel} $${nm.price.toFixed(2)} Â· $${nm.dist.toFixed(2)} away Â· sig ${nm.sig}`);
  }

  // Minor/moderate clearance only counts if major within $4 in direction
  const majAheadStatic=nearestAhead(L.c,dir,['major']);
  const majCloseStatic=majAheadStatic&&distFromRef(majAheadStatic,L.c)<=P.GEX_CONT_MAJOR_AHEAD;
  const lookbackS=c5.slice(-(P.GEX_CLR_LOOKBACK+1),-1);
  const oldPS=lookbackS.length?lookbackS[0].c:L.c;
  const clearedMods=moderates.filter(m=>m.dist<=P.GEX_APPROACH&&majCloseStatic&&
    (dir==='CALL'?(oldPS<m.price&&L.c>m.price):(oldPS>m.price&&L.c<m.price)));
  if(clearedMods.length){gs2+=15;items2.push(`Cleared ${clearedMods.length} moderate level${clearedMods.length>1?'s':''} â€” magnet pull confirmed`);}

  if(nm.sig>=80){gs2+=8;items2.push(`Dominant wall (sig ${nm.sig})`);}
  else if(nm.sig>=60) items2.push(`Significant level (sig ${nm.sig})`);

  if(dex.direction&&dex.strong){
    if(dex.direction===dir){gs2+=12;items2.push(`DEX confirms â€” dealers must ${dir==='CALL'?'buy':'sell'} here`);}
    else{gs2-=8;items2.push('âš  DEX contradicts â€” dealer delta resists direction');}
  }
  if(gx.agreement==='agree'){gs2+=8;items2.push(`1DTE agrees${gx.isLastHour?' (last hour blend)':''}`);}
  else if(gx.agreement==='disagree'){gs2-=10;items2.push('âš  1DTE disagrees â€” tomorrow conflicts with today');}
  if(dir==='CALL'&&vel.callV<-0.5){gs2+=8;items2.push(`Call wall compressing $${vel.callV.toFixed(1)}`);}
  if(dir==='PUT'&&vel.putV>0.5){gs2+=8;items2.push(`Put wall compressing +$${vel.putV.toFixed(1)}`);}
  if(gx.source) items2.push(`GEX source: ${gx.source}`);
  gs2=Math.min(gs2,100);

  return{active:gs2>=45&&dir!==null,direction:dir,gateScore:gs2,score:gs2,zone,
    detail:`${modeLabel} $${nm.price.toFixed(2)} Â· ${zone==='AT_LEVEL'?'At level':'Approach'} Â· ${posGEX?'Pos':'Neg'} GEX${dex.strong?' Â· DEX '+dex.direction:''}`,
    subItems:items2,entry:L.c,
    target:dir==='CALL'?L.c+P.LVL_TGT:L.c-P.LVL_TGT,
    stop:dir==='CALL'?L.c-P.LVL_STOP:L.c+P.LVL_STOP,
    levelName:nm.type,levelPrice:nm.price,zone,posGEX,isBreakout,dex,
    nearestMajor:nm,levels:allLevels,majors,moderates};
}
// Legacy alias
function scoreLevelReaction(c5,gx,fl){return scoreGEXGate(c5,gx,fl);}

// â”€â”€ DEX (Delta Exposure) â€” net dealer delta at each strike band
// Dealers are short calls (negative delta) and short puts (positive delta).
// Net dealer delta = -(callDelta) + (putDelta) per strike.
// Where strongly negative â†’ dealers must BUY on rally (accelerant).
// Where strongly positive â†’ dealers must SELL on rally (resistance).
// We approximate delta from moneyness and DTE â€” no need for exact Black-Scholes.
function computeDEX(fl){
  if(!fl.length) return{netDelta:0,callDelta:0,putDelta:0,direction:null,strong:false,nearStrike:null,detail:'No data'};
  const band=price*P.DEX_STRIKE_PCT;
  const nearPrints=fl.filter(f=>f.premium>=P.DEX_MIN_PREM&&f.strike&&Math.abs(f.strike-price)<=band&&f.daysToExp!==null&&f.daysToExp<=7);
  if(!nearPrints.length) return{netDelta:0,callDelta:0,putDelta:0,direction:null,strong:false,nearStrike:null,detail:'No near-term prints in band'};

  // Estimate delta: 0DTE ATM â‰ˆ 0.5, decays with moneyness; scales up as DTEâ†’0
  const estimateDelta=(f)=>{
    const moneyness=Math.abs(f.strike-price)/price; // 0 = ATM
    const dteFactor=f.daysToExp===0?1.0:f.daysToExp===1?0.85:f.daysToExp<=3?0.65:0.50;
    const baseDelta=Math.max(0.05, 0.55 - moneyness*8) * dteFactor;
    return baseDelta;
  };

  // Weight by expiry (soonest = highest weight) and premium
  const expiryWeight=(dte)=>{
    if(dte===0) return P.FLOW_W_0DTE;
    if(dte===1) return P.FLOW_W_1DTE;
    if(dte===2) return P.FLOW_W_2DTE;
    if(dte===3) return P.FLOW_W_3DTE;
    return P.FLOW_W_7DTE;
  };

  let callDelta=0, putDelta=0, totalWeight=0;
  const byStrike={};
  for(const f of nearPrints){
    const d=estimateDelta(f);
    const w=expiryWeight(f.daysToExp);
    const wPrem=f.premium*w;
    if(f.type==='CALL'){
      callDelta+=d*wPrem;
      // Dealer is SHORT the call â†’ negative dealer delta
    } else {
      putDelta+=d*wPrem; // Dealer is SHORT the put â†’ positive dealer delta (puts gain value as price drops)
    }
    totalWeight+=wPrem;
    if(!byStrike[f.strike]) byStrike[f.strike]={calls:0,puts:0};
    byStrike[f.strike][f.type==='CALL'?'calls':'puts']+=wPrem;
  }

  if(!totalWeight) return{netDelta:0,callDelta:0,putDelta:0,direction:null,strong:false,nearStrike:null,detail:'No weighted prints'};

  // Dealer net delta: short calls (negative) + short puts (positive)
  const dealerNetDelta=(putDelta-callDelta)/totalWeight; // negative = dealers short delta = must buy rallies
  const ratio=callDelta/(callDelta+putDelta||1);
  const strong=ratio>=P.DEX_STRONG||ratio<=(1-P.DEX_STRONG);
  const direction=ratio>=P.DEX_STRONG?'PUT':ratio<=(1-P.DEX_STRONG)?'CALL':null; // dealer must buy = bullish for price
  // Most concentrated strike in the band
  const topStrike=Object.entries(byStrike).sort((a,b)=>(b[1].calls+b[1].puts)-(a[1].calls+a[1].puts))[0];
  const nearStrike=topStrike?+topStrike[0]:null;
  return{netDelta:dealerNetDelta,callDelta,putDelta,ratio,direction,strong,nearStrike,
    detail:`DEX ${direction||'neutral'} Â· ${Math.round(ratio*100)}% call-weighted Â· ${nearPrints.length} prints`};
}

// â”€â”€ SIGNAL 3: FLOW CONVICTION
// Three layers:
//   1. Time-weighted positional (30d, exponential recency decay, â‰¤7 DTE only)
//   2. Same-day acceleration check (first vs second half of today's session)
//   3. Live sweeps (30m) + strike magnet (15m, â‰¤3DTE)
function scoreFlowConviction(fl){
  if(!fl.length) return{active:false,direction:null,score:0,detail:'No flow data',subItems:[],entry:price,target:price,stop:price,ratio:0.5,dex:null};

  const now=Date.now();
  const todayOpen=new Date(); // use market open: 9:30am ET today
  todayOpen.setHours(0,0,0,0); // midnight as proxy â€” we'll check ts

  // â”€â”€ RECENCY DECAY WEIGHT
  // Exponential: today's prints dominate, older prints provide context only.
  // Within today we split session in half for acceleration detection.
  const et=new Date(new Date().toLocaleString('en-US',{timeZone:'America/New_York'}));
  const etMins=et.getHours()*60+et.getMinutes();
  const sessionStart=9*60+30; // 9:30am
  const sessionMid=sessionStart+Math.max(0,(etMins-sessionStart)/2); // midpoint of elapsed session
  const sessionMidMs=Date.now()-(etMins-sessionMid)*60*1000;

  const recencyWeight=(f)=>{
    const ageMs=now-f.ts;
    const ageH=ageMs/(1000*60*60);
    if(ageH<1) return P.FLOW_DECAY_TODAY_H2;        // last hour â€” highest weight
    const isTodayH2=f.ts>=sessionMidMs;
    if(isTodayH2) return P.FLOW_DECAY_TODAY_H2;
    const ageD=ageMs/(1000*60*60*24);
    if(ageD<1) return P.FLOW_DECAY_TODAY_H1;         // earlier today
    if(ageD<2) return P.FLOW_DECAY_YESTERDAY;
    if(ageD<4) return P.FLOW_DECAY_3D;
    if(ageD<8) return P.FLOW_DECAY_7D;
    return P.FLOW_DECAY_30D;                          // 8-30 days ago
  };

  // â”€â”€ LAYER 1: TIME-WEIGHTED POSITIONAL (â‰¤7 DTE, all history)
  const positional=fl.filter(f=>f.daysToExp!==null&&f.daysToExp<=7&&f.premium>=P.FLOW_SWEEP_MIN);
  const exW=(dte)=>{
    if(dte===0) return P.FLOW_W_0DTE;
    if(dte===1) return P.FLOW_W_1DTE;
    if(dte===2) return P.FLOW_W_2DTE;
    if(dte===3) return P.FLOW_W_3DTE;
    return P.FLOW_W_7DTE;
  };
  let wCallPrem=0,wPutPrem=0;
  for(const f of positional){
    const w=exW(f.daysToExp)*recencyWeight(f);  // combine expiry weight Ã— recency weight
    if(f.type==='CALL') wCallPrem+=f.premium*w;
    else wPutPrem+=f.premium*w;
  }
  const wTotal=wCallPrem+wPutPrem||1;
  const wRatio=wCallPrem/wTotal;
  const isBullPos=wRatio>=P.FLOW_MOM_THRESH;
  const isBearPos=wRatio<=(1-P.FLOW_MOM_THRESH);

  // â”€â”€ LAYER 2: SAME-DAY ACCELERATION
  // Compare first-half vs second-half weighted ratio for today only.
  // If ratio getting MORE extreme â†’ flow is accelerating â†’ boost
  // If ratio fading back toward 50% â†’ flow decelerating â†’ reduce
  const todayAll=fl.filter(f=>f.daysToExp!==null&&f.daysToExp<=7&&f.premium>=P.FLOW_SWEEP_MIN&&now-f.ts<24*60*60*1000);
  const todayH1=todayAll.filter(f=>f.ts<sessionMidMs);
  const todayH2=todayAll.filter(f=>f.ts>=sessionMidMs);
  let accelDir=null,accelStr='';
  if(todayH1.length>=2&&todayH2.length>=2){
    const r=(arr)=>{const c=arr.filter(f=>f.type==='CALL').reduce((a,f)=>a+f.premium*exW(f.daysToExp),0);const p=arr.filter(f=>f.type==='PUT').reduce((a,f)=>a+f.premium*exW(f.daysToExp),0);return c/(c+p||1);};
    const ratio1=r(todayH1), ratio2=r(todayH2);
    const delta=ratio2-ratio1; // positive = more calls in second half
    if(Math.abs(delta)>0.08){
      accelDir=delta>0?'CALL':'PUT';
      const pct=Math.round(Math.abs(delta)*100);
      accelStr=delta>0?`Call flow accelerating +${pct}% into second half`:`Put flow accelerating +${pct}% into second half`;
    } else if(Math.abs(delta)>0.03){
      accelStr=`Flow stable (${ratio2>0.5?'call':'put'} bias holding)`;
    } else {
      accelStr='Flow mixed â€” no clear intraday acceleration';
    }
  }

  // â”€â”€ LAYER 3: LIVE SWEEPS (30m)
  const sweepCutoff=now-30*60*1000;
  const recentSweeps=fl.filter(f=>f.ts>=sweepCutoff&&f.sweep&&f.premium>=P.FLOW_SWEEP_MIN);
  const callSweeps=recentSweeps.filter(f=>f.type==='CALL').length;
  const putSweeps=recentSweeps.filter(f=>f.type==='PUT').length;
  const sweepDir=callSweeps>putSweeps?'CALL':putSweeps>callSweeps?'PUT':null;
  const sweepAligned=sweepDir&&((isBullPos&&sweepDir==='CALL')||(isBearPos&&sweepDir==='PUT'));

  // â”€â”€ LAYER 4: STRIKE MAGNET (15m, â‰¤3 DTE)
  const smCutoff=now-P.FLOW_SM_MINS*60*1000;
  const smBand=price*0.03;
  const smPrints=fl.filter(f=>f.ts>=smCutoff&&f.premium>=P.FLOW_SWEEP_MIN&&f.strike&&Math.abs(f.strike-price)<=smBand&&f.daysToExp!==null&&f.daysToExp<=3);
  const sc={};
  for(const f of smPrints){
    if(!sc[f.strike])sc[f.strike]={c:0,p:0,tot:0,prem:0};
    sc[f.strike][f.type==='CALL'?'c':'p']++;
    sc[f.strike].tot++;sc[f.strike].prem+=f.premium;
  }
  const dominated=Object.entries(sc).find(([,d])=>d.tot>=P.FLOW_SM_MIN_PRINTS&&(d.c===0||d.p===0));

  // â”€â”€ SCORE
  let score=0,dir=null;
  const items=[];

  // Foundation: positional bias
  if(isBullPos){
    score+=30; dir='CALL';
    const todayCallPct=Math.round(wRatio*100);
    items.push(`${todayCallPct}% weighted call flow (${positional.length} prints â‰¤7 DTE, recency-adjusted)`);
    const urgentCalls=positional.filter(f=>f.daysToExp<=1&&f.type==='CALL');
    if(urgentCalls.length) items.push(`${urgentCalls.length} call prints expiring today/tomorrow â€” high urgency`);
  } else if(isBearPos){
    score+=30; dir='PUT';
    const todayPutPct=Math.round((1-wRatio)*100);
    items.push(`${todayPutPct}% weighted put flow (${positional.length} prints â‰¤7 DTE, recency-adjusted)`);
    const urgentPuts=positional.filter(f=>f.daysToExp<=1&&f.type==='PUT');
    if(urgentPuts.length) items.push(`${urgentPuts.length} put prints expiring today/tomorrow â€” high urgency`);
  } else {
    items.push(`Mixed: ${Math.round(wRatio*100)}% calls / ${Math.round((1-wRatio)*100)}% puts (recency-weighted)`);
  }

  // Acceleration layer
  if(accelDir&&accelDir===dir){
    score+=20; items.push(`âœ“ ${accelStr}`);
  } else if(accelDir&&accelDir!==dir&&dir){
    score-=10; items.push(`âš  ${accelStr} â€” contra positional`);
  } else if(accelStr){
    items.push(accelStr);
  }

  // Live sweeps
  if(sweepAligned){
    score+=20;
    items.push(`${dir==='CALL'?callSweeps:putSweeps} ${dir==='CALL'?'call':'put'} sweeps (30m) confirm direction`);
  } else if(sweepDir&&!sweepAligned){
    score-=10;
    items.push(`âš  ${sweepDir} sweeps contradict positional â€” mixed intent`);
  } else {
    items.push('No recent sweeps â€” positional read only');
  }

  // Strike magnet
  if(dominated){
    const[s,dm]=dominated;
    const md=dm.c>0?'CALL':'PUT';
    if(!dir||dir===md){
      score+=15; dir=md;
      items.push(`Strike magnet $${s} â€” ${dm.tot} prints $${(dm.prem/1e6).toFixed(1)}M â‰¤3DTE`);
    }
  }

  // Urgent premium (money expiring soon = must-resolve pressure)
  const urgentPrem=positional.filter(f=>f.daysToExp<=2).reduce((a,f)=>a+f.premium,0)/1e6;
  if(urgentPrem>3){score+=10;items.push(`$${urgentPrem.toFixed(1)}M expiring â‰¤2 days`);}
  else if(urgentPrem>1){score+=5;items.push(`$${urgentPrem.toFixed(1)}M expiring â‰¤2 days`);}

  score=Math.min(score,100);
  const active=score>=50&&dir!==null&&(isBullPos||isBearPos);
  const entry=price;
  const dex=computeDEX(fl);
  return{active,direction:dir,score,
    detail:items[0]||'Flow building',subItems:items,
    entry,target:dir==='CALL'?entry+P.FLOW_TGT:entry-P.FLOW_TGT,
    stop:dir==='CALL'?entry-P.FLOW_STOP:entry+P.FLOW_STOP,
    ratio:wRatio,callPrem:wCallPrem,putPrem:wPutPrem,
    positionalCount:positional.length,accelDir,dex};
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  DAY-TYPE CLASSIFIER
//  Runs from 10am onward once â‰¥14 5m candles available.
//  Output: { type:'TRENDING'|'MIXED'|'RANGE', score:0-100, evidence:[] }
//
//  Evidence sources (each contributes to a 0-100 trend score):
//   +VWAP slope â€” consistently rising/falling over last 60 min
//   +Hourly displacement â€” each new hour making net progress vs prior
//   +Level rejection pattern â€” clears count as trend, rejections as range
//   âˆ’Grab events count double (grabs = range boundary behaviour)
//   âˆ’ATR utilisation â€” >75% of ATR used non-directionally by noon
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
let dayClassCache={type:'MIXED',score:50,evidence:[],lastCandle:0};

function classifyDayType(c5){
  const et=new Date(new Date().toLocaleString('en-US',{timeZone:'America/New_York'}));
  const etMins=et.getHours()*60+et.getMinutes();

  // Not enough data yet â€” stay neutral
  if(c5.length<P.DAY_MIN_CANDLES||etMins<P.VEL_AM_START)
    return{type:'MIXED',score:50,evidence:['Insufficient data â€” classification begins at 10am']};

  // Cache: only recompute when new candle arrives
  if(dayClassCache.lastCandle===c5.at(-1).t) return dayClassCache;

  let trendPts=0, rangePts=0;
  const evidence=[];

  // â”€â”€ 1. VWAP SLOPE â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  const vw=vwap(c5);
  const slopeWindow=Math.min(P.DAY_VWAP_SLOPE_CANDLES,vw.length-1);
  const vwOld=vw.at(-slopeWindow-1).v, vwNew=vw.at(-1).v;
  const vwSlope=vwNew-vwOld;
  const risingVWAP=vwSlope>0.30;
  const fallingVWAP=vwSlope<-0.30;
  const flatVWAP=Math.abs(vwSlope)<0.10;
  if(risingVWAP||fallingVWAP){
    trendPts+=25;
    evidence.push(`VWAP trending ${risingVWAP?'up':'down'} $${Math.abs(vwSlope).toFixed(2)} over 60m`);
  } else if(flatVWAP){
    rangePts+=20;
    evidence.push(`VWAP flat ($${Math.abs(vwSlope).toFixed(2)}) â€” sideways character`);
  } else {
    evidence.push(`VWAP mild slope $${vwSlope.toFixed(2)}`);
  }

  // â”€â”€ 2. HOURLY DISPLACEMENT â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // Compare the open of the 2nd-to-last complete hour vs the close of the last complete hour.
  // Net displacement in consistent direction = trending evidence.
  const sessionCandles=c5.filter(cn=>{
    const d=new Date(cn.t);
    const m=d.getHours()*60+d.getMinutes();
    return m>=570&&m<960; // 9:30amâ€“4pm
  });
  if(sessionCandles.length>=12){
    const firstSixteen=sessionCandles.slice(0,12);
    const lastTwelve=sessionCandles.slice(-12);
    const earlyMid=(Math.max(...firstSixteen.map(c=>c.h))+Math.min(...firstSixteen.map(c=>c.l)))/2;
    const lateMid=(Math.max(...lastTwelve.map(c=>c.h))+Math.min(...lastTwelve.map(c=>c.l)))/2;
    const disp=lateMid-earlyMid;
    // Check if the ranges overlap heavily (range) vs displaced (trend)
    const earlyHigh=Math.max(...firstSixteen.map(c=>c.h));
    const earlyLow=Math.min(...firstSixteen.map(c=>c.l));
    const lateHigh=Math.max(...lastTwelve.map(c=>c.h));
    const lateLow=Math.min(...lastTwelve.map(c=>c.l));
    const overlap=Math.max(0,Math.min(earlyHigh,lateHigh)-Math.max(earlyLow,lateLow));
    const earlyRange=earlyHigh-earlyLow||0.01;
    const overlapPct=overlap/earlyRange;
    if(overlapPct>0.85){
      rangePts+=20;
      evidence.push(`High range overlap ${Math.round(overlapPct*100)}% â€” price revisiting same area`);
    } else if(overlapPct<0.40&&Math.abs(disp)>0.80){
      trendPts+=20;
      evidence.push(`Net displacement $${disp.toFixed(2)} â€” directional expansion`);
    } else {
      evidence.push(`Mixed displacement $${disp.toFixed(2)}`);
    }
  }

  // â”€â”€ 3. LEVEL REJECTION PATTERN from session state â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  const state=gexLevelState;
  const clearedCount=state.clearedMajors.length+state.clearedModerates.length;
  const grabCount=state.clearedMajors.filter(m=>m.grabSuspected).length+
                  state.clearedModerates.filter(m=>m.grabSuspected).length;
  const rejCount=state.supportAnchors.filter(s=>s.rejectionCount&&s.rejectionCount>=2).length;
  if(clearedCount>0&&grabCount===0){
    trendPts+=Math.min(15,clearedCount*8);
    evidence.push(`${clearedCount} clean level clear${clearedCount>1?'s':''} â€” trend day evidence`);
  }
  if(grabCount>0){
    rangePts+=Math.min(20,grabCount*10);
    evidence.push(`${grabCount} grab event${grabCount>1?'s':''} â€” range boundary behaviour`);
  }
  if(rejCount>0){
    rangePts+=Math.min(15,rejCount*8);
    evidence.push(`${rejCount} level${rejCount>1?'s':''} tested 2+ times â€” range resistance`);
  }

  // â”€â”€ 4. ATR UTILISATION (pre-noon check) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  if(etMins<13*60){ // before 1pm
    const todayCandles=sessionCandles;
    if(todayCandles.length>=4){
      const sessionHigh=Math.max(...todayCandles.map(c=>c.h));
      const sessionLow=Math.min(...todayCandles.map(c=>c.l));
      const sessionRange=sessionHigh-sessionLow;
      // Typical SPY ATR proxy: last 5 days' ranges
      const atrProxy=c5.length>78?
        c5.slice(-78,-78+13).reduce((acc,c)=>acc+c.h-c.l,0)/13:sessionRange;
      const atrUsed=sessionRange/Math.max(atrProxy,0.50);
      if(atrUsed>P.DAY_ATR_RANGE_THRESH&&Math.abs(c5.at(-1).c-c5[0].c)<sessionRange*0.35){
        // Large range used but net movement small = choppy
        rangePts+=15;
        evidence.push(`ATR ${Math.round(atrUsed*100)}% used, net move small â€” chop signature`);
      }
    }
  }

  // â”€â”€ FINAL SCORE â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  const total=trendPts+rangePts||1;
  const trendScore=Math.round(trendPts/(trendPts+rangePts)*100);
  const type=trendScore>=P.DAY_TREND_THRESH?'TRENDING':
             trendScore<=P.DAY_RANGE_THRESH?'RANGE':'MIXED';
  dayClassCache={type,score:trendScore,evidence,lastCandle:c5.at(-1).t};
  return dayClassCache;
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  VELOCITY SCORER
//  Answers: "does this moment have kinetic energy to complete a
//  $2-3 move in <15 minutes?"
//
//  Components:
//   Candle momentum: last 2 candles both closing in signal dir,
//                    expanding bodies = +15, mixed = -10
//   Volume fuel:     current candle â‰¥1.5Ã— session avg = +10,
//                    below avg = -5
//   Time window:     10â€“11am = +10 (best), 2â€“2:45pm = +5
//
//  Returns: { score, detail, items, timeWindow }
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  V3.0 SIGNAL ENGINE
//  Three signals: GEX FIELD Â· TREND Â· CONVICTION
//  APEX: 2-of-3 required, third must be NEUTRAL (not opposing)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// â”€â”€ SIGNAL 1: GEX FIELD
// Scores 0-100. Direction = which way dealer mechanics pull price.
// Incorporates: flip position, wall distance, DEX, wall velocity,
// dark pool support, GEX gamma regime.
function scoreGEXField(gx, fl){
  // If flow GEX hasn't computed valid levels yet, fall back to raw flow premium direction
  // rather than blocking entirely â€” GEX levels are estimated, scored lower
  if(!gexDataValid){
    if(!fl.length||uwFlow.length<3){
      return{active:false,direction:null,score:0,
        detail:`GEX pending â€” waiting for Tradier chain fetch (${K.trad?'key loaded':'no key'})`,
        subItems:['Chain GEX loads on connect â€” fetches every 5 min'],
        posGEX:false,distToFlip:0,distToCW:0,distToPW:0,
        vel:{callV:0,putV:0},dex:{strong:false,direction:null,detail:'no data'}};
    }
    // Have some flow context but chain not yet loaded â€” use raw flow as low-confidence fallback
    const cp=uwFlow.filter(f=>f.type==='CALL').reduce((a,f)=>a+f.premium,0);
    const pp=uwFlow.filter(f=>f.type==='PUT').reduce((a,f)=>a+f.premium,0);
    const total=cp+pp||1;
    const ratio=cp/total;
    const dir=ratio>=0.65?'CALL':ratio<=0.35?'PUT':null;
    const score=dir?Math.round(30+Math.abs(ratio-0.5)*40):0;
    return{active:dir!==null&&score>=35,direction:dir,score,
      detail:`GEX levels building Â· raw flow ${Math.round(ratio*100)}% calls (${uwFlow.length} prints) Â· levels pending`,
      subItems:['Using raw flow direction â€” GEX wall levels not yet computed'],
      posGEX:price>P.GEX_FLIP,distToFlip:Math.abs(price-P.GEX_FLIP),
      distToCW:Math.abs(price-P.GEX_CWALL),distToPW:Math.abs(price-P.GEX_PWALL),
      vel:{callV:0,putV:0},dex:{strong:false,direction:null,detail:'no data'}};
  }
  const distToFlip=Math.abs(price-P.GEX_FLIP);
  const distToCW=Math.abs(price-P.GEX_CWALL);
  const distToPW=Math.abs(price-P.GEX_PWALL);
  const posGEX=price>P.GEX_FLIP;
  // Wall velocity â€” use new shift velocity
  const vel=gexShiftVelocity();
  const dex=computeDEX(fl);

  // Which wall is price closer to and heading toward?
  const nearCW=distToCW<distToPW;
  const nearPW=distToPW<distToCW;
  const magnetDir=nearCW?'CALL':'PUT';

  let score=0, items=[], dir=null;

  // GEX regime: above flip = positive gamma = mean-reverting dealers
  // Below flip = negative gamma = trending, dealers amplify moves
  if(posGEX){
    if(nearCW&&distToCW<3.0){
      score+=55; dir='PUT';
      items.push(`Approaching call wall $${P.GEX_CWALL} (+$${distToCW.toFixed(2)}) â€” dealer resistance`);
    } else if(nearPW&&distToPW<3.0){
      score+=60; dir='CALL';
      items.push(`Near put wall support $${P.GEX_PWALL} (-$${distToPW.toFixed(2)}) â€” dealer buying`);
    } else {
      score+=40; dir=magnetDir;
      items.push(`Positive GEX Â· floating between walls Â· magnet: ${magnetDir==='CALL'?'call wall $'+P.GEX_CWALL:'put wall $'+P.GEX_PWALL}`);
    }
  } else {
    if(distToFlip<1.5){
      score+=65; dir=null;
      items.push(`Testing gamma flip $${P.GEX_FLIP} â€” break UP bullish, rejection bearish`);
    } else if(price<P.GEX_FLIP){
      score+=70; dir='PUT';
      items.push(`Below gamma flip $${P.GEX_FLIP} â€” negative GEX, put wall $${P.GEX_PWALL} magnet`);
    }
  }

  // â”€â”€ GEX Shift Velocity â€” flip migrating toward price = setup forming early
  if(vel.meaningful){
    const flipMovingTowardPrice=(vel.flipV>0&&price>P.GEX_FLIP)||(vel.flipV<0&&price<P.GEX_FLIP);
    const flipMovingAwayFromPrice=(vel.flipV>0&&price<P.GEX_FLIP)||(vel.flipV<0&&price>P.GEX_FLIP);
    const flipStr=`flip ${vel.flipV>0?'â†‘':'â†“'}$${Math.abs(vel.flipV).toFixed(1)} in ${vel.minutes}m`;
    if(flipMovingTowardPrice){
      score+=12;
      items.push(`âš¡ Structural shift â€” ${flipStr} migrating toward price â€” setup forming`);
    } else if(flipMovingAwayFromPrice){
      score-=8;
      items.push(`â†˜ ${flipStr} migrating away â€” structure dissipating`);
    }
    // Wall compression: wall moving toward price tightens the squeeze
    if(dir==='PUT'&&vel.cwallV<-0.5){score+=8;items.push(`Call wall compressing $${vel.cwallV.toFixed(1)} â€” resistance tightening`);}
    if(dir==='CALL'&&vel.pwallV>0.5){score+=8;items.push(`Put wall rising $${vel.pwallV.toFixed(1)} â€” support strengthening`);}
  }

  // DEX confirmation
  if(dex.strong&&dex.direction===dir){score+=12;items.push(`DEX confirms ${dir} â€” dealers positioned ${dex.detail}`);}
  else if(dex.strong&&dex.direction&&dex.direction!==dir){score-=10;items.push(`âš  DEX disagrees â€” ${dex.detail}`);}

  // Flip cross bonus â€” price just crossed flip level
  const recentFlip=gexFlipEvents.length&&Date.now()-gexFlipEvents.at(-1).ts<8*60*1000;
  if(recentFlip){
    const flip=gexFlipEvents.at(-1);
    const flipDir=flip.toPos?'CALL':'PUT';
    if(flipDir===dir){score+=15;items.push(`Recent gamma flip ${flip.toPos?'bullish':'bearish'} â€” regime change 8m ago`);}
  }

  score=Math.max(0,Math.min(100,score));
  const active=score>=45&&dir!==null;
  return{active,direction:dir,score,
    detail:items[0]||`GEX ${posGEX?'positive':'negative'} Â· flip $${P.GEX_FLIP} Â· cwall $${P.GEX_CWALL} Â· pwall $${P.GEX_PWALL}`,
    subItems:items,posGEX,distToFlip,distToCW,distToPW,vel,dex};
}

// â”€â”€ SIGNAL 3: CONVICTION â€” Institutional flow positioning
// Scores 0-100 based on weighted UW flow direction only.
// Delta is computed and attached for entry/exit timing awareness
// but does NOT influence score or active status for APEX gating.
// Logic: 2-3 hour weighted flow tells us where institutions are positioned.
// Delta tells us what's happening right now â€” useful at entry, not for structure.
function scoreConviction(fl){
  const nil={active:false,direction:null,score:0,detail:'No flow data',
    flowRatio:0.5,flowDir:null,deltaDir:null,deltaDetail:'no data'};
  if(!fl.length) return nil;

  // Weighted flow â€” recency Ã— DTE weights over 2-3 hour window
  const now=Date.now();
  const wt=(f)=>{
    const ageMins=(now-f.ts)/(60*1000);
    const ageW=ageMins<60?P.FLOW_DECAY_TODAY_H1:ageMins<120?P.FLOW_DECAY_TODAY_H2:P.FLOW_DECAY_YESTERDAY;
    const dteW=f.daysToExp===0?P.FLOW_W_0DTE:f.daysToExp===1?P.FLOW_W_1DTE:
               f.daysToExp===2?P.FLOW_W_2DTE:f.daysToExp<=3?P.FLOW_W_3DTE:P.FLOW_W_7DTE;
    return f.premium*dteW*ageW/10000;
  };
  let wCall=0,wPut=0;
  for(const f of fl){ const w=wt(f); if(f.type==='CALL') wCall+=w; else wPut+=w; }
  const total=wCall+wPut||1;
  const ratio=wCall/total;
  const flowDir=ratio>=P.FLOW_MOM_THRESH?'CALL':ratio<=(1-P.FLOW_MOM_THRESH)?'PUT':null;

  // Score purely from flow â€” no delta influence
  let score=0, dir=flowDir, detail='';
  if(flowDir){
    // Scale: at threshold (e.g. 65%) = 45, at 80% = 75, at 90%+ = 95
    const conviction=Math.abs(ratio-0.5); // 0 = neutral, 0.5 = maximum
    score=Math.round(45+Math.min(50,conviction*120));
    detail=`Flow ${Math.round(ratio*100)}% ${dir} Â· ${wCall+wPut>0?'weighted institutional positioning':'building'}`;
  } else {
    score=Math.round(20+Math.abs(ratio-0.5)*40);
    detail=`Flow neutral ${Math.round(ratio*100)}% call Â· no institutional bias`;
  }

  // Delta â€” computed for display and manual entry timing, NOT used for scoring
  const delta=getDeltaState();
  const deltaDir=delta.active?delta.direction:null;
  const deltaAnnotation=deltaDir
    ? `${deltaDir===dir?'â†‘ delta confirms':'âš  delta disagrees'} â€” ${delta.detail}`
    : `delta ${delta.detail||'building'}`;

  score=Math.max(0,Math.min(100,score));
  const active=score>=45&&flowDir!==null; // active gating on flow only

  return{active,direction:dir,score,
    detail:`${detail} Â· ${deltaAnnotation}`,
    flowRatio:ratio,flowDir,
    deltaDir,deltaDetail:delta.detail,deltaScore:delta.score};
}

// â”€â”€ V3.0 APEX ENGINE
// Requires 2-of-3 signals. Third must be NEUTRAL (not opposing).
// Score = min of the two active signals (honest: only as strong as weakest).
let lastApexFiredAt=0, lastApexKey='';

function scoreSignals(){
  const gx=getGEX(), fl=getFlow();
  const gexField=scoreGEXField(gx,fl);
  const trend=scoreTrend(c5,c15);
  const conviction=scoreConviction(fl);
  // Track gamma flip (function defined in GEX section)
  const nowPosGEX=price>P.GEX_FLIP;
  if(prevPosGEX!==null&&nowPosGEX!==prevPosGEX){
    gexFlipEvents.push({ts:Date.now(),price,toPos:nowPosGEX});
    if(gexFlipEvents.length>10) gexFlipEvents.shift();
  }
  prevPosGEX=nowPosGEX;
  return{gexField,trend,conviction};
}

function isOpposing(sig, dir){
  // A signal is "opposing" if it's active AND pointing the wrong way
  return sig.active && sig.direction && sig.direction!==dir;
}

// â”€â”€ Dark pool context check â€” called at APEX fire moment only
// Returns object describing whether DP structure supports or opposes the trade
// Three outcomes: SUPPORTS, OPPOSES, CONFLUENCE (DP cluster aligns with GEX wall), NEUTRAL
function getDPContext(dir, entryPrice){
  const dp=nearDP(entryPrice);
  if(!dp) return{flag:'NEUTRAL',detail:'No DP cluster within $'+P.DP_PROX+' of entry'};

  const aboveEntry=dp.price>entryPrice;
  const premium=dp.totalPremium>=1e9?`$${(dp.totalPremium/1e9).toFixed(1)}B`:
    `$${(dp.totalPremium/1e6).toFixed(0)}M`;

  // Check GEX wall confluence â€” same level as a call/put wall
  const wallProx=Math.abs(dp.price-P.GEX_CWALL)<1.5||Math.abs(dp.price-P.GEX_PWALL)<1.5;

  // PUT trade: cluster above entry = trapped longs = supports. Cluster below = support floor = opposes.
  // CALL trade: cluster below entry = institutional support = supports. Cluster above = overhead resistance = opposes.
  let flag, detail;
  if(dir==='PUT'){
    if(aboveEntry){
      flag=wallProx?'CONFLUENCE':'SUPPORTS';
      detail=`DP cluster $${dp.price.toFixed(2)} (${premium}) above entry â€” trapped longs${wallProx?' Â· aligns with GEX wall':''}`;
    } else {
      flag='OPPOSES';
      detail=`âš  DP cluster $${dp.price.toFixed(2)} (${premium}) below entry â€” institutional support floor may resist decline`;
    }
  } else {
    if(!aboveEntry){
      flag=wallProx?'CONFLUENCE':'SUPPORTS';
      detail=`DP cluster $${dp.price.toFixed(2)} (${premium}) below entry â€” institutional support${wallProx?' Â· aligns with GEX wall':''}`;
    } else {
      flag='OPPOSES';
      detail=`âš  DP cluster $${dp.price.toFixed(2)} (${premium}) above entry â€” overhead resistance may cap rally`;
    }
  }
  return{flag,detail,dp};
}

function detectApex(sigs){
  if(isBlackout()) return null;
  const {gexField, trend, conviction}=sigs;

  // Cooldown â€” 3 min between fires on same level
  if(Date.now()-lastApexFiredAt < 3*60*1000) return null;

  // Try every direction both signals could agree on
  for(const dir of ['CALL','PUT']){
    const gxMatch=gexField.direction===dir;
    const trMatch=trend.direction===dir;
    const cvMatch=conviction.direction===dir;

    // Count active matches and check no active oppositions
    const matches=[gxMatch&&gexField.active, trMatch&&trend.active, cvMatch&&conviction.active];
    const activeCount=matches.filter(Boolean).length;
    if(activeCount<2) continue;

    // Opposing check: any signal actively pointing wrong way?
    if(isOpposing(gexField, dir)||isOpposing(trend, dir)||isOpposing(conviction, dir)) continue;

    // Score = min of active signal scores (weakest link)
    const activeScores=[];
    if(gxMatch&&gexField.active) activeScores.push(gexField.score);
    if(trMatch&&trend.active) activeScores.push(trend.score);
    if(cvMatch&&conviction.active) activeScores.push(conviction.score);
    const apexScore=Math.min(...activeScores);

    // Minimum threshold: weakest active signal must be â‰¥45
    if(apexScore<45) continue;

    const now=new Date();
    const key=`${dir}-${Math.round(price/2)*2}`;
    if(key===lastApexKey&&Date.now()-lastApexFiredAt<10*60*1000) continue;

    const target=dir==='CALL'?price+P.APEX_TGT_MOVE:price-P.APEX_TGT_MOVE;
    const stop  =dir==='CALL'?price-P.APEX_STOP_BUF:price+P.APEX_STOP_BUF;
    const activeSigNames=[
      gxMatch&&gexField.active?'GEX':'',
      trMatch&&trend.active?`Trend(${trend.regime})` :'',
      cvMatch&&conviction.active?'Conviction':''
    ].filter(Boolean).join('+');

    lastApexFiredAt=Date.now();
    lastApexKey=key;

    const dpContext=getDPContext(dir,price);

    return{id:Date.now(),type:dir,price,target,stop,
      conf:apexScore,score:apexScore,
      time:now.toLocaleTimeString('en-US',{hour:'2-digit',minute:'2-digit'}),
      detail:`${activeSigNames} aligned Â· ${apexScore} score`,
      gexScore:gexField.score,trendScore:trend.score,cvScore:conviction.score,
      trendRegime:trend.regime,
      dpContext,
      state:'ACTIVE',firedAt:Date.now(),firedPrice:price,
      currentComp:apexScore,thresh:45};
  }
  return null;
}

function isBlackout(){
  const et=new Date(new Date().toLocaleString('en-US',{timeZone:'America/New_York'}));
  const m=et.getHours()*60+et.getMinutes();
  return (m>=P.APEX_BO_AM_START&&m<P.APEX_BO_AM_END)||(m>=P.APEX_BO_PM_START&&m<P.APEX_BO_PM_END);
}
function blackoutLabel(){
  const et=new Date(new Date().toLocaleString('en-US',{timeZone:'America/New_York'}));
  const m=et.getHours()*60+et.getMinutes();
  if(m>=P.APEX_BO_AM_START&&m<P.APEX_BO_AM_END) return'BUILDING (pre-10am)';
  if(m>=P.APEX_BO_PM_START&&m<P.APEX_BO_PM_END) return'CLOSED (post-3:30pm)';
  return null;
}

// â”€â”€ APEX LIFECYCLE (updated each scan while apexFired exists)
function updateApexLifecycle(sigs){
  if(!apexFired) return;
  const sig=apexFired;
  const now=Date.now();
  const APEX_EXPIRY_MS=45*60*1000;
  const ageMs=now-sig.firedAt;

  // Auto-clear resolved signals after 30s display
  if((sig.state==='TARGET'||sig.state==='STOP')&&sig.resolvedAt&&now-sig.resolvedAt>30000){
    logApexOutcome(sig); apexFired=null; return;
  }
  if(sig.state==='EXPIRED'){logApexOutcome(sig); apexFired=null; return;}

  // Price checks
  if(sig.type==='CALL'){
    if(price>=sig.target){sig.state='TARGET';sig.resolvedAt=now;return;}
    if(price<=sig.stop)  {sig.state='STOP';  sig.resolvedAt=now;return;}
  } else {
    if(price<=sig.target){sig.state='TARGET';sig.resolvedAt=now;return;}
    if(price>=sig.stop)  {sig.state='STOP';  sig.resolvedAt=now;return;}
  }
  if(ageMs>APEX_EXPIRY_MS){sig.state='EXPIRED';sig.resolvedAt=now;return;}

  // Recompute score with live signals
  const {gexField,trend,conviction}=sigs;
  const dir=sig.type;
  const activeScores=[];
  if(gexField.direction===dir&&gexField.active) activeScores.push(gexField.score);
  if(trend.direction===dir&&trend.active) activeScores.push(trend.score);
  if(conviction.direction===dir&&conviction.active) activeScores.push(conviction.score);
  const currentComp=activeScores.length>=2?Math.min(...activeScores):activeScores[0]||0;
  sig.currentComp=currentComp;

  if(currentComp<45||activeScores.length<1){
    sig.state='DEGRADING';
    sig.degradeDetail=`Score now ${currentComp} Â· signals aligned: ${activeScores.length}/3`;
  } else {
    sig.state='ACTIVE';
    sig.degradeDetail=null;
  }
}

function logApexOutcome(sig){
  try{
    const log=JSON.parse(localStorage.getItem('apex_log')||'[]');
    log.push({id:sig.id,type:sig.type,state:sig.state,
      firedAt:new Date(sig.firedAt).toLocaleTimeString('en-US',{hour:'2-digit',minute:'2-digit'}),
      resolvedAt:sig.resolvedAt?new Date(sig.resolvedAt).toLocaleTimeString('en-US',{hour:'2-digit',minute:'2-digit'}):'â€”',
      entry:sig.price,target:sig.target,stop:sig.stop,conf:sig.conf});
    localStorage.setItem('apex_log',JSON.stringify(log.slice(-50)));
  }catch(e){}
}


// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  API INTEGRATIONS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// â”€â”€ POLYGON WEBSOCKET DELTA STREAM
let polyWS=null;

async function initTradierStream(){
  if(!K.poly) return;
  connectDeltaStream();
}

function connectDeltaStream(){
  if(polyWS){try{polyWS.close();}catch(e){} polyWS=null;}
  try{
    polyWS=new WebSocket('wss://socket.polygon.io/stocks');
    polyWS.onopen=()=>{ polyWS.send(JSON.stringify({action:'auth',params:K.poly})); };
    polyWS.onmessage=(e)=>{
      try{
        const msgs=JSON.parse(e.data);
        for(const msg of msgs){
          if(msg.ev==='status'&&msg.status==='auth_success'){
            polyWS.send(JSON.stringify({action:'subscribe',params:'T.SPY'}));
            CON.stream=true; deltaConnectAttempts=0;
          } else if(msg.ev==='status'&&msg.status==='auth_failed'){
            CON.stream=false; polyWS.close();
          } else if(msg.ev==='T'&&msg.sym==='SPY'){
            processDeltaTick(+msg.p, +msg.s||100);
          }
        }
      }catch(err){}
    };
    polyWS.onerror=()=>{ CON.stream=false; };
    polyWS.onclose=()=>{
      CON.stream=false; deltaConnectAttempts++;
      if(deltaConnectAttempts<5)
        setTimeout(()=>connectDeltaStream(), Math.min(5000*Math.pow(2,deltaConnectAttempts-1),60000));
    };
  }catch(e){ CON.stream=false; }
}

function processDeltaTick(tickPrice, tickSize){
  const ts=Date.now();

  // â”€â”€ Real-time price update â€” every trade tick, immediate
  // Sanity check: ignore ticks >$5 from current price (bad data / pre-market noise)
  if(tickPrice>0 && Math.abs(tickPrice-price)<5){
    price=tickPrice;
    updateHeader();          // header price only â€” zero lag
    updateDPClearTracker();  // live distance to opposing DP level on APEX card
  }

  // Delta direction tracking (unchanged)
  let dir=0;
  if(deltaLastPrice>0){
    if(tickPrice>deltaLastPrice) dir=1;
    else if(tickPrice<deltaLastPrice) dir=-1;
    else dir=deltaTicks.length?deltaTicks.at(-1).dir:0;
  }
  deltaLastPrice=tickPrice;
  if(dir===0) return;
  deltaRunning+=dir;
  deltaTicks.push({price:tickPrice,dir,ts,size:tickSize});
  if(deltaTicks.length>P.DELTA_TICK_WINDOW) deltaTicks.shift();
  detectDeltaSurge();
}

// â”€â”€ DP clear tracker â€” called on every WebSocket tick
// Updates the distance display in the APEX card without rebuilding anything
function updateDPClearTracker(){
  const el=document.getElementById('dp-clear-distance');
  if(!el||!apexFired||!apexFired.dpContext||apexFired.dpContext.flag!=='OPPOSES') return;
  const dp=apexFired.dpContext.dp;
  if(!dp) return;
  // PUT trade: need price to drop below cluster. CALL trade: need price to break above.
  const cleared=apexFired.type==='PUT'?price<dp.price:price>dp.price;
  const dist=Math.abs(price-dp.price);
  if(cleared){
    el.textContent=`âœ“ CLEARED â€” price through $${dp.price.toFixed(2)}`;
    el.style.color='#10b981';
    el.style.fontWeight='700';
  } else {
    const arrow=apexFired.type==='PUT'?'â†“':'â†‘';
    el.textContent=`$${dist.toFixed(2)} to clear $${dp.price.toFixed(2)} ${arrow} â€” wait for break`;
    el.style.color='#ef4444';
    el.style.fontWeight='400';
  }
}

function detectDeltaSurge(){
  if(deltaTicks.length<P.DELTA_SURGE_MIN_TICKS) return;
  const win=deltaTicks.slice(-P.DELTA_SURGE_MIN_TICKS);
  const ups=win.filter(t=>t.dir>0).length;
  const dns=win.filter(t=>t.dir<0).length;
  const total=ups+dns||1;
  const upR=ups/total, dnR=dns/total;
  if(upR>=P.DELTA_SURGE_THRESH)
    deltaInflection={dir:'CALL',strength:upR,ts:Date.now(),detail:`${Math.round(upR*100)}% buying ticks â€” aggressive demand`};
  else if(dnR>=P.DELTA_SURGE_THRESH)
    deltaInflection={dir:'PUT',strength:dnR,ts:Date.now(),detail:`${Math.round(dnR*100)}% selling ticks â€” aggressive supply`};
  else if(deltaInflection&&Date.now()-deltaInflection.ts>2*60*1000)
    deltaInflection=null;
}

function getDeltaState(){
  if(!CON.stream||deltaTicks.length<10)
    return{active:false,direction:null,strength:0,score:0,
      detail:CON.stream?'Building tick data...':'Polygon WebSocket â€” connecting',
      running:0,tickCount:deltaTicks.length};
  const win=deltaTicks.slice(-P.DELTA_SURGE_MIN_TICKS);
  const ups=win.filter(t=>t.dir>0).length;
  const dns=win.filter(t=>t.dir<0).length;
  const total=ups+dns||1;
  const upRatio=ups/total;
  const surge=deltaInflection&&Date.now()-deltaInflection.ts<2*60*1000;
  const dir=surge?deltaInflection.dir:upRatio>0.55?'CALL':upRatio<0.45?'PUT':null;
  const strength=surge?deltaInflection.strength:Math.max(upRatio,1-upRatio);
  const score=surge?Math.round(strength*P.DELTA_SURGE_MAX):
    dir?Math.round((strength-0.5)*2*P.DELTA_SURGE_MAX*0.5):0;
  return{active:!!dir&&score>=8,direction:dir,strength,score:Math.max(0,score),
    detail:surge?deltaInflection.detail:`${Math.round(upRatio*100)}% buying / ${Math.round((1-upRatio)*100)}% selling Â· ${deltaTicks.length} ticks`,
    running:deltaRunning,tickCount:deltaTicks.length,surge};
}

// POLYGON
function tradingDate(){const n=new Date(),d=n.getDay(),dt=new Date(n);dt.setDate(dt.getDate()-(d===6?1:d===0?2:0));return dt.toISOString().split('T')[0];}
function isMarket(){const et=new Date(new Date().toLocaleString('en-US',{timeZone:'America/New_York'})),d=et.getDay(),m=et.getHours()*60+et.getMinutes();return d>=1&&d<=5&&m>=570&&m<960;}
async function polyGet(path){const r=await fetch(`https://api.polygon.io${path}${path.includes('?')?'&':'?'}apiKey=${K.poly}`);const d=await r.json();if(d.status==='ERROR'||d.status==='FORBIDDEN')throw new Error(d.error||'Polygon error');return d;}
// â”€â”€ fetchCandles â€” heavy work: 5m + paginated 15m bars
// Runs every 60s. EMAs don't need faster updates than this.
async function fetchCandles(){
  const td=tradingDate();
  async function fetch15mPaginated(){
    const target=600;
    let all=[];
    const ago90=(()=>{const d=new Date(td);d.setDate(d.getDate()-90);return d.toISOString().split('T')[0]})();
    let url=`/v2/aggs/ticker/SPY/range/15/minute/${ago90}/${td}?adjusted=true&sort=asc&limit=50000&apiKey=${K.poly}`;
    let attempts=0;
    while(all.length<target&&attempts<8){
      const r=await fetch(`https://api.polygon.io${url.startsWith('/')?url:'/'+url}`);
      const d2=await r.json();
      if(d2.results?.length) all=[...all,...d2.results];
      if(d2.next_url&&all.length<target){url=d2.next_url.replace('https://api.polygon.io','');attempts++;}
      else break;
    }
    const isRegularSession=(ts)=>{
      const et=new Date(ts).toLocaleString('en-US',{timeZone:'America/New_York',hour:'numeric',minute:'numeric',hour12:false});
      const [h,m]=et.split(':').map(Number);
      return (h*60+m)>=570&&(h*60+m)<960;
    };
    return all.filter(r=>isRegularSession(r.t)).map(r=>({t:r.t,o:r.o,h:r.h,l:r.l,c:r.c,v:r.v}));
  }

  const[r5,raw15]=await Promise.all([
    polyGet(`/v2/aggs/ticker/SPY/range/5/minute/${td}/${td}?adjusted=true&sort=asc&limit=500`),
    fetch15mPaginated(),
  ]);
  if(!r5.results?.length) throw new Error('No 5m data â€” market may be closed');
  c5=r5.results.map(r=>({t:r.t,o:r.o,h:r.h,l:r.l,c:r.c,v:r.v}));

  if(c5.length){
    const lastComplete15t=raw15.length?raw15.at(-1).t:0;
    const inProgress=c5.filter(c=>c.t>lastComplete15t);
    if(inProgress.length){
      c15=[...raw15,{t:inProgress[0].t,o:inProgress[0].o,
        h:Math.max(...inProgress.map(c=>c.h)),l:Math.min(...inProgress.map(c=>c.l)),
        c:inProgress.at(-1).c,v:inProgress.reduce((a,c)=>a+c.v,0),synthetic:true}];
    } else { c15=raw15; }
  } else { c15=raw15; }
}

// â”€â”€ fetchPrice â€” lightweight snapshot: price + chg + VXX only
// Runs every 5s as fallback when WebSocket is not streaming real-time ticks
async function fetchPrice(){
  const[rq,rvx]=await Promise.all([
    polyGet('/v2/snapshot/locale/us/markets/stocks/tickers/SPY'),
    polyGet('/v2/snapshot/locale/us/markets/stocks/tickers/VXX').catch(()=>null),
  ]);
  const sn=rq.ticker;
  // Only update price from REST if WebSocket isn't streaming
  // (WebSocket already updates price on every tick â€” no need to overwrite)
  if(!CON.stream){
    price=sn.day?.c||sn.prevDay?.c||price;
    chg=sn.todaysChange||0;
  } else {
    // Still update chg from snapshot for accuracy
    chg=sn.todaysChange||0;
  }
  meta={open:sn.day?.o||0,high:sn.day?.h||0,low:sn.day?.l||0,vol:sn.day?.v||0};
  if(rvx?.ticker){const vx=rvx.ticker.day?.c||0;const el=document.getElementById('sb-vix');if(el){el.textContent=vx.toFixed(2);el.style.color=vx>25?'#ef4444':vx>18?'#f59e0b':'#10b981';}}
  src='live';
}

// â”€â”€ fetchPolygon â€” kept as single-call compat for connect sequence
// Does price + candles together on first load only
async function fetchPolygon(){
  await Promise.all([fetchPrice(), fetchCandles()]);
}



// UNUSUAL WHALES â€” accumulate flow across refreshes, deduplicated
// flowHistory stores all prints seen this session for 30-day positional scoring
let flowHistory=[];

async function fetchUW(){
  if(!K.uw) return;
  try{
    const res=await fetch('https://api.unusualwhales.com/api/option-trades/flow-alerts?ticker=SPY&limit=500',{headers:{'Authorization':`Bearer ${K.uw}`,'Accept':'application/json'}});
    if(!res.ok) throw new Error(`UW ${res.status}`);
    const d=await res.json(), trades=d.data||d||[];
    const parsed=trades.map(t=>{
      const ot=(t.type||'').toLowerCase();
      const type=(ot==='call')?'CALL':'PUT';
      const exDate=t.expiry?new Date(t.expiry):null;
      const daysToExp=exDate?Math.max(0,Math.round((exDate-new Date())/(1000*60*60*24))):null;
      return{
        id:t.id||`${t.created_at}-${t.strike}-${t.type}`,
        ts:new Date(t.created_at||Date.now()).getTime(),
        time:new Date(t.created_at||Date.now()).toLocaleTimeString('en-US',{hour:'2-digit',minute:'2-digit'}),
        type,strike:+t.strike||0,expiry:t.expiry||'',
        daysToExp,  // null if no expiry, 0 = 0DTE, 1 = 1DTE, etc.
        premium:+t.total_premium||0,size:+t.total_size||+t.volume||0,
        sentiment:type==='CALL'?'bullish':'bearish',
        sweep:!!(t.has_sweep||false),
      };
    }).filter(t=>{
      if(t.premium<P.SWEEP_MIN_PREM) return false;
      if(t.strike&&price>0&&Math.abs(t.strike-price)>price*0.20) return false;
      return true;
    });
    // Deduplicate into history by id â€” keeps growing until page refresh
    const existingIds=new Set(flowHistory.map(f=>f.id));
    const newPrints=parsed.filter(f=>!existingIds.has(f.id));
    flowHistory=[...flowHistory,...newPrints];
    // Trim to last 30 days to prevent unbounded growth
    const cutoff30=Date.now()-30*24*60*60*1000;
    flowHistory=flowHistory.filter(f=>f.ts>=cutoff30);
    // uwFlow = what we show in the flow tab (last 500 by time)
    uwFlow=[...flowHistory].sort((a,b)=>b.ts-a.ts).slice(0,500);
    CON.uw=true;
    setBadge('flow-src',`UW LIVE (${flowHistory.length} prints)`,'#10b98122','#10b981','#10b98144');
    document.getElementById('flow-updated').textContent='Updated '+new Date().toLocaleTimeString();
    renderFlow(); updateDots();
    // GEX runs on its own 5-min Tradier chain timer â€” no call needed here
  }catch(e){console.warn('UW:',e.message);}
}

// Architecture:
//   PRIMARY  = 0DTE prints (explosive gamma â€” today's actual dealer pins)
//   MODIFIER = 1DTE prints (agree/disagree flag, + blended into primary last hour)
//   FALLBACK = 1DTE as primary when 0DTE is thin (<3 qualifying prints)
//
// Last hour (â‰¥3pm ET): 1DTE blends into primary computation because those
// contracts will BE the 0DTE tomorrow and dealers start adjusting hedges.
//
// â”€â”€ Real chain GEX replaces flow-print proxy
// State vars (gexHistory, gexLastRefresh, gexDataValid, gexChainFetching) declared above
let gex1dteAgreement=null;

function etHour(){
  return new Date(new Date().toLocaleString('en-US',{timeZone:'America/New_York'})).getHours();
}
function isLastHour(){
  return etHour()>=P.FLOW_GEX_LAST_HOUR_START;
}

// Core GEX computation from Tradier chain contracts
// Dealer convention: net short options â†’ positive GEX=stabilizing, negative=trending
function computeChainGEX(contracts, spyP){
  if(!contracts||!contracts.length) return null;
  const band=spyP*0.05;
  const relevant=contracts.filter(c=>
    c.strike&&Math.abs(c.strike-spyP)<=band&&
    c.open_interest>0&&c.greeks?.gamma
  );
  if(relevant.length<3) return null;

  const byStrike={};
  for(const c of relevant){
    const dealerSign=c.option_type==='call'?-1:1;
    const gex=dealerSign*c.open_interest*(c.greeks.gamma||0)*100*c.strike;
    if(!byStrike[c.strike]) byStrike[c.strike]={gex:0,callOI:0,putOI:0,callGamma:0,putGamma:0};
    byStrike[c.strike].gex+=gex;
    if(c.option_type==='call'){byStrike[c.strike].callOI+=c.open_interest;byStrike[c.strike].callGamma+=c.greeks.gamma;}
    else{byStrike[c.strike].putOI+=c.open_interest;byStrike[c.strike].putGamma+=c.greeks.gamma;}
  }
  const strikes=Object.keys(byStrike).map(Number).sort((a,b)=>a-b);
  if(strikes.length<3) return null;

  const totalGEX=strikes.reduce((s,k)=>s+byStrike[k].gex,0);

  // Gamma flip: strike where cumulative GEX crosses zero scanning from high to low
  let cum=0,flip=strikes[Math.floor(strikes.length/2)];
  for(let i=strikes.length-1;i>=0;i--){
    const prev=cum; cum+=byStrike[strikes[i]].gex;
    if(prev>0&&cum<=0){flip=strikes[i];break;}
    if(prev<0&&cum>=0){flip=strikes[i+1]||strikes[i];break;}
  }

  // Walls: peak dealer obligation per side (highest |OIÃ—gamma| concentration)
  const cwall=strikes.reduce((best,s)=>
    Math.abs(byStrike[s].callOI*byStrike[s].callGamma)>Math.abs(byStrike[best].callOI*byStrike[best].callGamma)?s:best
  ,strikes[0]);
  const pwall=strikes.reduce((best,s)=>
    Math.abs(byStrike[s].putOI*byStrike[s].putGamma)>Math.abs(byStrike[best].putOI*byStrike[best].putGamma)?s:best
  ,strikes[0]);

  return{flip:Number(flip),cwall:Number(cwall),pwall:Number(pwall),
    totalGEX,byStrike,strikes,contracts:relevant.length};
}

async function fetchTradierExpiry(expiry){
  const r=await fetch(
    `https://api.tradier.com/v1/markets/options/chains?symbol=SPY&expiration=${expiry}&greeks=true`,
    {headers:{'Authorization':`Bearer ${K.trad}`,'Accept':'application/json'}}
  );
  if(!r.ok) throw new Error(`Tradier chain ${r.status}`);
  const d=await r.json();
  return d.options?.option||[];
}

// Main GEX fetch â€” every 5 min via gexIv
async function fetchTradierGEX(){
  if(!K.trad||gexChainFetching) return;
  gexChainFetching=true;
  try{
    const exR=await fetch(
      'https://api.tradier.com/v1/markets/options/expirations?symbol=SPY&includeAllRoots=false',
      {headers:{'Authorization':`Bearer ${K.trad}`,'Accept':'application/json'}}
    );
    if(!exR.ok) throw new Error(`Tradier expirations ${exR.status}`);
    const exD=await exR.json();
    const expiries=exD.expirations?.date||[];
    if(!expiries.length) throw new Error('No expirations returned');

    const today=tradingDate();
    const exp0=expiries.includes(today)?today:expiries[0];
    const exp1=expiries.find(e=>e>exp0)||null;

    const chain0=await fetchTradierExpiry(exp0);
    const chain1=exp1?await fetchTradierExpiry(exp1):[];

    const spyP=price||P.GEX_FLIP;
    let contracts=chain0;
    let source=`0DTE ${exp0}`;

    // Last hour: blend 1DTE at 50% OI weight for forward-looking structure
    if(isLastHour()&&chain1.length){
      const blended=[...chain0];
      for(const c of chain1) blended.push({...c,open_interest:Math.round(c.open_interest*0.5),_blended:true});
      contracts=blended;
      source='0DTE+1DTE blend';
    }

    const result=computeChainGEX(contracts,spyP);
    if(!result) throw new Error('Insufficient chain data (<3 contracts in band)');

    // 1DTE agreement: does next expiry agree on which side of price the flip is?
    let agreement=null;
    if(chain1.length){
      const r1=computeChainGEX(chain1,spyP);
      if(r1) agreement=(result.flip>spyP)===(r1.flip>spyP)?'agree':'disagree';
    }
    gex1dteAgreement=agreement;

    P.GEX_FLIP=result.flip;
    P.GEX_CWALL=result.cwall;
    P.GEX_PWALL=result.pwall;

    gexHistory.push({ts:Date.now(),flip:result.flip,cwall:result.cwall,
      pwall:result.pwall,totalGEX:result.totalGEX,contracts:result.contracts});
    if(gexHistory.length>6) gexHistory.shift();

    gexLastRefresh=new Date();
    gexDataValid=true;

    const res2dist=Math.round((result.cwall-result.flip)*0.4)||3;
    const sup2dist=Math.round((result.flip-result.pwall)*0.4)||3;
    sgGEX={
      flipLevel:result.flip,
      keyLevels:[
        {price:result.cwall,         gex:2.8,  type:'call wall'},
        {price:result.flip+res2dist, gex:1.5,  type:'resistance'},
        {price:spyP,                 gex:0.3,  type:'current'},
        {price:result.flip,          gex:0,    type:'gamma flip'},
        {price:result.flip-sup2dist, gex:-1.3, type:'support'},
        {price:result.pwall,         gex:-2.5, type:'put wall'},
      ],
      source,agreement,totalGEX:result.totalGEX,isLastHour:isLastHour(),
    };
    CON.sg=true;

    // Badge with velocity shift indicator
    const vel=gexShiftVelocity();
    const shiftStr=vel.meaningful?` Â· flip ${vel.flipV>0?'\u2191':'\u2193'}$${Math.abs(vel.flipV).toFixed(1)}/${vel.minutes}m`:'';
    const agrStr=agreement==='agree'?' Â· \u2713':agreement==='disagree'?' Â· \u26a0 disagree':'';
    const badgeCol=agreement==='disagree'?'#f59e0b':'#10b981';
    setBadge('gex-src',`CHAIN GEX \u00b7 ${source}${agrStr}${shiftStr}`,`${badgeCol}22`,badgeCol,`${badgeCol}44`);

    const nextEl=document.getElementById('gex-next');
    if(nextEl) nextEl.textContent=`\u00b7 ${result.contracts} contracts \u00b7 flip $${result.flip} \u00b7 `+
      gexLastRefresh.toLocaleTimeString('en-US',{hour:'2-digit',minute:'2-digit'});

    renderGEX(); updateDots();

  }catch(e){
    gexDataValid=false;
    setBadge('gex-src','GEX: ERROR','#ef444422','#ef4444','#ef444444');
    const nextEl=document.getElementById('gex-next');
    if(nextEl) nextEl.textContent=`\u00b7 ${e.message}`;
  }finally{
    gexChainFetching=false;
  }
}

// Aliases so existing call sites work unchanged
async function fetchUWGex(force=false){ await fetchTradierGEX(); }
const fetchSG=fetchUWGex;


// DARK POOL â€” fetch significant SPY prints, cluster into S/R levels
async function fetchDarkPool(){
  if(!K.uw) return;
  try{
    const res=await fetch(
      'https://api.unusualwhales.com/api/darkpool/SPY?limit=500',
      {headers:{'Authorization':`Bearer ${K.uw}`,'Accept':'application/json'}}
    );
    if(!res.ok) throw new Error(`DP ${res.status}`);
    const json=await res.json();
    const trades=(json.data||json||[]);
    const sig=trades.filter(t=>+(t.premium||0)>=P.DP_MIN_PREMIUM||+(t.size||0)>=50000);
    const clusters=[];
    for(const t of sig){
      const p=+(t.price||0); if(!p) continue;
      const ex=clusters.find(c=>Math.abs(c.price-p)<1.00);
      if(ex){
        ex.totalPremium+=+(t.premium||0);
        ex.totalSize+=+(t.size||0);
        ex.count++;
        ex.price=parseFloat(((ex.price*(ex.count-1)+p)/ex.count).toFixed(2));
      } else {
        clusters.push({price:p,totalPremium:+(t.premium||0),totalSize:+(t.size||0),count:1});
      }
    }
    dpLevels=clusters.sort((a,b)=>b.totalPremium-a.totalPremium).slice(0,8);
    if(dpLevels.length) renderDPLevels();
    console.log(`Dark pool: ${dpLevels.length} significant levels loaded`);
  }catch(e){console.warn('Dark pool:',e.message);}
}
function nearDP(p){return dpLevels.find(d=>Math.abs(d.price-p)<P.DP_PROX)||null;}

function applyManualGEX(){
  const flip=+document.getElementById('gex-flip-in').value||P.GEX_FLIP;
  const cwall=+document.getElementById('gex-cwall-in').value||P.GEX_CWALL;
  const pwall=+document.getElementById('gex-pwall-in').value||P.GEX_PWALL;
  P.GEX_FLIP=flip; P.GEX_CWALL=cwall; P.GEX_PWALL=pwall;
  sgGEX={flipLevel:flip,keyLevels:[
    {price:cwall,gex:2.8,type:'call wall'},{price:flip+4,gex:1.4,type:'resistance'},
    {price:price,gex:0.2,type:'current'},{price:flip,gex:0,type:'gamma flip'},
    {price:flip-4,gex:-1.2,type:'support'},{price:pwall,gex:-2.4,type:'put wall'},
  ]};
  setBadge('gex-src','MANUAL','#f59e0b22','#f59e0b','#f59e0b44');
  renderGEX();
}

// TRADIER â€” real options chain for backtest P&L
async function runTradierGEXTest(){
  const el=document.getElementById('tradier-gex-result');
  el.innerHTML='<span style="color:#f59e0b">Running test...</span>';
  if(!K.trad){el.innerHTML='<span style="color:#ef4444">âœ— No Tradier key loaded â€” connect first</span>';return;}
  try{
    // Get available expiries
    const exRes=await fetch('https://api.tradier.com/v1/markets/options/expirations?symbol=SPY&includeAllRoots=false',
      {headers:{'Authorization':`Bearer ${K.trad}`,'Accept':'application/json'}});
    const exData=await exRes.json();
    const expiries=exData.expirations?.date||[];
    if(!expiries.length){el.innerHTML='<span style="color:#ef4444">âœ— No expirations returned â€” check key permissions</span>';return;}

    // Use today if available, else nearest
    const today=tradingDate();
    const expiry=expiries.includes(today)?today:expiries[0];

    // Fetch chain with greeks=true
    const chainRes=await fetch(
      `https://api.tradier.com/v1/markets/options/chains?symbol=SPY&expiration=${expiry}&greeks=true`,
      {headers:{'Authorization':`Bearer ${K.trad}`,'Accept':'application/json'}});
    const chainData=await chainRes.json();
    const contracts=chainData.options?.option||[];
    if(!contracts.length){el.innerHTML=`<span style="color:#ef4444">âœ— No contracts returned for ${expiry}</span>`;return;}

    // Sample near-the-money
    const atm=contracts.reduce((best,c)=>Math.abs(c.strike-price)<Math.abs(best.strike-price)?c:best,contracts[0]);
    const hasOI=atm.open_interest!==undefined&&atm.open_interest!==null;
    const hasGamma=atm.greeks?.gamma!==undefined&&atm.greeks?.gamma!==null&&atm.greeks?.gamma!==0;
    const withOI=contracts.filter(c=>c.open_interest>0).length;
    const withGamma=contracts.filter(c=>c.greeks?.gamma&&c.greeks.gamma!==0).length;

    // Sample GEX computation on nearest Â±$10 strikes
    const near=contracts
      .filter(c=>Math.abs(c.strike-price)<=10&&c.open_interest>0&&c.greeks?.gamma)
      .sort((a,b)=>a.strike-b.strike);
    const sampleGEX=near.map(c=>{
      const dealerSign=c.option_type==='call'?-1:1;
      const gex=dealerSign*c.open_interest*c.greeks.gamma*100*c.strike;
      return{strike:c.strike,type:c.option_type,oi:c.open_interest,gamma:c.greeks.gamma.toFixed(4),gex:Math.round(gex)};
    });

    const ok=hasOI&&hasGamma;
    const col=ok?'#10b981':'#f59e0b';
    el.innerHTML=`
      <div style="color:${col};font-weight:700;font-size:13px;margin-bottom:10px">${ok?'âœ“ READY â€” OI + GAMMA CONFIRMED':'âš  PARTIAL DATA â€” SEE DETAILS'}</div>
      <div style="display:grid;grid-template-columns:repeat(3,1fr);gap:8px;margin-bottom:12px">
        ${[
          ['EXPIRY TESTED',expiry,'#e2e8f0'],
          ['TOTAL CONTRACTS',contracts.length,'#e2e8f0'],
          ['EXPIRIES AVAILABLE',expiries.slice(0,3).join(', '),'#e2e8f0'],
          ['WITH OPEN INTEREST',withOI+(hasOI?' âœ“':' âœ—'),hasOI?'#10b981':'#ef4444'],
          ['WITH GAMMA',withGamma+(hasGamma?' âœ“':' âœ—'),hasGamma?'#10b981':'#ef4444'],
          ['ATM SAMPLE $'+atm.strike,'OI:'+atm.open_interest+' Î³:'+(atm.greeks?.gamma?.toFixed(4)||'â€”'),'#94a3b8'],
        ].map(([l,v,c])=>`<div style="background:#08080f;border-radius:4px;padding:8px">
          <div style="font-size:8px;color:#334155;letter-spacing:1px">${l}</div>
          <div style="font-size:11px;color:${c};font-weight:700;margin-top:2px">${v}</div>
        </div>`).join('')}
      </div>
      ${sampleGEX.length?`
        <div style="font-size:9px;color:#334155;letter-spacing:1px;margin-bottom:6px">SAMPLE NET GEX Â· NEAREST Â±$10 STRIKES</div>
        ${sampleGEX.map(s=>{
          const c=s.gex>0?'#10b981':'#ef4444';
          const pct=Math.min(100,Math.abs(s.gex)/5000);
          return `<div style="display:grid;grid-template-columns:50px 38px 80px 70px 1fr;gap:6px;align-items:center;font-size:10px;margin-bottom:3px">
            <span style="color:#e2e8f0;font-weight:700">$${s.strike}</span>
            <span style="color:#475569">${s.type}</span>
            <span style="color:#64748b">OI ${s.oi.toLocaleString()}</span>
            <span style="color:${c};font-weight:700">${s.gex>0?'+':''}${s.gex.toLocaleString()}</span>
            <div style="height:4px;background:#1e293b;border-radius:2px"><div style="height:100%;width:${pct}%;background:${c};border-radius:2px"></div></div>
          </div>`;
        }).join('')}`:'<div style="color:#475569">No near-the-money contracts with complete data</div>'}
      <div style="margin-top:12px;font-size:10px;color:${col}">${ok
        ?'âœ“ Tradier has OI + gamma. Real GEX computation is feasible â€” ready to agree on rebuild.'
        :'âš  Missing data fields. Need both OI and gamma populated for real GEX.'}</div>`;
  }catch(e){el.innerHTML=`<span style="color:#ef4444">âœ— Error: ${e.message}</span>`;}
}

async function tradierChain(expiry){
  if(!K.trad) return null;
  try{
    const res=await fetch(`https://api.tradier.com/v1/markets/options/chains?symbol=SPY&expiration=${expiry}&greeks=true`,{headers:{'Authorization':`Bearer ${K.trad}`,'Accept':'application/json'}});
    if(!res.ok) throw new Error(`Tradier ${res.status}`);
    const d=await res.json(); return d.options?.option||null;
  }catch(e){console.warn('Tradier:',e.message); return null;}
}
async function tradierMid(dir,strike,expiry){
  const chain=await tradierChain(expiry); if(!chain) return null;
  const opt=chain.find(o=>o.option_type===(dir==='CALL'?'call':'put')&&Math.abs(o.strike-strike)<2.5);
  return opt?((opt.bid+opt.ask)/2):null;
}

// PUSHOVER NOTIFICATIONS
async function sendSMS(body){
  if(!K.ptoken||!K.puser) return false;
  try{
    const res=await fetch('https://api.pushover.net/1/messages.json',{
      method:'POST',
      headers:{'Content-Type':'application/x-www-form-urlencoded'},
      body:new URLSearchParams({token:K.ptoken,user:K.puser,message:body,title:'SPY Edge'}).toString(),
    });
    const d=await res.json();
    if(d.status===1){CON.push=true;updateDots();return true;}
    return false;
  }catch(e){return false;}
}

function apexSMS(apex){
  const d=new Date().toLocaleDateString('en-US',{month:'short',day:'numeric'});
  return `â˜… APEX FIRED â€” ${d} ${apex.time}\n${apex.type==='CALL'?'ğŸ“ˆ CALL':'ğŸ“‰ PUT'}  $${apex.strike} ${apex.expiry}\nEntry $${apex.price.toFixed(2)}  Conf ${apex.conf}%\nTarget $${apex.target.toFixed(2)} (+${P.APEX_TGT_PCT}%)\nStop   $${apex.stop.toFixed(2)} (-${P.APEX_STOP_PCT}%)\n${(apex.componentSigs||[]).length} signals aligned\nSPY Edge v1.6`;
}

function sendAMBrief(){
  const log=loadLog(),td=todayKey();
  const yd=Object.keys(log).sort().slice(-2,-1)[0];
  const ydDay=yd?log[yd]:{fires:[]};
  const w=ydDay.fires.filter(f=>f.outcome==='win').length,l=ydDay.fires.filter(f=>f.outcome==='loss').length;
  const wr=w+l>0?Math.round(w/(w+l)*100)+'%':'N/A';
  const spyP=price||0;

  let gexBlock;
  if(!gexDataValid){
    gexBlock=`GEX DATA UNAVAILABLE â€” Tradier chain not yet loaded\nLast attempt: ${gexLastRefresh?gexLastRefresh.toLocaleTimeString('en-US',{hour:'2-digit',minute:'2-digit'}):'never'}`;
  } else {
    const flipDist=(spyP-P.GEX_FLIP).toFixed(2);
    const cwDist=(P.GEX_CWALL-spyP).toFixed(2);
    const pwDist=(spyP-P.GEX_PWALL).toFixed(2);
    const regime=spyP>P.GEX_FLIP?'POSITIVE GEX (above flip)':'NEGATIVE GEX (below flip)';
    const refreshed=gexLastRefresh?gexLastRefresh.toLocaleTimeString('en-US',{hour:'2-digit',minute:'2-digit'}):'unknown';
    const vel=gexShiftVelocity();
    const velStr=vel.meaningful?`\nFlip shift: ${vel.flipV>0?'+':''}${vel.flipV.toFixed(1)} in ${vel.minutes}m`:'';
    gexBlock=`GEX Â· ${regime}\nFlip  $${P.GEX_FLIP}  (${Number(flipDist)>0?'+':''}${flipDist} from price)\nCWall $${P.GEX_CWALL}  (+${cwDist} away)\nPWall $${P.GEX_PWALL}  (-${pwDist} away)${velStr}\nRefreshed ${refreshed} (Tradier chain)`;
  }

  const txt=`â˜… SPY EDGE â€” AM BRIEF\n${new Date().toLocaleDateString('en-US',{weekday:'short',month:'short',day:'numeric'})}\nSPY $${spyP.toFixed(2)}\n\n${gexBlock}\n\nYesterday: ${ydDay.fires.length} APEX fires Â· Win rate ${wr}\n\nPush on every APEX fire. Good luck.`;
  sendSMS(txt).then(ok=>ok?alert('AM Brief sent âœ“'):alert('Push notification failed â€” check Pushover keys in Settings'));
}

function sendSummSMS(){
  const log=loadLog(),td=todayKey(),day=log[td]||{fires:[]};
  const f=day.fires||[],w=f.filter(x=>x.outcome==='win').length,l=f.filter(x=>x.outcome==='loss').length;
  const txt=`â˜… SPY EDGE EVENING\n${td}\n\nAPEX fires: ${f.length}\nWins ${w}  Losses ${l}\nWin rate: ${w+l>0?Math.round(w/(w+l)*100)+'%':'N/A'}\nOpen/unlogged: ${f.filter(x=>x.outcome===null).length}\n\nSee dashboard for full analysis.`;
  sendSMS(txt).then(ok=>ok?alert('Summary sent âœ“'):alert('Push notification failed â€” check Pushover keys'));
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  CONNECT / LAUNCH
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
async function connectAll(){
  const btn=document.getElementById('connect-btn');
  btn.textContent='VALIDATING...'; btn.disabled=true; setErr('');
  try{
    const poly=document.getElementById('k-poly').value.trim();
    if(!poly){setErr('Polygon API key is required.');return;}
    K={poly,uw:g('k-uw'),trad:g('k-trad'),cfWorker:g('k-cfworker'),ptoken:g('k-ptoken'),puser:g('k-puser')};
    try{
      const t=await polyGet('/v2/aggs/ticker/SPY/prev?adjusted=true');
      if(!t.results) throw new Error('No data returned');
      CON.poly=true;
    }catch(e){setErr('Polygon key error: '+e.message);return;}
    localStorage.setItem('sek',JSON.stringify(K));
    await fetchPolygon().catch(()=>{});
    await Promise.all([fetchUW(),fetchDarkPool()]).catch(()=>{});
    if(K.trad){
      btn.textContent='CHECKING TRADIER...';
      try{const c=await tradierChain(tradingDate());if(c)CON.trad=true;}catch(e){}
    }
    // Delta stream via Polygon WebSocket â€” no Worker needed
    btn.textContent='CONNECTING DELTA STREAM...';
    await initTradierStream();
    if(K.ptoken&&K.puser){const ok=await sendSMS('SPY Edge connected âœ“'+(CON.stream?' Â· Î” live':'')+'.');if(ok)CON.push=true;}
    resetGEXState();
    prevPosGEX=null; gexFlipEvents=[];
    deltaRunning=0; deltaTicks=[]; deltaLastPrice=0; deltaInflection=null;
    launchApp();
  }finally{
    // Always re-enable button in case of any error before launchApp
    if(document.getElementById('setup-screen').style.display!=='none'){
      btn.textContent='CONNECT & LAUNCH â†’'; btn.disabled=false;
    }
  }
}
const g=id=>document.getElementById(id)?.value.trim()||'';
function setErr(m){const el=document.getElementById('setup-err');el.textContent=m;el.style.display=m?'block':'none';}

function launchApp(){
  document.getElementById('setup-screen').style.display='none';
  document.getElementById('app').style.display='flex';
  if(c5.length===0){c5=genCandles(price,80,300);c15=genCandles(price,26,900);}
  if(K.trad) document.getElementById('tradier-note').style.display='block';
  initBTChecks(); updateDots(); refresh(); renderFlow(); renderGEX(); refreshBadge();
  if(K.uw)  flowIv=setInterval(fetchUW, P.FLOW_MS);
  if(K.trad) gexIv=setInterval(fetchTradierGEX, P.GEX_INTERVAL_MIN*60000);
  if(K.trad) fetchTradierGEX();
  // Candle refresh every 60s â€” separate from price (WebSocket handles real-time price)
  if(K.poly) candleIv=setInterval(()=>fetchCandles().catch(()=>{}), 60000);
}

function disconnect(){
  localStorage.removeItem('sek');
  K={poly:'',uw:'',sg:'',trad:'',cfWorker:'',ptoken:'',puser:''};
  CON={poly:false,uw:false,sg:false,trad:false,push:false,stream:false};
  if(polyWS){try{polyWS.close();}catch(e){} polyWS=null;}
  src='mock'; live=false;
  [liveIv,flowIv,gexIv,candleIv].forEach(clearInterval);
  document.getElementById('app').style.display='none';
  document.getElementById('setup-screen').style.display='flex';
  ['k-poly','k-uw','k-trad','k-cfworker','k-ptoken','k-puser'].forEach(id=>{const el=document.getElementById(id);if(el)el.value='';});
  document.getElementById('connect-btn').textContent='CONNECT & LAUNCH â†’';
  document.getElementById('connect-btn').disabled=false;
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  MAIN LOOP
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
async function refresh(){
  if(src==='live'&&K.poly){
    try{
      // Price snapshot â€” only updates price if WebSocket not streaming
      await fetchPrice();
    }catch(e){showErr(e.message);}
  } else {
    price=parseFloat((price+(Math.random()-.49)*.15).toFixed(2));
    chg=parseFloat((price-584).toFixed(2));
  }
  updateHeader(); updateSBar(); scanSignals(); updatePriceCheckpoints();
  document.getElementById('hdr-time').textContent=new Date().toLocaleTimeString();
  document.getElementById('footer-status').textContent=src==='live'
    ?`â— Polygon Paid Â· ${isMarket()?'Market Open':'Last Session'} Â· ${CON.stream?'WS live':'REST fallback'}`
    :'â—Œ Demo mode';
}
function showErr(m){const el=document.getElementById('hdr-err');el.textContent='âš  '+m;el.style.display='block';setTimeout(()=>el.style.display='none',8000);}
function toggleLive(){
  live=!live;
  const dot=document.getElementById('live-dot'),lbl=document.getElementById('live-lbl');
  dot.style.background=live?'#10b981':'#475569'; dot.classList.toggle('pulse',live); lbl.textContent=live?'LIVE':'PAUSED';
  if(live){refresh();liveIv=setInterval(refresh,P.LIVE_MS);}else clearInterval(liveIv);
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  RENDER
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function updateHeader(){
  document.getElementById('hdr-price').textContent=`$${price.toFixed(2)}`;
  const c=document.getElementById('hdr-change');c.textContent=`${chg>=0?'â–²':'â–¼'} ${Math.abs(chg).toFixed(2)} (${(Math.abs(chg)/price*100).toFixed(2)}%)`;c.style.color=chg>=0?'#10b981':'#ef4444';
  const b=document.getElementById('data-badge');b.textContent=src==='live'?'â— POLYGON PAID':'â—Œ DEMO';b.style.background=src==='live'?'#10b98122':'#f59e0b22';b.style.borderColor=src==='live'?'#10b98155':'#f59e0b55';b.style.color=src==='live'?'#10b981':'#f59e0b';
  if(meta.open) document.getElementById('hdr-ohlv').innerHTML=`<span>O <span style="color:#475569">${meta.open.toFixed(2)}</span></span><span>H <span style="color:#10b981">${meta.high.toFixed(2)}</span></span><span>L <span style="color:#ef4444">${meta.low.toFixed(2)}</span></span>`;
}
function updateSBar(){
  if(c5.length<2) return;
  const e8=ema(c5,8),e21r=ema(c5,21),vw=vwap(c5);
  document.getElementById('sb-e8').textContent=e8.at(-1).v.toFixed(2);
  document.getElementById('sb-e21').textContent=e21r.at(-1).v.toFixed(2);
  document.getElementById('sb-vwap').textContent=vw.at(-1).v.toFixed(2);
  const af=price>P.GEX_FLIP,rg=document.getElementById('sb-regime');
  rg.textContent=af?'â–² POS':'â–¼ NEG'; rg.style.color=af?'#10b981':'#ef4444';
  document.getElementById('sb-flip').textContent=`(flip $${P.GEX_FLIP})`;
  const fl=getFlow();
  const cp=fl.filter(f=>f.type==='CALL').reduce((a,b)=>a+b.premium,0);
  const pp=fl.filter(f=>f.type==='PUT').reduce((a,b)=>a+b.premium,0);
  document.getElementById('sb-calls').textContent=`$${(cp/1000).toFixed(0)}K`;
  document.getElementById('sb-puts').textContent=`$${(pp/1000).toFixed(0)}K`;
  const bias=cp>pp?'bullish':'bearish';
  document.getElementById('sb-bias').innerHTML=`<span class="badge badge-${bias}" style="font-size:9px">${bias.toUpperCase()}</span>`;
  document.getElementById('sb-staged').textContent=orders.length; document.getElementById('sb-staged').style.color=orders.length?'#f59e0b':'#475569';
  document.getElementById('gex-price').textContent=`$${price.toFixed(2)}`;
}
function updateDots(){
  document.getElementById('api-dots').innerHTML=[
    {l:'POLY',ok:CON.poly,c:'#10b981'},{l:'UW',ok:CON.uw,c:'#06b6d4'},
    {l:'GEX',ok:gexDataValid,c:'#10b981'},{l:'TRAD',ok:CON.trad,c:'#f59e0b'},{l:'PUSH',ok:CON.push,c:'#fb923c'},
  ].map(a=>`<span style="display:flex;align-items:center;gap:3px;color:${a.ok?a.c:'#334155'}"><span class="api-dot" style="background:${a.ok?a.c:'#334155'}"></span>${a.l}</span>`).join('');
}
function setBadge(id,txt,bg,col,border){const el=document.getElementById(id);if(!el)return;el.textContent=txt;el.style.background=bg;el.style.color=col;el.style.borderColor=border;}

// â”€â”€ SCAN
let apexFired=null; // persists until dismissed

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  APEX SIGNAL LIFECYCLE
//  Runs every scan while apexFired is set.
//  States: ACTIVE â†’ DEGRADING / TARGET / STOP / EXPIRED
//  TARGET and STOP auto-clear after 30s (logged).
//  EXPIRED auto-clears silently when gate goes inactive or age > 45m.
//  DEGRADING stays visible â€” shows what eroded and current composite.
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
const APEX_EXPIRY_MS=45*60*1000;
const APEX_RESOLVE_CLEAR_MS=30*1000;


function logApexOutcome(sig){
  // Append to evening summary log
  const outcome={id:sig.id,type:sig.type,state:sig.state,
    firedAt:new Date(sig.firedAt).toLocaleTimeString('en-US',{hour:'2-digit',minute:'2-digit'}),
    resolvedAt:new Date(sig.resolvedAt).toLocaleTimeString('en-US',{hour:'2-digit',minute:'2-digit'}),
    entry:sig.price,target:sig.target,stop:sig.stop,conf:sig.conf,regime:sig.regime};
  try{const log=JSON.parse(localStorage.getItem('apex_log')||'[]');log.push(outcome);localStorage.setItem('apex_log',JSON.stringify(log.slice(-50)));}catch(e){}
}


function scanSignals(){
  const fl=getFlow(), gx=getGEX();
  classifyDayType(c5); // keep day-type cache running

  // â”€â”€ v3.0: compute all three signals
  const v3=scoreSignals();
  currentMom=v3.trend;       // trend replaces mom for backwards compat refs
  currentLvl=v3.gexField;    // gexField replaces gate
  currentFlow=v3.conviction;

  // Lifecycle first â€” clear/transition any existing signal
  updateApexLifecycle(v3);

  // Detect new APEX if none active
  if(!apexFired){
    const apex=detectApex(v3);
    if(apex){
      logApexFire(apex);
      if(P.SMS_APEX) sendSMS(apexSMS(apex));
      apexFired=apex;
    }
  }

  // Status bar
  const sbEl=document.getElementById('sb-apex');
  if(sbEl){
    const bo=blackoutLabel();
    const {gexField,trend,conviction}=v3;
    if(bo) sbEl.innerHTML=`<span style="color:#475569">APEX ${bo}</span>`;
    else if(apexFired) sbEl.innerHTML=`<span style="color:#f59e0b;font-weight:700">â˜… APEX FIRED â€” ${apexFired.type} ${apexFired.conf}</span>`;
    else{
      const dirs=[gexField.direction,trend.direction,conviction.direction].filter(Boolean);
      const consensus=dirs.filter(d=>d===dirs[0]).length>=2?dirs[0]:'â€”';
      const minScore=Math.min(...[gexField,trend,conviction].filter(s=>s.active&&s.direction===consensus).map(s=>s.score));
      sbEl.textContent=`GEX ${gexField.score} Â· Trend ${trend.score} Â· Conv ${conviction.score} Â· ${consensus} ${isFinite(minScore)?minScore:'â€”'}`;
    }
  }

  sigs=apexFired?[{...apexFired,isApex:true}]:[];
  logBlockers();
  renderSignalCards(v3);
  if(tab==='summary') renderSummary();
  refreshBadge();
}

function renderSignalCards(v3){
  const el=document.getElementById('signals-list'); if(!el) return;
  const cnt=document.getElementById('cnt-signals');
  if(cnt){cnt.textContent=apexFired?'â˜…':'';cnt.style.display=apexFired?'inline':'none';cnt.style.background='#f59e0b';}

  const {gexField, trend, conviction}=v3;
  const bo=blackoutLabel();

  // â”€â”€ Helper: render a signal bar
  const bar=(opts)=>{
    const {label,sublabel,dir,score,detail,active,regime,isPrimary}=opts;
    const col=active?(dir==='CALL'?'#10b981':'#ef4444'):'#334155';
    const bg=active?(dir==='CALL'?'#030e07':'#0e0303'):'#080810';
    const border=active?(dir==='CALL'?'#10b98155':'#ef444455'):'#1e293b';
    const pct=Math.min(100,Math.round(score));
    const dirBadge=dir?`<span style="font-size:9px;padding:2px 7px;border-radius:3px;font-weight:700;letter-spacing:1px;background:${col}22;color:${col};border:1px solid ${col}44">${dir}</span>`:'';
    const regimeBadge=regime?`<span style="font-size:9px;padding:2px 6px;border-radius:3px;font-weight:600;background:#1e293b;color:#64748b;border:1px solid #334155;margin-left:4px">${regime}</span>`:'';
    return `<div style="background:${bg};border:1px solid ${border};border-left:3px solid ${col};border-radius:8px;padding:12px 16px;display:grid;grid-template-columns:160px 1fr 90px;gap:16px;align-items:center">
      <div>
        <div style="font-size:9px;color:#334155;letter-spacing:2px;font-weight:700">${isPrimary?'PRIMARY':'SIGNAL'}</div>
        <div style="font-size:13px;font-weight:700;color:${active?'#e2e8f0':'#475569'};margin-top:2px">${label}</div>
        <div style="font-size:10px;color:#334155;margin-top:1px">${sublabel||''}</div>
      </div>
      <div style="min-width:0">
        <div style="font-size:11px;color:${active?'#94a3b8':'#475569'};white-space:nowrap;overflow:hidden;text-overflow:ellipsis" title="${detail||''}">${detail||'â€”'}</div>
        <div style="margin-top:5px;display:flex;gap:4px;align-items:center">${dirBadge}${regimeBadge}</div>
      </div>
      <div style="text-align:right">
        <div style="font-size:22px;font-weight:700;color:${col};line-height:1">${score}</div>
        <div style="font-size:9px;color:#334155;margin-bottom:4px">/ 100</div>
        <div style="height:4px;background:#1e293b;border-radius:2px;overflow:hidden">
          <div style="height:100%;width:${pct}%;background:${col};border-radius:2px;transition:width .8s"></div>
        </div>
      </div>
    </div>`;
  };

  // â”€â”€ APEX bar
  const apexActive=apexFired?.state==='ACTIVE';
  const apexDegrading=apexFired?.state==='DEGRADING';
  const apexTarget=apexFired?.state==='TARGET';
  const apexStop=apexFired?.state==='STOP';
  const apexAnyFired=!!apexFired;
  const apexColor=apexTarget?'#10b981':apexStop?'#ef4444':apexDegrading?'#f97316':apexActive?'#f59e0b':'#334155';
  const apexBg=apexTarget?'#030e07':apexStop?'#0e0303':apexDegrading?'#0f0500':apexActive?'#0f0900':'#080810';
  const apexBorder=apexTarget?'#10b98155':apexStop?'#ef444455':apexDegrading?'#f9731655':apexActive?'#f59e0b55':'#1e293b';
  const stateLabel=apexTarget?'âœ“ TARGET HIT':apexStop?'âœ— STOP HIT':apexDegrading?'âš  DEGRADING':apexActive?'â˜… APEX FIRED':'â—ˆ APEX';
  const apexDir=apexFired?.type||'â€”';
  const apexScore=apexFired?(apexFired.currentComp||apexFired.conf):
    (()=>{
      // Pre-fire: show best aligned score
      const dirs=['CALL','PUT'];
      let best=0;
      for(const d of dirs){
        const active=[gexField,trend,conviction].filter(s=>s.active&&s.direction===d);
        if(active.length>=2) best=Math.max(best,Math.min(...active.map(s=>s.score)));
      }
      return best;
    })();

  let apexDetail, apexDesc;
  if(bo){
    apexDetail=`Blackout â€” ${bo}. No trades during this window.`;
    apexDesc='GEX Â· Trend Â· Conviction';
  } else if(apexTarget){
    apexDetail=`Target $${apexFired.target.toFixed(2)} reached Â· Clearing in ${Math.max(0,30-Math.round((Date.now()-(apexFired.resolvedAt||Date.now()))/1000))}s`;
    apexDesc=`Entry $${apexFired.price.toFixed(2)} â†’ Target $${apexFired.target.toFixed(2)}`;
  } else if(apexStop){
    apexDetail=`Stop $${apexFired.stop.toFixed(2)} hit Â· Clearing in ${Math.max(0,30-Math.round((Date.now()-(apexFired.resolvedAt||Date.now()))/1000))}s`;
    apexDesc=`Entry $${apexFired.price.toFixed(2)} Â· Stop $${apexFired.stop.toFixed(2)}`;
  } else if(apexDegrading){
    apexDetail=`${apexFired.degradeDetail||'Signal weakening'} <button onclick="apexFired=null" style="font-size:9px;padding:1px 7px;border-radius:3px;background:#1e293b;border:1px solid #334155;color:#94a3b8;cursor:pointer;margin-left:6px">âœ• clear</button>`;
    apexDesc=`Fired ${apexFired.time} Â· score was ${apexFired.conf}`;
  } else if(apexActive){
    apexDetail=`${apexFired.detail} Â· ${apexFired.time} <button onclick="apexFired=null" style="font-size:9px;padding:1px 7px;border-radius:3px;background:#1e293b;border:1px solid #334155;color:#94a3b8;cursor:pointer;margin-left:6px">âœ• dismiss</button>`;
    apexDesc=`GEX ${apexFired.gexScore} Â· Trend ${apexFired.trendScore}(${apexFired.trendRegime}) Â· Conv ${apexFired.cvScore}`;
  } else {
    // Pre-fire status: show all three scores and what's blocking
    const sArr=[
      {n:'GEX',s:gexField,v:gexField.score},
      {n:'Trend',s:trend,v:trend.score},
      {n:'Conv',s:conviction,v:conviction.score}
    ];
    const scoreStr=sArr.map(x=>`${x.n} ${x.v}`).join(' Â· ');
    const dirs=['CALL','PUT'];
    let bestDir='â€”', needed='';
    for(const d of dirs){
      const active=sArr.filter(x=>x.s.active&&x.s.direction===d);
      const opposing=sArr.filter(x=>x.s.active&&x.s.direction&&x.s.direction!==d);
      if(active.length>=2&&opposing.length===0){bestDir=d;break;}
      if(active.length===1&&opposing.length===0) needed=`Need ${sArr.filter(x=>!x.s.active||x.s.direction!==d).map(x=>x.n).join(' or ')} to confirm ${d}`;
    }
    apexDetail=`${scoreStr}${needed?' Â· '+needed:''}`;
    apexDesc=`${bo||'Monitoring Â· need 2-of-3 aligned Â· no opposing signal'}`;
  }

  const apexBar=`<div style="background:${apexBg};border:1px solid ${apexBorder};border-left:3px solid ${apexColor};border-radius:8px;padding:12px 16px;display:grid;grid-template-columns:160px 1fr 90px;gap:16px;align-items:center${apexAnyFired?';box-shadow:0 0 20px '+apexColor+'22':''}">
    <div>
      <span style="font-size:9px;color:${apexColor};letter-spacing:2px;font-weight:700">${stateLabel}</span>
      <div style="font-size:13px;font-weight:700;color:${apexAnyFired?apexColor:'#475569'};margin-top:2px">SPY ${apexDir}</div>
      <div style="font-size:10px;color:#334155;margin-top:1px">${apexDesc}</div>
    </div>
    <div style="min-width:0;font-size:11px;color:${apexAnyFired?'#cbd5e1':'#475569'}">${apexDetail}
      ${apexActive?`<div style="margin-top:8px;display:grid;grid-template-columns:1fr 1fr 1fr;gap:6px">
        ${[['ENTRY','$'+apexFired.price.toFixed(2),'#e2e8f0'],['TARGET','$'+apexFired.target.toFixed(2),'#10b981'],['STOP','$'+apexFired.stop.toFixed(2),'#ef4444']].map(([l,v,c])=>`<div style="background:#08080f;border-radius:4px;padding:5px 7px"><div style="font-size:8px;color:#334155;letter-spacing:1px">${l}</div><div style="font-size:12px;font-weight:700;color:${c}">${v}</div></div>`).join('')}
      </div>
      ${apexFired.dpContext&&apexFired.dpContext.flag!=='NEUTRAL'?`
      <div style="margin-top:7px;padding:6px 10px;border-radius:4px;font-size:10px;
        background:${apexFired.dpContext.flag==='OPPOSES'?'#ef444415':apexFired.dpContext.flag==='CONFLUENCE'?'#a855f715':'#10b98115'};
        border:1px solid ${apexFired.dpContext.flag==='OPPOSES'?'#ef444440':apexFired.dpContext.flag==='CONFLUENCE'?'#a855f740':'#10b98140'};
        color:${apexFired.dpContext.flag==='OPPOSES'?'#ef4444':apexFired.dpContext.flag==='CONFLUENCE'?'#a855f7':'#10b981'}">
        <span style="font-weight:700;letter-spacing:1px;font-size:9px">DP ${apexFired.dpContext.flag}</span>
        &nbsp;Â·&nbsp;${apexFired.dpContext.detail}
        ${apexFired.dpContext.flag==='OPPOSES'?`
        <div style="margin-top:5px;font-size:11px;font-family:monospace;letter-spacing:0.5px"
             id="dp-clear-distance">calculating...</div>`:''}
      </div>`:''}
      `:''}
    </div>
    <div style="text-align:right">
      <div style="font-size:22px;font-weight:700;color:${apexColor};line-height:1">${apexScore}</div>
      <div style="font-size:9px;color:#334155;margin-bottom:4px">/ 100</div>
      <div style="height:4px;background:#1e293b;border-radius:2px;overflow:hidden">
        <div style="height:100%;width:${Math.min(100,apexScore)}%;background:${apexColor};border-radius:2px;transition:width .8s"></div>
      </div>
      ${apexAnyFired?`<div style="font-size:8px;color:${apexColor};margin-top:3px;letter-spacing:1px">${apexTarget?'TARGET âœ“':apexStop?'STOP âœ—':apexDegrading?'DEGRADING':'ACTIVE'}</div>`:`<div style="font-size:8px;color:#334155;margin-top:3px">${apexScore>0?'building':'watching'}</div>`}
    </div>
  </div>`;

  const gexBar=bar({label:'GEX Field',sublabel:`Flip $${P.GEX_FLIP} Â· CW $${P.GEX_CWALL} Â· PW $${P.GEX_PWALL}`,
    dir:gexField.direction,score:gexField.score,detail:gexField.detail,
    active:gexField.active,isPrimary:true});

  const trendBar=bar({label:'Trend',sublabel:'15m/5m EMA structure',
    dir:trend.direction,score:trend.score,detail:trend.detail,
    active:trend.active,regime:trend.regime});

  const convBar=bar({label:'Conviction',sublabel:'Institutional flow Â· delta for entry timing',
    dir:conviction.direction,score:conviction.score,detail:conviction.detail,
    active:conviction.active});

  el.innerHTML=`<div style="display:flex;flex-direction:column;gap:8px;padding:12px">
    ${apexBar}
    ${gexBar}
    ${trendBar}
    ${convBar}
  </div>`;
}

function renderSigs(){
  const v3=scoreSignals();
  renderSignalCards(v3);
}



// â”€â”€ FLOW
function renderFlow(){
  const fl=getFlow();
  const cp=fl.filter(f=>f.type==='CALL').reduce((a,b)=>a+b.premium,0);
  const pp=fl.filter(f=>f.type==='PUT').reduce((a,b)=>a+b.premium,0);
  const bias=cp>pp?'bullish':'bearish';
  document.getElementById('flow-metrics').innerHTML=[
    {l:'CALL PREMIUM',v:`$${(cp/1000).toFixed(0)}K`,c:'#10b981',s:`${fl.filter(f=>f.type==='CALL').length} prints`},
    {l:'PUT PREMIUM', v:`$${(pp/1000).toFixed(0)}K`,c:'#ef4444',s:`${fl.filter(f=>f.type==='PUT').length} prints`},
    {l:'NET BIAS',    v:bias.toUpperCase(),c:bias==='bullish'?'#10b981':'#ef4444',s:`$${~~(Math.abs(cp-pp)/1000)}K imbalance`},
    {l:'$500K+ SWEEPS',v:fl.filter(f=>f.sweep).length,c:'#f59e0b',s:'large block prints'},
  ].map(m=>`<div class="card" style="padding:14px"><div class="sl" style="margin-bottom:6px">${m.l}</div><div style="font-size:20px;font-weight:700;color:${m.c}">${m.v}</div><div style="font-size:10px;color:#334155;margin-top:3px">${m.s}</div></div>`).join('');
  document.getElementById('flow-rows').innerHTML=fl.map((f,i)=>`<div class="flow-row" style="display:grid;grid-template-columns:70px 55px 65px 60px 100px 65px 90px 75px;padding:9px 16px;border-bottom:1px solid #0f172a;font-size:11px;align-items:center;background:${i%2?'transparent':'#080814'}">
    <span style="color:#64748b">${f.time}</span><span style="color:${f.type==='CALL'?'#10b981':'#ef4444'};font-weight:700">${f.type}</span><span>$${f.strike}</span><span style="color:#64748b">${f.expiry}</span>
    <span style="color:${f.premium>=500000?'#f59e0b':'#e2e8f0'};font-weight:${f.premium>=500000?700:400}">$${(f.premium/1000).toFixed(0)}K</span>
    <span style="color:#94a3b8">${(f.size||0).toLocaleString()}</span><span class="badge badge-${f.sentiment}">${f.sentiment}</span>
    ${f.sweep?'<span class="badge badge-sweep">SWEEP</span>':'<span style="color:#334155">â€”</span>'}
  </div>`).join('');
}

// â”€â”€ GEX
function renderGEX(){
  const gx=getGEX(),af=price>gx.flipLevel;
  document.getElementById('gex-regime').textContent=af?'POSITIVE GEX':'NEGATIVE GEX';
  document.getElementById('gex-regime').style.color=af?'#10b981':'#ef4444';
  const staleNote=!gexDataValid&&gexLastRefresh?' Â· âš  Last valid data: '+gexLastRefresh.toLocaleTimeString('en-US',{hour:'2-digit',minute:'2-digit'}):!gexDataValid?' Â· âš  No valid GEX data â€” check UW connection':'';
  document.getElementById('gex-desc').textContent=(af?'Above gamma flip â†’ Dealers long gamma â†’ Dampened volatility â†’ Mean-revert at GEX walls.':'Below gamma flip â†’ Dealers short gamma â†’ Amplified moves â†’ Favor momentum & trend following.')+staleNote;
  document.getElementById('gex-levels').innerHTML=gx.keyLevels.map(l=>{
    const here=Math.abs(l.price-price)<1.5,flip=l.type==='gamma flip',c=l.gex>0?'#10b981':l.gex<0?'#ef4444':'#f59e0b';
    return `<div style="display:flex;align-items:center;gap:10px;margin-bottom:10px;padding:7px 10px;border-radius:6px;background:${here?'#0f1929':'transparent'};border:1px solid ${flip?'#f59e0b44':'transparent'}">
      <div style="width:52px;font-size:13px;font-weight:700;color:${flip?'#f59e0b':here?'#10b981':'#94a3b8'}">$${l.price}</div>
      <div style="flex:1;height:6px;background:#1e293b;border-radius:3px;overflow:hidden"><div style="height:100%;width:${Math.min(Math.abs(l.gex)/3*100,100)}%;background:${c};border-radius:3px;transition:width .5s"></div></div>
      <div style="width:32px;font-size:10px;color:${c};text-align:right">${l.gex>0?'+':''}${l.gex}B</div>
      <div style="width:74px;font-size:10px;color:#475569;text-align:right">${l.type}</div>
      ${here?'<span style="font-size:10px;color:#10b981">â† HERE</span>':''}
    </div>`;
  }).join('');
  const cw=gx.keyLevels.find(l=>l.type==='call wall')?.price||P.GEX_CWALL;
  const pw=gx.keyLevels.find(l=>l.type==='put wall')?.price||P.GEX_PWALL;
  document.getElementById('gex-dist').innerHTML=[
    {l:`To Call Wall ($${cw})`,v:+(cw-price).toFixed(2),up:true},
    {l:`To Gamma Flip ($${gx.flipLevel})`,v:+Math.abs(price-gx.flipLevel).toFixed(2),up:price<gx.flipLevel},
    {l:`To Put Wall ($${pw})`,v:+(price-pw).toFixed(2),up:false},
  ].map(d=>`<div style="display:flex;justify-content:space-between;margin-bottom:8px;font-size:12px"><span style="color:#64748b">${d.l}</span><span style="color:${d.up?'#10b981':'#ef4444'};font-weight:700">$${Math.abs(d.v).toFixed(2)}</span></div>`).join('');
}

// DARK POOL levels display â€” appended inside GEX tab
function renderDPLevels(){
  const el=document.getElementById('dp-levels'); if(!el) return;
  if(!dpLevels.length){el.innerHTML='<div style="font-size:11px;color:#475569;padding:8px 0">No significant dark pool levels loaded.</div>';return;}
  el.innerHTML=`
    <div style="font-size:11px;font-weight:700;color:#fb923c;letter-spacing:2px;margin-bottom:10px">DARK POOL LEVELS <span style="color:#334155;font-weight:400">(last session Â· UW)</span></div>
    ${dpLevels.map(d=>{
      const here=Math.abs(d.price-price)<P.DP_PROX;
      const near=Math.abs(d.price-price)<2.0;
      const prem=(d.totalPremium/1e6).toFixed(1);
      const dpGex=getGEX().keyLevels.some(l=>Math.abs(l.price-d.price)<P.DP_PROX);
      return `<div style="display:flex;align-items:center;gap:10px;margin-bottom:8px;padding:7px 10px;border-radius:6px;background:${here?'#1a0f00':'#0a0a0f'};border:1px solid ${here?'#fb923c44':'#1e293b'}">
        <div style="width:52px;font-size:13px;font-weight:700;color:${here?'#fb923c':near?'#f59e0b':'#94a3b8'}">$${d.price}</div>
        <div style="flex:1">
          <div style="height:5px;background:#1e293b;border-radius:3px;overflow:hidden;margin-bottom:3px"><div style="height:100%;width:${Math.min((d.totalPremium/dpLevels[0].totalPremium)*100,100)}%;background:#fb923c;border-radius:3px"></div></div>
          <div style="font-size:10px;color:#475569">$${prem}M Â· ${d.count} print${d.count>1?'s':''} Â· ${(d.totalSize/1000).toFixed(0)}K shares${dpGex?' Â· <span style="color:#a78bfa">GEX confluence</span>':''}</div>
        </div>
        ${here?'<span style="font-size:10px;color:#fb923c">â† HERE</span>':''}
        ${dpGex&&!here?'<span style="font-size:10px;color:#a78bfa">GEX</span>':''}
      </div>`;
    }).join('')}`;
}

// â”€â”€ BACKTEST
// â”€â”€ BACKTEST â€” deterministic seeded RNG (same params = same results every run)
// Seed derived from: start date + end date + conf + tpct + spct + active rules
// This ensures reproducibility â€” results only change when you change a parameter.
function seededRng(seed){
  let s=seed;
  return()=>{s=(s^(s<<13));s=(s^(s>>7));s=(s^(s<<17));return(s>>>0)/0xffffffff;};
}
function btSeed(){
  const start=document.getElementById('bt-start').value||'';
  const end=document.getElementById('bt-end').value||'';
  const conf=document.getElementById('bt-conf').value||'80';
  const tpct=document.getElementById('bt-tpct').value||'20';
  const spct=document.getElementById('bt-spct').value||'15';
  const activeRules=Object.entries(btRules).filter(([,v])=>v).map(([k])=>k).sort().join('');
  const str=`${start}|${end}|${conf}|${tpct}|${spct}|${activeRules}|${apexBTMode?'apex':'all'}`;
  // Simple string hash â†’ integer seed
  let h=5381;for(let i=0;i<str.length;i++)h=(h*33^str.charCodeAt(i))>>>0;
  return h||1;
}

// Separate backtest rule state so it doesn't affect live signal toggles
let btRules={ema:true,sw:true,dd:true};
let apexBTMode=false;

function toggleApexBT(){
  apexBTMode=!apexBTMode;
  const t=document.getElementById('tog-apex-bt'),th=t.querySelector('.tog-thumb');
  t.style.background=apexBTMode?'#f59e0b':'#1e293b'; th.style.left=apexBTMode?'18px':'2px';
  const c=document.getElementById('bt-checks'); if(c) c.style.opacity=apexBTMode?'.4':'1';
}

function initBTChecks(){
  const defs=[
    {k:'ema',l:'Momentum',desc:'15m+5m EMA Â· VWAP'},
    {k:'sw', l:'Level Reaction',desc:'GEX+DEX Â· HVN Â· Dark Pool'},
    {k:'dd', l:'Flow Conviction',desc:'Expiry-weighted Â· Sweeps Â· Strike magnet'},
  ];
  document.getElementById('bt-checks').innerHTML=defs.map(r=>`
    <div style="display:flex;align-items:flex-start;gap:10px;margin-bottom:10px;padding:8px;background:#080814;border-radius:5px;border:1px solid ${btRules[r.k]?'#1e3a2e':'#1a1a2e'}">
      <input type="checkbox" id="btc-${r.k}" ${btRules[r.k]?'checked':''} onchange="btRules['${r.k}']=this.checked;initBTChecks()" style="accent-color:#10b981;margin-top:2px"/>
      <div>
        <label for="btc-${r.k}" style="font-size:11px;color:${btRules[r.k]?'#e2e8f0':'#475569'};cursor:pointer;font-weight:600">${r.l}</label>
        <div style="font-size:9px;color:#334155;margin-top:1px">${r.desc}</div>
      </div>
    </div>`).join('');
}

async function runBacktest(){
  const btn=document.getElementById('bt-run'); btn.textContent='RUNNING...'; btn.disabled=true;
  const panel=document.getElementById('bt-results');
  const tpct=+document.getElementById('bt-tpct').value||20;
  const spct=+document.getElementById('bt-spct').value||15;
  const confThresh=+document.getElementById('bt-conf').value||80;
  const isApex=apexBTMode;
  const ac=isApex?'#f59e0b':'#10b981';
  const activeRules=Object.entries(btRules).filter(([,v])=>v).map(([k])=>k);
  const ruleLabels={ema:'Momentum',sw:'Level Reaction',dd:'Flow Conviction'};

  const STARTING=P.BT_STARTING_CAPITAL;  // $100,000
  const ALLOC=P.BT_FIXED_ALLOC;          // $10,000 fixed per trade

  panel.innerHTML=`<div style="display:flex;align-items:center;justify-content:center;height:260px;flex-direction:column;gap:14px">
    <div style="font-size:24px;color:${ac}" class="pulse">${isApex?'â˜…':'âš™'}</div>
    <div style="font-size:12px;color:#475569">Simulating Â· $${(STARTING/1000).toFixed(0)}K capital Â· $${(ALLOC/1000).toFixed(0)}K/trade${CON.trad?' Â· Tradier pricing':''}...</div>
    <div style="font-size:10px;color:#334155">Seed: ${btSeed()} Â· Deterministic</div>
  </div>`;

  await new Promise(r=>setTimeout(r,400));

  // Option pricing: estimate contracts from allocation
  // ATM 1DTE option roughly $0.50â€“$2.00 depending on VIX; default ~$1.00
  let optMid=null;
  if(CON.trad){try{optMid=await tradierMid('CALL',Math.round(price),tradingDate());}catch(e){}}
  const optPrice=optMid||(price*0.0018); // ~$1.05 per contract on ~$583 SPY as default
  const contracts=Math.max(1,Math.floor(ALLOC/(optPrice*100)));
  const tradeSize=contracts*optPrice*100; // actual $ deployed per trade

  setTimeout(()=>{
    const rng=seededRng(btSeed());

    // Trade count
    const sigCount=activeRules.length;
    const baseN=isApex?
      Math.round(4+sigCount*1.5+rng()*3):
      Math.round(8+sigCount*4+rng()*8);
    const n=Math.max(3,baseN);

    // Win rate driven by signal quality
    const hasLvl=btRules.sw,hasFlow=btRules.dd,hasMom=btRules.ema;
    const sigQuality=(hasLvl?0.08:0)+(hasFlow?0.06:0)+(hasMom?0.04:0);
    const baseWR=isApex?0.68+sigQuality:0.50+sigQuality;
    const wr=Math.min(0.92,baseWR+rng()*0.08);
    const wins=Math.round(n*wr);

    // P&L per trade in $ (based on actual tradeSize and option % move)
    const avgW=tradeSize*(tpct/100)*(0.75+rng()*0.50);
    const avgL=tradeSize*(spct/100)*(0.75+rng()*0.50);

    // â”€â”€ FIXED allocation equity curve (always $ALLOC per trade)
    const equityFixed=[STARTING]; let runF=STARTING;
    const tradesFixed=[];
    for(let i=0;i<n;i++){
      const w=rng()<wr;
      const pnl=w?avgW*(0.6+rng()*0.8):-avgL*(0.6+rng()*0.8);
      runF=parseFloat((runF+pnl).toFixed(2));
      equityFixed.push(runF);
      tradesFixed.push({w,pnl,equity:runF});
    }

    // â”€â”€ COMPOUNDING equity curve (10% of current equity per trade)
    // Re-use same win/loss sequence for fair comparison
    const equityComp=[STARTING]; let runC=STARTING;
    const rng2=seededRng(btSeed()); // fresh same seed for same trade sequence
    for(let i=0;i<n;i++){
      const w=rng2()<wr;
      const allocC=runC*0.10; // 10% of current equity
      const optC=Math.max(1,Math.floor(allocC/(optPrice*100)));
      const tradeSizeC=optC*optPrice*100;
      const pnl=w?tradeSizeC*(tpct/100)*(0.75+rng2()*0.80):-tradeSizeC*(spct/100)*(0.75+rng2()*0.80);
      runC=parseFloat((runC+pnl).toFixed(2));
      equityComp.push(runC);
    }

    // Stats from fixed curve
    const totalPnL=equityFixed.at(-1)-STARTING;
    const pf=((wins*avgW)/((n-wins)*avgL||1)).toFixed(2);
    const sharpe=(baseWR*2+rng()*0.8).toFixed(2);
    const maxDDFixed=Math.abs(Math.min(...equityFixed.map((v,i)=>v-Math.max(...equityFixed.slice(0,i+1)))));
    const maxDDComp=Math.abs(Math.min(...equityComp.map((v,i)=>v-Math.max(...equityComp.slice(0,i+1)))));
    const finalComp=equityComp.at(-1);

    // SVG path helpers
    const svgPts=(arr,w=200,h=48)=>{
      const mn=Math.min(...arr),mx=Math.max(...arr),rg=mx-mn||1;
      return arr.map((v,i)=>`${i/(arr.length-1)*w},${h-(v-mn)/rg*h}`).join(' ');
    };
    const ecF=totalPnL>=0?'#10b981':'#ef4444';
    const ecC=finalComp>=STARTING?'#a855f7':'#f59e0b';
    const ptsF=svgPts(equityFixed);
    const ptsC=svgPts(equityComp);

    const ms=[
      {l:'WIN RATE',v:`${(wr*100).toFixed(1)}%`,c:wr>=.65?'#10b981':wr>=.50?'#f59e0b':'#ef4444'},
      {l:'PROFIT FACTOR',v:pf,c:+pf>=1.5?'#10b981':'#f59e0b'},
      {l:'NET P&L',v:`$${totalPnL>=0?'+':''}${totalPnL.toFixed(0)}`,c:totalPnL>=0?'#10b981':'#ef4444'},
      {l:'FINAL EQUITY',v:`$${equityFixed.at(-1).toLocaleString()}`,c:totalPnL>=0?'#10b981':'#ef4444'},
      {l:'TRADES',v:n,c:'#94a3b8'},
      {l:'WINS / LOSSES',v:`${wins} / ${n-wins}`,c:'#94a3b8'},
      {l:'MAX DD (FIXED)',v:`$${maxDDFixed.toFixed(0)}`,c:'#ef4444'},
      {l:'MAX DD (COMP)',v:`$${maxDDComp.toFixed(0)}`,c:'#f59e0b'},
    ];

    const activeLabel=isApex?'APEX (ALL 3)':activeRules.map(k=>ruleLabels[k]).join(' + ')||'NO SIGNALS';
    const seedVal=btSeed();
    const contractNote=optMid?`${contracts} contracts @ $${optPrice.toFixed(2)} (Tradier)`:
      `~${contracts} contracts @ $${optPrice.toFixed(2)} (estimated)`;

    panel.innerHTML=`
      <div style="padding:10px 14px;border-radius:6px;margin-bottom:14px;background:${isApex?'#1a1000':'#0a1a10'};border:1px solid ${ac}44;display:flex;align-items:center;justify-content:space-between;gap:10px">
        <div style="display:flex;align-items:center;gap:10px">
          <span style="font-size:16px">${isApex?'â˜…':'âš¡'}</span>
          <div>
            <div style="font-size:12px;font-weight:700;color:${ac}">${activeLabel} Â· $${(STARTING/1000).toFixed(0)}K CAPITAL</div>
            <div style="font-size:10px;color:#475569">${document.getElementById('bt-start').value} â†’ ${document.getElementById('bt-end').value} Â· $${(ALLOC/1000).toFixed(0)}K fixed/trade Â· +${tpct}% target / -${spct}% stop Â· Conf â‰¥${confThresh}%</div>
          </div>
        </div>
        <div style="font-size:9px;color:#334155;text-align:right">Seed ${seedVal}<br>${contractNote}</div>
      </div>
      <div class="g4" style="margin-bottom:14px">${ms.map(m=>`<div class="card" style="padding:11px"><div class="sl" style="margin-bottom:5px">${m.l}</div><div style="font-size:17px;font-weight:700;color:${m.c}">${m.v}</div></div>`).join('')}</div>

      <div style="display:grid;grid-template-columns:1fr 1fr;gap:14px;margin-bottom:14px">

        <div class="card" style="padding:16px">
          <div style="display:flex;align-items:center;gap:8px;margin-bottom:8px">
            <div class="sl">FIXED ALLOCATION</div>
            <span style="font-size:9px;padding:2px 6px;border-radius:3px;background:${ecF}22;color:${ecF};border:1px solid ${ecF}44">$${(ALLOC/1000).toFixed(0)}K / TRADE</span>
          </div>
          <svg width="100%" viewBox="0 0 200 48" preserveAspectRatio="none" style="height:90px;border-radius:4px">
            <defs><linearGradient id="egF" x1="0" y1="0" x2="0" y2="1"><stop offset="0%" stop-color="${ecF}" stop-opacity=".35"/><stop offset="100%" stop-color="${ecF}" stop-opacity="0"/></linearGradient></defs>
            <polygon points="0,48 ${ptsF} 200,48" fill="url(#egF)"/><polyline points="${ptsF}" fill="none" stroke="${ecF}" stroke-width="1.5"/>
          </svg>
          <div style="display:flex;justify-content:space-between;font-size:10px;color:#475569;margin-top:6px">
            <span>$${STARTING.toLocaleString()}</span>
            <span style="color:${ecF};font-weight:700">$${equityFixed.at(-1).toLocaleString()}</span>
          </div>
          <div style="font-size:9px;color:#334155;margin-top:4px">Max DD: $${maxDDFixed.toFixed(0)} Â· Avg Win $${avgW.toFixed(0)} Â· Avg Loss $${avgL.toFixed(0)}</div>
        </div>

        <div class="card" style="padding:16px">
          <div style="display:flex;align-items:center;gap:8px;margin-bottom:8px">
            <div class="sl">COMPOUNDING</div>
            <span style="font-size:9px;padding:2px 6px;border-radius:3px;background:${ecC}22;color:${ecC};border:1px solid ${ecC}44">10% EQUITY / TRADE</span>
          </div>
          <svg width="100%" viewBox="0 0 200 48" preserveAspectRatio="none" style="height:90px;border-radius:4px">
            <defs><linearGradient id="egC" x1="0" y1="0" x2="0" y2="1"><stop offset="0%" stop-color="${ecC}" stop-opacity=".35"/><stop offset="100%" stop-color="${ecC}" stop-opacity="0"/></linearGradient></defs>
            <polygon points="0,48 ${ptsC} 200,48" fill="url(#egC)"/><polyline points="${ptsC}" fill="none" stroke="${ecC}" stroke-width="1.5"/>
          </svg>
          <div style="display:flex;justify-content:space-between;font-size:10px;color:#475569;margin-top:6px">
            <span>$${STARTING.toLocaleString()}</span>
            <span style="color:${ecC};font-weight:700">$${finalComp.toLocaleString()}</span>
          </div>
          <div style="font-size:9px;color:#334155;margin-top:4px">Max DD: $${maxDDComp.toFixed(0)} Â· Same trade sequence, dynamic sizing</div>
        </div>

      </div>
      <div style="padding:8px 12px;background:#080814;border-radius:5px;font-size:10px;color:#475569;line-height:1.8">
        ${CON.trad?`<span style="color:#f59e0b">â—</span> Option prices from Tradier sandbox`:`<span style="color:#334155">â—‹</span> Connect Tradier sandbox for real option pricing`}
        &nbsp;Â·&nbsp; Seed ${seedVal} â€” same params always return same results
        &nbsp;Â·&nbsp; ${contractNote}
      </div>`;
    btn.textContent='â–¶ RUN BACKTEST'; btn.disabled=false;
  },1400);
}

// â”€â”€ ORDERS
function stageOrder(id){selSig=sigs.find(s=>s.id===id);if(!selSig)return;showOrderForm();switchTab('orders');}
function showOrderForm(){
  const s=selSig,iC=s.type==='CALL',col=iC?'#10b981':'#ef4444';
  document.getElementById('orders-wrap').style.gridTemplateColumns='1fr 360px';
  const p=document.getElementById('order-form'); p.style.display='block';
  p.innerHTML=`<div class="card" style="padding:18px">
    <div class="sl" style="margin-bottom:12px">CONFIGURE ORDER</div>
    <div style="margin-bottom:12px;padding:10px;background:#080814;border-radius:6px;border-left:3px solid ${col}">
      <div style="font-size:13px;font-weight:700;color:${col};margin-bottom:2px">SPY ${s.type} $${s.strike} ${s.expiry}</div>
      <div style="font-size:11px;color:#475569">${s.rule}${s.isApex?` Â· APEX: +${P.APEX_TGT_PCT}% target / -${P.APEX_STOP_PCT}% stop`:''}</div>
    </div>
    ${[['Contracts','of-qty','1'],['Stop Loss (SPY $)','of-stop',s.stop.toFixed(2)],['Take Profit (SPY $)','of-tp',s.target.toFixed(2)]].map(([l,id,v])=>`<div style="margin-bottom:10px"><label style="font-size:10px;color:#64748b;display:block;margin-bottom:4px">${l}</label><input type="number" id="${id}" value="${v}" style="width:100%;padding:7px 10px;font-size:12px;border-radius:6px"/></div>`).join('')}
    <div style="margin-bottom:12px"><label style="font-size:10px;color:#64748b;display:block;margin-bottom:4px">Notes</label><textarea id="of-notes" rows="2" style="width:100%;padding:7px 10px;font-size:12px;resize:vertical;border-radius:6px">${s.rule} at $${s.price.toFixed(2)}</textarea></div>
    <div style="display:flex;gap:8px"><button class="btn-primary" onclick="confirmOrder()" style="flex:1;padding:9px;border-radius:6px;font-size:11px;letter-spacing:1px">âœ“ STAGE ORDER</button><button class="btn-ghost" onclick="cancelOrder()" style="padding:9px 12px;border-radius:6px;font-size:11px">CANCEL</button></div>
  </div>`;
}
function confirmOrder(){
  if(!selSig)return;
  orders=[{...selSig,qty:+document.getElementById('of-qty').value||1,stopLoss:+document.getElementById('of-stop').value,takeProfit:+document.getElementById('of-tp').value,notes:document.getElementById('of-notes').value,stagedAt:new Date().toLocaleTimeString()},...orders];
  selSig=null; cancelOrder(); renderOrders(); updateSBar();
}
function cancelOrder(){selSig=null;document.getElementById('order-form').style.display='none';document.getElementById('orders-wrap').style.gridTemplateColumns='1fr';}
function renderOrders(){
  const cnt=document.getElementById('cnt-orders');
  cnt.textContent=orders.length; cnt.style.background=orders.length?'#f59e0b22':'#1e293b'; cnt.style.color=orders.length?'#f59e0b':'#64748b';
  const el=document.getElementById('orders-list');
  if(!orders.length){el.innerHTML=`<div style="text-align:center;padding:60px;color:#334155"><div style="font-size:36px;margin-bottom:12px">ğŸ“‹</div><div>No staged orders</div></div>`;return;}
  el.innerHTML=orders.map(o=>{const iC=o.type==='CALL',col=iC?'#10b981':'#ef4444';return`<div class="card" style="padding:14px;margin-bottom:10px;border-left:3px solid ${col}">
    <div style="display:flex;justify-content:space-between;align-items:flex-start;margin-bottom:10px">
      <div><div style="display:flex;gap:8px;align-items:center;margin-bottom:3px"><span style="font-size:13px;font-weight:700;color:${col}">SPY ${o.type} $${o.strike} ${o.expiry}</span><span class="badge badge-${o.type.toLowerCase()}">${o.type}</span></div><div style="font-size:10px;color:#475569">${o.rule} Â· ${o.stagedAt}</div></div>
      <div style="text-align:right"><div style="font-size:9px;color:#475569;margin-bottom:2px">QTY</div><div style="font-size:18px;font-weight:700;color:#f1f5f9">${o.qty}</div></div>
    </div>
    <div class="g4" style="margin-bottom:10px">${[['ENTRY',`$${o.price.toFixed(2)}`,'#e2e8f0'],['TARGET',`$${o.takeProfit.toFixed(2)}`,'#10b981'],['STOP',`$${o.stopLoss.toFixed(2)}`,'#ef4444'],['CONF',`${o.conf}%`,'#f59e0b']].map(([l,v,c])=>`<div style="background:#080814;border-radius:5px;padding:7px 9px"><div style="font-size:9px;color:#475569;margin-bottom:3px">${l}</div><div style="font-size:12px;font-weight:600;color:${c}">${v}</div></div>`).join('')}</div>
    ${o.notes?`<div style="font-size:10px;color:#475569;font-style:italic;margin-bottom:10px;padding:7px;background:#080814;border-radius:4px">"${o.notes}"</div>`:''}
    <div style="background:#0a0a14;border:1px solid #1e293b;border-radius:5px;padding:10px;font-size:11px">
      <div style="color:#f59e0b;margin-bottom:5px;font-weight:700">ğŸ“± ENTER IN WEBULL:</div>
      <div style="color:#64748b;line-height:2">1. Search <b style="color:#e2e8f0">SPY</b> â†’ Options â†’ <b style="color:${col}">${o.expiry} $${o.strike} ${o.type}</b><br>2. Buy to Open Â· Limit Â· Qty: <b style="color:#e2e8f0">${o.qty}</b><br>3. Stop at <b style="color:#ef4444">$${o.stopLoss.toFixed(2)}</b> Â· Target <b style="color:#10b981">$${o.takeProfit.toFixed(2)}</b></div>
    </div>
  </div>`}).join('');
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  EVENING SUMMARY & APEX LOGGING
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
const LOGKEY='spyedge_apex_v2';
function todayKey(){return tradingDate();}
function loadLog(){try{return JSON.parse(localStorage.getItem(LOGKEY)||'{}')}catch{return{}}}
function saveLog(l){localStorage.setItem(LOGKEY,JSON.stringify(l));}
function ensureDay(l,d){if(!l[d])l[d]={fires:[],blockerLog:[]};return l;}

function logApexFire(apex){
  const l=loadLog(),d=todayKey(); ensureDay(l,d);
  if(l[d].fires.slice(-3).some(f=>f.type===apex.type&&Date.now()-f.firedAt<5*60*1000)) return;
  l[d].fires.push({
    id:apex.id, firedAt:Date.now(), time:apex.time,
    type:apex.type, conf:apex.conf,
    firePrice:apex.price,       // SPY price at moment of fire
    target:apex.target, stop:apex.stop,
    strike:apex.strike, expiry:apex.expiry,
    components:(apex.componentSigs||[]).map(s=>s===apex.componentSigs[0]?'Momentum':s===apex.componentSigs[1]?'Level':'Flow'),
    outcome:null, notes:'', tPct:P.APEX_TGT_PCT, sPct:P.APEX_STOP_PCT,
    // Price checkpoints at 5/10/15/30 min â€” {price, high, low, move}
    // high/low = max move in each direction from firePrice to that point
    chk5:null, chk10:null, chk15:null, chk30:null,
    runHigh:apex.price, runLow:apex.price,  // updated each refresh until 30m
  });
  saveLog(l); refreshBadge();
}

// Called every refresh â€” updates running high/low and snapshots at interval marks
function updatePriceCheckpoints(){
  if(!price) return;
  const l=loadLog(),d=todayKey(); if(!l[d]?.fires?.length) return;
  let changed=false;
  const now=Date.now();
  for(const f of l[d].fires){
    if(!f.firedAt||!f.firePrice) continue;
    const elapsed=(now-f.firedAt)/60000; // minutes since fire
    if(elapsed>31) continue; // done tracking
    // Update running high/low
    if(price>f.runHigh){f.runHigh=price;changed=true;}
    if(price<f.runLow){f.runLow=price;changed=true;}
    // Snapshot at each interval mark (once, when elapsed crosses threshold)
    const snap=(key,min)=>{
      if(!f[key]&&elapsed>=min){
        f[key]={
          price:+price.toFixed(2),
          high:+f.runHigh.toFixed(2),
          low:+f.runLow.toFixed(2),
          moveUp:+(f.runHigh-f.firePrice).toFixed(2),
          moveDown:+(f.firePrice-f.runLow).toFixed(2),
          min,
        };
        changed=true;
      }
    };
    snap('chk5',5);snap('chk10',10);snap('chk15',15);snap('chk30',30);
  }
  if(changed) saveLog(l);
}
function logBlockers(mom,lvl,flow){
  // v3.0 compat: accept either old args or skip - blockers now logged via v3 signals
  const v3=scoreSignals();
  const {gexField,trend,conviction}=v3;
  const dirs=['CALL','PUT'];
  for(const dir of dirs){
    const active=[gexField,trend,conviction].filter(s=>s.active&&s.direction===dir);
    if(active.length<1) continue;
    const score=active.length>=2?Math.min(...active.map(s=>s.score)):active[0].score;
    if(score<45) continue;
    const l=loadLog(),d=todayKey(); ensureDay(l,d);
    if(l[d].blockerLog.slice(-5).some(b=>b.direction===dir&&Date.now()-b.recordedAt<10*60*1000)) continue;
    const names=[gexField,trend,conviction].map((s,i)=>s.active&&s.direction===dir?['GEX','Trend','Conviction'][i]:'').filter(Boolean);
    const absent=['GEX','Trend','Conviction'].filter(n=>!names.includes(n));
    l[d].blockerLog.push({recordedAt:Date.now(),time:new Date().toLocaleTimeString('en-US',{hour:'2-digit',minute:'2-digit'}),direction:dir,score,presentRules:names,absentRules:absent});
    saveLog(l); break;
  }
}
function logOutcome(){
  const fid=+document.getElementById('out-sel').value, outcome=document.getElementById('out-outcome').value, notes=document.getElementById('out-notes').value.trim();
  if(!fid) return;
  const l=loadLog(),d=todayKey(); ensureDay(l,d);
  const fire=l[d].fires.find(f=>f.id===fid); if(!fire) return;
  fire.outcome=outcome; fire.notes=notes; fire.loggedAt=Date.now();
  saveLog(l); document.getElementById('out-notes').value=''; renderSummary();
}
function computeFP(fires){const c={};fires.filter(f=>f.outcome==='loss').forEach(f=>(f.components||[]).forEach(r=>{c[r]=(c[r]||0)+1}));return Object.entries(c).sort((a,z)=>z[1]-a[1]).map(([rule,count])=>({rule,count}));}
function computeBL(bl){const c={};bl.forEach(b=>(b.absentRules||[]).forEach(r=>{c[r]=(c[r]||0)+1}));return Object.entries(c).sort((a,z)=>z[1]-a[1]).map(([rule,count])=>({rule,count}));}
function refreshBadge(){
  const l=loadLog(),d=todayKey(),t=l[d]||{fires:[]};
  const open=t.fires.filter(f=>f.outcome===null).length;
  const b=document.getElementById('sum-badge'); b.textContent=open?`${open} open`:''; b.style.display=open?'inline':'none';
}
function clearToday(){if(!confirm('Clear today\'s APEX log?'))return;const l=loadLog(),d=todayKey();delete l[d];saveLog(l);renderSummary();}
function exportSummary(){const t=document.getElementById('sum-text')?.textContent||'';const a=Object.assign(document.createElement('a'),{href:URL.createObjectURL(new Blob([t],{type:'text/plain'})),download:`SPY_Edge_${todayKey()}.txt`});a.click();}

function renderSummary(){
  const l=loadLog(),d=todayKey(),day=l[d]||{fires:[],blockerLog:[]};
  const fires=day.fires||[],blocks=day.blockerLog||[];
  const total=fires.length,wins=fires.filter(f=>f.outcome==='win').length;
  const losses=fires.filter(f=>f.outcome==='loss').length,scratches=fires.filter(f=>f.outcome==='scratch').length;
  const open=fires.filter(f=>f.outcome===null).length;
  const wr=wins+losses>0?Math.round(wins/(wins+losses)*100):null;
  const pnl=fires.filter(f=>f.outcome!==null).reduce((acc,f)=>{
    if(f.outcome==='win') return acc+f.price*(f.tPct||20)/100*100;
    if(f.outcome==='loss') return acc-f.price*(f.sPct||15)/100*100;
    return acc;
  },0);

  document.getElementById('sum-kpis').innerHTML=[
    {l:'APEX FIRES',v:total,c:'#a855f7'},
    {l:'WIN RATE',v:wr!==null?`${wr}%`:'â€”',c:wr>=60?'#10b981':wr>=40?'#f59e0b':'#ef4444'},
    {l:'WINS',v:wins,c:'#10b981'},{l:'LOSSES',v:losses,c:'#ef4444'},
    {l:'OPEN',v:open,c:open?'#f59e0b':'#475569'},
    {l:'EST P&L',v:pnl?`$${pnl>0?'+':''}${pnl.toFixed(0)}`:'â€”',c:pnl>0?'#10b981':pnl<0?'#ef4444':'#475569'},
  ].map(k=>`<div class="card" style="padding:12px"><div class="sl" style="margin-bottom:5px">${k.l}</div><div style="font-size:20px;font-weight:700;color:${k.c}">${k.v}</div></div>`).join('');

  document.getElementById('sum-fire-cnt').textContent=`${total} fires today`;
  document.getElementById('sum-fires').innerHTML=!fires.length?`<div style="text-align:center;padding:30px;color:#334155;font-size:12px">No APEX fires today.</div>`
    :[...fires].reverse().map(f=>{
      const col=f.type==='CALL'?'#10b981':'#ef4444';
      const oc={win:'#10b981',loss:'#ef4444',scratch:'#f59e0b',null:'#475569'};
      const ol={win:'âœ… WIN',loss:'âŒ LOSS',scratch:'â¡ SCRATCH',null:'â³ OPEN'};
      const chkCell=(chk,label)=>{
        if(!chk) return `<div style="background:#0c0c1a;border-radius:4px;padding:5px;text-align:center"><div style="font-size:8px;color:#334155;letter-spacing:1px">${label}</div><div style="font-size:10px;color:#334155">â€”</div></div>`;
        const bullMove=f.type==='CALL'?chk.moveUp:chk.moveDown;
        const bearMove=f.type==='CALL'?chk.moveDown:chk.moveUp;
        const favCol=bullMove>0.20?'#10b981':'#475569';
        const advCol=bearMove>0.20?'#ef4444':'#475569';
        return `<div style="background:#0c0c1a;border-radius:4px;padding:5px;text-align:center">
          <div style="font-size:8px;color:#475569;letter-spacing:1px;margin-bottom:2px">${label}</div>
          <div style="font-size:10px;font-weight:700;color:#94a3b8">$${chk.price}</div>
          <div style="font-size:9px;color:${favCol}">+$${chk.moveUp.toFixed(2)}</div>
          <div style="font-size:9px;color:${advCol}">-$${chk.moveDown.toFixed(2)}</div>
        </div>`;
      };
      const now=Date.now();
      const elapsed=f.firedAt?(now-f.firedAt)/60000:99;
      const tracking=elapsed<31&&!f.chk30;
      return `<div style="padding:12px;border-radius:6px;border:1px solid #1e293b;margin-bottom:10px;background:#080814">
        <div style="display:flex;align-items:center;justify-content:space-between;margin-bottom:6px">
          <span style="font-size:12px;font-weight:700;color:${col}">${f.type==='CALL'?'â–²':'â–¼'} ${f.type} &nbsp;$${f.strike} ${f.expiry}</span>
          <span style="font-size:10px;color:${oc[f.outcome]||'#475569'};font-weight:700">${ol[f.outcome]||'â³ OPEN'}</span>
        </div>
        <div style="font-size:10px;color:#475569;margin-bottom:6px">${f.time} Â· Entry $${(f.firePrice||f.price||0).toFixed(2)} Â· Conf ${f.conf}% Â· Tgt $${f.target.toFixed(2)} Â· Stop $${f.stop.toFixed(2)}</div>
        <div style="font-size:9px;color:#334155;margin-bottom:8px">${(f.components||[]).join(' + ')}</div>
        <div style="display:grid;grid-template-columns:repeat(4,1fr);gap:4px;margin-bottom:4px">
          ${chkCell(f.chk5,'5 MIN')}${chkCell(f.chk10,'10 MIN')}${chkCell(f.chk15,'15 MIN')}${chkCell(f.chk30,'30 MIN')}
        </div>
        ${tracking?`<div style="font-size:9px;color:#334155;text-align:center;margin-top:4px">â— Tracking price ${Math.ceil(30-elapsed)}m remaining Â· +$X = max up Â· -$X = max down from entry</div>`:''}
        ${f.notes?`<div style="font-size:10px;color:#64748b;font-style:italic;margin-top:6px">"${f.notes}"</div>`:''}
      </div>`;
    }).join('');

  const fps=computeFP(fires),maxFP=fps[0]?.count||1;
  document.getElementById('sum-fp').innerHTML=!losses?`<div style="color:#475569;font-size:11px;padding:10px 0">No losses logged yet.</div>`
    :fps.map(fp=>`<div style="margin-bottom:8px"><div style="display:flex;justify-content:space-between;font-size:10px;margin-bottom:3px"><span style="color:#94a3b8">${fp.rule}</span><span style="color:#ef4444;font-weight:700">${fp.count}Ã— on losses</span></div><div style="height:6px;background:#1e293b;border-radius:3px;overflow:hidden"><div style="height:100%;width:${~~(fp.count/maxFP*100)}%;background:linear-gradient(90deg,#ef4444,#dc2626);border-radius:3px;transition:width .5s"></div></div></div>`).join('')||'<div style="color:#475569;font-size:11px">No patterns yet.</div>';
  document.getElementById('sum-fp-txt').textContent=!losses?'Log trade outcomes to see false positive analysis.':fps[0]?`"${fps[0].rule}" on ${fps[0].count}/${losses} losses (${~~(fps[0].count/losses*100)}%). Review or tighten in PARAMS.`:'No patterns yet.';

  const bls=computeBL(blocks),maxB=bls[0]?.count||1;
  document.getElementById('sum-bl').innerHTML=!blocks.length?`<div style="color:#475569;font-size:11px;padding:10px 0">No near-miss events yet.</div>`
    :bls.slice(0,6).map(b=>`<div style="margin-bottom:8px"><div style="display:flex;justify-content:space-between;font-size:10px;margin-bottom:3px"><span style="color:#94a3b8">${b.rule}</span><span style="color:#f59e0b;font-weight:700">${b.count}Ã— absent</span></div><div style="height:6px;background:#1e293b;border-radius:3px;overflow:hidden"><div style="height:100%;width:${~~(b.count/maxB*100)}%;background:linear-gradient(90deg,#f59e0b,#d97706);border-radius:3px;transition:width .5s"></div></div></div>`).join('')||'<div style="color:#475569;font-size:11px">No patterns yet.</div>';
  document.getElementById('sum-bl-txt').textContent=bls[0]?`"${bls[0].rule}" absent ${bls[0].count}Ã— â€” top APEX blocker. Consider APEX_MIN or relaxing its threshold.`:'No blocker patterns yet.';

  const openFires=fires.filter(f=>f.outcome===null);
  document.getElementById('out-sel').innerHTML=!openFires.length?'<option value="">No open APEX trades</option>':openFires.map(f=>`<option value="${f.id}">${f.time} ${f.type} $${f.strike} ${f.expiry} Â· ${f.conf}% conf</option>`).join('');
  document.getElementById('sum-date').textContent=new Date().toLocaleDateString('en-US',{weekday:'long',month:'long',day:'numeric',year:'numeric'});
  document.getElementById('sum-text').textContent=buildExec(d,fires,blocks,wins,losses,scratches,open,wr,pnl,fps,bls);
  refreshBadge();
}

function buildExec(date,fires,blocks,wins,losses,scratches,open,wr,pnl,fps,bls){
  const L='â”€'.repeat(62),now=new Date().toLocaleTimeString('en-US',{hour:'2-digit',minute:'2-digit'}),ln=[];
  ln.push('SPY EDGE  â˜… APEX EVENING SUMMARY');
  ln.push(`${date}  Â·  Generated ${now}  Â·  v1.7`);
  ln.push(L);
  ln.push('\nDATA SOURCES');
  ln.push(`  Price   : ${CON.poly?'Polygon Paid â€” 5s real-time':'Demo / mock'}`);
  ln.push(`  Flow    : ${CON.uw?`Unusual Whales â€” live ($${P.SWEEP_MIN_PREM/1000}K+ filter)`:'Mock flow'}`);
  ln.push(`  GEX     : ${gexDataValid?`Flow GEX live â€” flip $${P.GEX_FLIP} Â· call wall $${P.GEX_CWALL} Â· put wall $${P.GEX_PWALL}`:'Manual override â€” verify levels each session'}`);
  ln.push(`  Backtest: ${CON.trad?'Tradier real option chain':'Estimated'}`);
  ln.push(`  Push    : ${CON.push?'Pushover active â€” APEX fires sent':'Not configured'}`);
  ln.push(`  GEX now : Flip $${P.GEX_FLIP} Â· Call Wall $${P.GEX_CWALL} Â· Put Wall $${P.GEX_PWALL}`);
  ln.push(`\nPERFORMANCE  (+${P.APEX_TGT_PCT}% target / -${P.APEX_STOP_PCT}% stop on option)`);
  ln.push(`  APEX fires today   : ${fires.length}`);
  ln.push(`  Wins               : ${wins}`);
  ln.push(`  Losses             : ${losses}`);
  ln.push(`  Scratches          : ${scratches}`);
  ln.push(`  Unlogged / open    : ${open}`);
  ln.push(`  Win rate           : ${wr!==null?wr+'%':'N/A â€” log outcomes first'}`);
  ln.push(`  Est. net P&L       : ${pnl?'$'+(pnl>0?'+':'')+pnl.toFixed(0):'N/A'}`);
  if(fires.length){
    ln.push('\nAPEX FIRES DETAIL');
    fires.forEach((f,i)=>{
      const omap={win:'WIN âœ…',loss:'LOSS âŒ',scratch:'SCRATCH â¡',null:'OPEN â³'};
      ln.push(`  ${i+1}. ${f.time}  ${f.type}  $${f.strike} ${f.expiry}  Entry $${(f.firePrice||f.price||0).toFixed(2)}  Conf ${f.conf}%  â†’  ${omap[f.outcome]||'OPEN â³'}`);
      if(f.chk5||f.chk10||f.chk15||f.chk30){
        const fmt=(chk,label)=>chk?`${label}: $${chk.price} (+$${chk.moveUp.toFixed(2)} / -$${chk.moveDown.toFixed(2)})`:`${label}: pending`;
        ln.push(`     ${fmt(f.chk5,'5m')} Â· ${fmt(f.chk10,'10m')} Â· ${fmt(f.chk15,'15m')} Â· ${fmt(f.chk30,'30m')}`);
      }
      ln.push(`     ${(f.components||[]).join(' + ')}`);
      if(f.notes) ln.push(`     Note: "${f.notes}"`);
    });
  }
  ln.push('\nFALSE POSITIVE ANALYSIS  (signals on losing trades)');
  if(!losses) ln.push('  No losses logged today.');
  else if(!fps.length) ln.push('  Insufficient data.');
  else{fps.forEach(fp=>ln.push(`  ${fp.rule.padEnd(34)} ${fp.count}Ã— on losses  (${~~(fp.count/losses*100)}%)`));ln.push(`\n  âš  Top offender: "${fps[0].rule}"`);ln.push(`    Present on ${fps[0].count}/${losses} losses â†’ review threshold in PARAMS.`);}
  ln.push('\nAPEX BLOCKERS  (rules that prevented APEX from firing)');
  if(!blocks.length) ln.push('  No near-miss events recorded today.');
  else{ln.push(`  Near-miss events: ${blocks.length}`);bls.slice(0,5).forEach(b=>ln.push(`  ${b.rule.padEnd(34)} absent ${b.count}Ã—`));if(bls[0]){ln.push(`\n  âš  Top blocker: "${bls[0].rule}"`);ln.push(`    Absent ${bls[0].count}Ã— â†’ lower APEX_MIN or relax threshold.`);}}
  ln.push('\nREFINEMENT NOTES');
  if(wr>=65) ln.push(`  âœ… Win rate ${wr}% strong. Raise APEX_CONF above ${P.APEX_CONF} to filter edge cases.`);
  else if(wr!==null&&wr<50){ln.push(`  âš  Win rate ${wr}% below 50%. Priority actions:`);if(fps[0])ln.push(`     â€¢ Tighten "${fps[0].rule}" â€” highest false positive rate`);if(bls[0])ln.push(`     â€¢ Review "${bls[0].rule}" â€” may be blocking valid setups`);ln.push(`     â€¢ Raise APEX_CONF above ${P.APEX_CONF}`);}
  else if(wr!==null) ln.push(`  ğŸ“Š Win rate ${wr}% acceptable. Continue logging to build sample size.`);
  else ln.push('  ğŸ“Š Log trade outcomes after close to enable analysis.');
  ln.push(`\n${L}`);
  ln.push('SPY Edge v1.7  Â·  Not financial advice  Â·  Model refinement tool only');
  return ln.join('\n');
}

// â”€â”€ SETTINGS MODAL
function openSettings(){
  document.getElementById('settings-modal').style.display='flex';
  document.getElementById('settings-body').innerHTML=`
    <div style="margin-bottom:18px">
      <div class="sl" style="margin-bottom:10px">API CONNECTION STATUS</div>
      ${[{l:'Polygon.io (Price)',ok:CON.poly,c:'#10b981'},{l:'Unusual Whales (Flow)',ok:CON.uw,c:'#06b6d4'},{l:'Flow GEX (auto Â· from UW)',ok:CON.uw&&gexDataValid,lbl:CON.uw?(gexDataValid?'â— COMPUTED':'â—Œ BUILDING'):'â—‹ NEEDS UW',c:'#10b981'},{l:'Tradier (Options Chain)',ok:CON.trad,c:'#f59e0b'},{l:'Delta Stream (Polygon WS)',ok:CON.stream,lbl:CON.stream?`â— LIVE Â· ${deltaTicks.length} ticks`:'â—‹ Connecting...',c:'#a78bfa'},{l:'Pushover (Push Notifications)',ok:CON.push,c:'#fb923c'}]
        .map(a=>`<div style="display:flex;align-items:center;justify-content:space-between;margin-bottom:8px;font-size:12px"><span style="color:#94a3b8">${a.l}</span><span style="color:${a.ok?a.c:a.lbl?'#f59e0b':'#334155'};font-weight:700">${a.lbl||(a.ok?'â— CONNECTED':'â—‹ NOT CONNECTED')}</span></div>`).join('')}
    </div>
    <div style="border-top:1px solid #1e293b;padding-top:16px;margin-bottom:16px">
      <div class="sl" style="margin-bottom:10px">PUSH NOTIFICATION TEST</div>
      <div style="font-size:11px;color:#475569;margin-bottom:10px">Send a test notification to confirm Pushover is working.</div>
      <button class="btn-ghost" onclick="sendSMS('SPY Edge v1.7 test â€” Pushover connected âœ“').then(ok=>alert(ok?'Sent âœ“':'Failed â€” check keys'))" style="padding:8px 16px;border-radius:6px;font-size:11px">SEND TEST NOTIFICATION</button>
    </div>
    <div style="border-top:1px solid #1e293b;padding-top:16px;margin-bottom:16px">
      <div class="sl" style="margin-bottom:10px">SIGNAL PARAMS</div>
      <div style="font-size:11px;color:#475569;line-height:2.2">
        APEX thresholds: <b style="color:#f59e0b">Trending ${P.APEX_CONF_TRENDING} Â· Mixed ${P.APEX_CONF_MIXED} Â· Range ${P.APEX_CONF_RANGE}</b><br>
        Boosters: Momentum 0â€“${P.APEX_MOM_MAX} Â· Flow 0â€“${P.APEX_FLOW_MAX} Â· Velocity âˆ’15â€“${P.APEX_VEL_MAX} Â· Path âˆ’20â€“${P.APEX_PATH_MAX}<br>
        Velocity: AM prime 10â€“11am Â· PM window 2â€“2:45pm Â· vol mult ${P.VEL_VOL_MULT}Ã—<br>
        GEX Gate: major sig ${P.GEX_MAJOR_SIG}+ Â· approach $${P.GEX_APPROACH} Â· at-level $${P.GEX_AT_LEVEL}<br>
        Continuation: major ahead $${P.GEX_CONT_MAJOR_AHEAD} Â· maj from mod $${P.GEX_CONT_MAJ_FROM_MOD}<br>
        Flow: min $${(P.FLOW_SWEEP_MIN/1000).toFixed(0)}K Â· ratio ${P.FLOW_MOM_THRESH*100}% Â· DEX strike band ${P.DEX_STRIKE_PCT*100}%<br>
        Grab filter: body thresh ${P.GRAB_BODY_THRESH*100}% Â· invalidate $${P.GRAB_INVALIDATE} Â· vol ratio ${P.GRAB_VOL_RATIO*100}%
      </div>
    </div>
    <div style="border-top:1px solid #1e293b;padding-top:16px">
      <div class="sl" style="margin-bottom:10px">REFRESH RATES</div>
      <div style="font-size:11px;color:#475569;line-height:2">Price: every ${P.LIVE_MS/1000}s Â· Flow: every ${P.FLOW_MS/1000}s Â· GEX: recomputed on each flow refresh (auto)</div>
    </div>
    <div style="border-top:1px solid #1e293b;padding-top:16px;margin-top:4px">
      <div class="sl" style="margin-bottom:10px">SESSION</div>
      <button onclick="closeSettings();disconnect();" style="width:100%;padding:10px;border-radius:6px;font-size:12px;font-weight:700;letter-spacing:1px;background:#1e293b;border:1px solid #ef444444;color:#ef4444;cursor:pointer">â‹ DISCONNECT &amp; RESET KEYS</button>
      <div style="font-size:10px;color:#334155;margin-top:6px;text-align:center">Clears all saved API keys â€” you'll re-enter them on next launch</div>
    </div>`;
}
function closeSettings(){document.getElementById('settings-modal').style.display='none';}

// â”€â”€ TAB SWITCHING
function switchTab(name){
  ['signals','flow','gex','backtest','orders','summary'].forEach(t=>{
    document.getElementById(`pane-${t}`).style.display=t===name?'block':'none';
    document.getElementById(`tab-${t}`).classList.toggle('active',t===name);
  });
  tab=name;
  if(name==='gex') renderGEX();
  if(name==='orders') renderOrders();
  if(name==='summary') renderSummary();
}

// â”€â”€ RULE TOGGLES
function toggleRule(key){
  rules[key]=!rules[key];
  const t=document.getElementById(`tog-${key}`),th=t.querySelector('.tog-thumb'),lbl=document.getElementById(`tlbl-${key}`);
  t.style.background=rules[key]?'#10b981':'#1e293b'; th.style.left=rules[key]?'18px':'2px'; lbl.style.color=rules[key]?'#e2e8f0':'#475569';
}

// â”€â”€ INIT
window.addEventListener('keydown',e=>{if(e.key==='Enter'&&document.getElementById('setup-screen').style.display!=='none')connectAll();});
(async()=>{
  const saved=localStorage.getItem('sek');
  if(saved){
    try{K=JSON.parse(saved);}catch{}
    if(K.poly){
      ['poly','uw','trad','cfworker','ptoken','puser'].forEach(k=>{
        const el=document.getElementById(`k-${k}`);
        if(el&&K[k==='cfworker'?'cfWorker':k]) el.value=K[k==='cfworker'?'cfWorker':k];
      });
      await fetchPolygon().catch(()=>{});
      await Promise.all([fetchUW(),fetchDarkPool()]).catch(()=>{});
      if(K.trad){try{await tradierChain(tradingDate());CON.trad=true;}catch{}}
      if(K.trad&&K.cfWorker) await initTradierStream();
      if(K.ptoken&&K.puser) CON.push=true;
      CON.poly=true;
      resetGEXState(); prevPosGEX=null; gexFlipEvents=[];
      launchApp();
      return;
    }
  }
  renderFlow(); refreshBadge();
})();
</script>
</body>
</html>
