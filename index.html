<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1.0"/>
<title>SPY Edge v1.7</title>
<style>
@import url('https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@300;400;500;600;700&display=swap');
*,*::before,*::after{box-sizing:border-box;margin:0;padding:0}
body{font-family:'JetBrains Mono','Courier New',monospace;background:#09090f;color:#e2e8f0;min-height:100vh}
::-webkit-scrollbar{width:4px;height:4px}
::-webkit-scrollbar-track{background:#0f0f1a}
::-webkit-scrollbar-thumb{background:#334155;border-radius:2px}
input,select,textarea{font-family:inherit;background:#0f172a;border:1px solid #1e293b;color:#e2e8f0;border-radius:6px}
input:focus,select:focus,textarea:focus{outline:1px solid #10b981;border-color:#10b981}
button{font-family:inherit;cursor:pointer}
.btn-primary{background:#10b981;color:#000;font-weight:700;border:none;transition:all .15s}
.btn-primary:hover{background:#059669;transform:translateY(-1px)}
.btn-primary:disabled{opacity:.5;cursor:not-allowed;transform:none}
.btn-ghost{background:transparent;border:1px solid #334155;color:#94a3b8;transition:all .15s}
.btn-ghost:hover{border-color:#10b981;color:#10b981}
.btn-danger{background:transparent;border:1px solid #ef444433;color:#ef4444;transition:all .15s}
.btn-danger:hover{background:#ef444415}
.pulse{animation:pulse 2s infinite}
@keyframes pulse{0%,100%{opacity:1}50%{opacity:.4}}
.sig-card{cursor:pointer;transition:background .15s}
.sig-card:hover{background:#0f1929!important}
.flow-row:hover{background:#0f1520!important}
.tab-btn{background:none;border:none;border-bottom:2px solid transparent;color:#64748b;padding:11px 14px;font-size:11px;font-family:inherit;letter-spacing:1px;cursor:pointer;display:flex;align-items:center;gap:6px;white-space:nowrap}
.tab-btn:hover{color:#94a3b8}
.tab-btn.active{border-bottom-color:#10b981;color:#10b981}
.badge{font-size:10px;padding:2px 7px;border-radius:4px;border:1px solid;font-weight:700;display:inline-block}
.badge-call,.badge-bull,.badge-bullish{background:rgba(16,185,129,.15);color:#6ee7b7;border-color:rgba(16,185,129,.3)}
.badge-put,.badge-bear,.badge-bearish{background:rgba(239,68,68,.15);color:#fca5a5;border-color:rgba(239,68,68,.3)}
.badge-sweep{background:rgba(245,158,11,.15);color:#fcd34d;border-color:rgba(245,158,11,.3)}
.ftag{font-size:9px;padding:2px 6px;border-radius:3px;background:#0f172a;border:1px solid #1e293b;color:#475569;letter-spacing:.5px;display:inline-block;margin:2px 2px 0 0}
#setup-screen{display:flex;align-items:flex-start;justify-content:center;min-height:100vh;padding:30px 20px;overflow-y:auto}
#app{display:none;flex-direction:column;min-height:100vh}
.card{background:#0c0c1a;border:1px solid #1e293b;border-radius:8px}
.sl{font-size:11px;color:#475569;letter-spacing:2px}
.tog{width:36px;height:20px;border-radius:10px;position:relative;cursor:pointer;transition:background .2s;display:inline-block;flex-shrink:0}
.tog-thumb{position:absolute;top:2px;width:16px;height:16px;border-radius:50%;background:#fff;transition:left .2s}
.g2{display:grid;grid-template-columns:1fr 1fr;gap:16px}
.g3{display:grid;grid-template-columns:1fr 1fr 1fr;gap:16px}
.g4{display:grid;grid-template-columns:repeat(4,1fr);gap:12px}
.g6{display:grid;grid-template-columns:repeat(6,1fr);gap:12px}
.gsb{display:grid;grid-template-columns:300px 1fr;gap:20px}
.api-dot{width:7px;height:7px;border-radius:50%;display:inline-block}
</style>
</head>
<body>

<!-- â•â•â•â•â•â• SETUP â•â•â•â•â•â• -->
<div id="setup-screen">
<div style="width:620px;max-width:100%">
<div class="card" style="padding:36px">
  <div style="font-size:11px;color:#10b981;letter-spacing:3px;margin-bottom:4px;font-weight:700">â—ˆ SPY EDGE v1.6</div>
  <div style="font-size:20px;font-weight:700;color:#f1f5f9;margin-bottom:4px">Connect Your Data Sources</div>
  <div style="font-size:11px;color:#475569;margin-bottom:26px;line-height:1.7">Keys are saved in this browser and auto-fill next session â€” no re-entry needed. Only Polygon is required; everything else unlocks progressively more accurate signals.</div>

  <div style="margin-bottom:16px">
    <div style="display:flex;justify-content:space-between;margin-bottom:5px">
      <label style="font-size:11px;font-weight:700;color:#10b981">POLYGON.IO â€” Real-Time Price <span style="color:#ef4444;font-size:10px">â˜… Required</span></label>
      <a href="https://polygon.io" target="_blank" style="font-size:10px;color:#06b6d4;text-decoration:none">polygon.io â†’</a>
    </div>
    <input id="k-poly" type="password" placeholder="Polygon paid-tier API key" style="width:100%;padding:9px 12px;font-size:12px"/>
    <div style="font-size:10px;color:#334155;margin-top:3px">Paid tier enables 5-second real-time refresh. Free tier falls back to 15s.</div>
  </div>

  <div style="margin-bottom:16px">
    <div style="display:flex;justify-content:space-between;margin-bottom:5px">
      <label style="font-size:11px;font-weight:700;color:#06b6d4">UNUSUAL WHALES â€” Live Options Flow <span style="color:#f59e0b;font-size:10px">â˜… Strongly recommended</span></label>
      <a href="https://unusualwhales.com" target="_blank" style="font-size:10px;color:#06b6d4;text-decoration:none">unusualwhales.com â†’</a>
    </div>
    <input id="k-uw" type="password" placeholder="Unusual Whales API key (blank = mock flow)" style="width:100%;padding:9px 12px;font-size:12px"/>
    <div style="font-size:10px;color:#334155;margin-top:3px">Filters to $500K+ prints only â€” block-level flow that actually moves the signal.</div>
  </div>

  <div style="margin-bottom:16px;padding:10px 12px;background:#0c2818;border:1px solid #10b98144;border-radius:6px">
    <div style="display:flex;align-items:center;gap:8px;margin-bottom:4px">
      <span style="font-size:11px;font-weight:700;color:#10b981">FLOW GEX â€” Auto-computed from live options flow</span>
      <span style="font-size:10px;color:#10b981;background:#10b98122;padding:1px 6px;border-radius:3px">â˜… No extra key needed</span>
    </div>
    <div style="font-size:10px;color:#94a3b8;line-height:1.6">Call wall, put wall &amp; flip level are computed directly from UW options flow â€” 7 DTE or less, strikes within 3% of price, $250K+ prints only. Updates every time flow refreshes. Manual override available in the GEX tab.</div>
  </div>

  <div style="margin-bottom:16px">
    <div style="display:flex;justify-content:space-between;margin-bottom:5px">
      <label style="font-size:11px;font-weight:700;color:#f59e0b">TRADIER â€” Real Options Chain + Live Delta Stream <span style="color:#475569;font-size:10px">Optional Â· Production key</span></label>
      <a href="https://developer.tradier.com" target="_blank" style="font-size:10px;color:#06b6d4;text-decoration:none">developer.tradier.com â†’</a>
    </div>
    <input id="k-trad" type="password" placeholder="Tradier production API key" style="width:100%;padding:9px 12px;font-size:12px;margin-bottom:6px"/>
    <input id="k-cfworker" type="text" placeholder="Cloudflare Worker URL (e.g. https://spy-edge-tradier-proxy.xxx.workers.dev)" style="width:100%;padding:9px 12px;font-size:12px"/>
    <div style="font-size:10px;color:#334155;margin-top:3px">Worker URL enables live tick-level cumulative delta stream. Real option chain used for backtest P&L.</div>
  </div>

  <div style="margin-bottom:22px">
    <div style="display:flex;justify-content:space-between;margin-bottom:5px">
      <label style="font-size:11px;font-weight:700;color:#fb923c">PUSHOVER â€” Push Notifications <span style="color:#475569;font-size:10px">Optional Â· $5 one-time</span></label>
      <a href="https://pushover.net" target="_blank" style="font-size:10px;color:#06b6d4;text-decoration:none">pushover.net â†’</a>
    </div>
    <div style="display:grid;grid-template-columns:1fr 1fr;gap:8px">
      <input id="k-ptoken" type="password" placeholder="App API Token" style="padding:9px 12px;font-size:12px"/>
      <input id="k-puser"  type="password" placeholder="User Key"      style="padding:9px 12px;font-size:12px"/>
    </div>
    <div style="font-size:10px;color:#334155;margin-top:3px">Push notification when: APEX fires Â· You hit ğŸ“± AM BRIEF button each morning.</div>
  </div>

  <div id="setup-err" style="display:none;font-size:11px;color:#ef4444;margin-bottom:12px;padding:9px 12px;background:#1a0a0a;border:1px solid #ef444433;border-radius:6px"></div>
  <button id="connect-btn" class="btn-primary" onclick="connectAll()" style="width:100%;padding:13px;border-radius:7px;font-size:13px;letter-spacing:1px">CONNECT &amp; LAUNCH â†’</button>
  <div style="text-align:center;font-size:10px;color:#334155;margin-top:10px">Keys saved in this browser â€” auto-fill next time. Clear with Disconnect button.</div>
</div>
</div>
</div>

<!-- â•â•â•â•â•â• APP â•â•â•â•â•â• -->
<div id="app">

  <!-- HEADER -->
  <div style="background:#0a0a14;border-bottom:1px solid #1e293b;padding:10px 20px;display:flex;align-items:center;justify-content:space-between;flex-shrink:0">
    <div style="display:flex;align-items:center;gap:13px">
      <span style="font-size:11px;color:#10b981;letter-spacing:3px;font-weight:700">â—ˆ SPY EDGE v1.6</span>
      <span style="width:1px;height:20px;background:#1e293b;display:inline-block"></span>
      <span id="hdr-price" style="font-size:22px;font-weight:700;color:#f1f5f9;letter-spacing:-1px">$â€”â€”â€”</span>
      <span id="hdr-change" style="font-size:12px;color:#10b981"></span>
      <div id="hdr-ohlv" style="font-size:10px;color:#334155;display:flex;gap:10px"></div>
      <span id="data-badge" style="font-size:9px;padding:2px 8px;border-radius:3px;font-weight:700;letter-spacing:1px;background:#f59e0b22;border:1px solid #f59e0b55;color:#f59e0b">â—Œ DEMO</span>
      <div id="api-dots" style="display:flex;gap:8px;font-size:10px"></div>
    </div>
    <div style="display:flex;align-items:center;gap:8px">
      <span id="hdr-time" style="font-size:10px;color:#334155"></span>
      <div id="hdr-err" style="display:none;font-size:10px;color:#ef4444;max-width:200px;overflow:hidden;text-overflow:ellipsis;white-space:nowrap"></div>
      <button class="btn-ghost" onclick="sendAMBrief()" style="font-size:11px;padding:5px 11px;border-radius:4px" title="Send pre-market push notification">ğŸ“± AM BRIEF</button>
      <button class="btn-ghost" onclick="openSettings()" style="font-size:11px;padding:5px 11px;border-radius:4px">âš™</button>
      <button class="btn-ghost" id="live-btn" onclick="toggleLive()" style="font-size:11px;padding:5px 12px;border-radius:4px;display:flex;align-items:center;gap:6px">
        <span id="live-dot" style="width:6px;height:6px;border-radius:50%;background:#475569;display:inline-block"></span>
        <span id="live-lbl">PAUSED</span>
      </button>
      <button class="btn-ghost" onclick="refresh()" style="font-size:11px;padding:5px 10px;border-radius:4px">â†»</button>
      <button class="btn-ghost" onclick="disconnect()" style="font-size:11px;padding:5px 10px;border-radius:4px;color:#334155" title="Disconnect">â‹</button>
    </div>
  </div>

  <!-- STATUS BAR -->
  <div style="background:#070710;border-bottom:1px solid #1a1a2e;padding:6px 20px;display:flex;gap:16px;font-size:11px;flex-shrink:0;overflow-x:auto;align-items:center">
    <span style="color:#475569">GEX</span><span id="sb-regime" style="font-weight:700">â€”</span><span id="sb-flip" style="color:#334155;font-size:10px"></span>
    <span style="color:#1e293b">â”‚</span>
    <span style="color:#475569">8E</span><span id="sb-e8" style="color:#06b6d4">â€”</span>
    <span style="color:#475569">21E</span><span id="sb-e21" style="color:#a78bfa">â€”</span>
    <span style="color:#475569">VWAP</span><span id="sb-vwap" style="color:#64748b">â€”</span>
    <span style="color:#1e293b">â”‚</span>
    <span style="color:#475569">FLOW</span><span id="sb-bias">â€”</span>
    <span style="color:#475569">CALLS</span><span id="sb-calls" style="color:#10b981">â€”</span>
    <span style="color:#475569">PUTS</span><span id="sb-puts" style="color:#ef4444">â€”</span>
    <span style="color:#1e293b">â”‚</span>
    <span style="color:#475569">VIX</span><span id="sb-vix" style="color:#f59e0b">â€”</span>
    <span style="color:#475569">STAGED</span><span id="sb-staged" style="color:#475569;font-weight:700">0</span>
    <span style="color:#1e293b">â”‚</span>
    <span id="sb-apex" style="font-size:10px;color:#334155">APEX: awaiting scan</span>
  </div>

  <!-- TABS -->
  <div style="border-bottom:1px solid #1e293b;display:flex;padding:0 20px;flex-shrink:0;overflow-x:auto">
    <button class="tab-btn active" id="tab-signals"  onclick="switchTab('signals')">âš¡ SIGNALS <span id="cnt-signals" style="background:#10b981;color:#000;border-radius:10px;padding:1px 6px;font-size:10px;font-weight:700;display:none"></span></button>
    <button class="tab-btn"        id="tab-flow"     onclick="switchTab('flow')">ğŸŒŠ FLOW</button>
    <button class="tab-btn"        id="tab-gex"      onclick="switchTab('gex')">âš™ GEX</button>
    <button class="tab-btn"        id="tab-backtest" onclick="switchTab('backtest')">ğŸ“Š BACKTEST</button>
    <button class="tab-btn"        id="tab-orders"   onclick="switchTab('orders')">ğŸ“‹ ORDERS <span id="cnt-orders" style="background:#1e293b;color:#64748b;border-radius:10px;padding:1px 6px;font-size:10px;font-weight:700">0</span></button>
    <button class="tab-btn"        id="tab-summary"  onclick="switchTab('summary')">ğŸ“ˆ EVENING SUMMARY <span id="sum-badge" style="display:none;background:#a855f733;color:#a855f7;border:1px solid #a855f755;border-radius:10px;padding:1px 6px;font-size:10px;font-weight:700"></span></button>
  </div>

  <!-- CONTENT -->
  <div style="padding:20px;flex:1;overflow-y:auto">

    <!-- SIGNALS -->
      <div id="pane-signals">
      <div class="card" style="padding:12px 16px;margin-bottom:14px;display:flex;align-items:center;justify-content:space-between;gap:16px;flex-wrap:wrap">
        <div style="display:flex;align-items:center;gap:14px;flex-wrap:wrap">
          <span class="sl">APEX ENGINE</span>
          <span style="font-size:10px;color:#334155">GEX Gate (required) Â· Momentum booster (0â€“40) Â· Flow booster (0â€“40) Â· Threshold 100+</span>
          <span style="font-size:10px;color:#475569">Blackout: 9:30â€“10am Â· 3:30â€“4pm ET</span>
        </div>
        <button class="btn-primary" onclick="refresh()" style="padding:6px 16px;border-radius:6px;font-size:11px;letter-spacing:1px">SCAN NOW</button>
      </div>
      <div id="signals-list"><div style="text-align:center;padding:60px;color:#334155"><div style="font-size:36px;margin-bottom:12px">â—ˆ</div><div>Click SCAN NOW or enable LIVE</div></div></div>
    </div>

    <!-- FLOW -->
    <div id="pane-flow" style="display:none">
      <div style="display:flex;align-items:center;justify-content:space-between;margin-bottom:14px">
        <div style="display:flex;align-items:center;gap:10px">
          <div class="sl">OPTIONS FLOW</div>
          <span id="flow-src" style="font-size:9px;padding:2px 8px;border-radius:3px;background:#1e293b;color:#64748b;border:1px solid #334155">MOCK DATA</span>
        </div>
        <span id="flow-updated" style="font-size:10px;color:#334155"></span>
      </div>
      <div class="g4" style="margin-bottom:14px" id="flow-metrics"></div>
      <div class="card" style="overflow:hidden">
        <div style="display:grid;grid-template-columns:70px 55px 65px 60px 100px 65px 90px 75px;padding:9px 16px;border-bottom:1px solid #1e293b;font-size:10px;color:#475569;letter-spacing:1px">
          <span>TIME</span><span>TYPE</span><span>STRIKE</span><span>EXP</span><span>PREMIUM</span><span>SIZE</span><span>SENTIMENT</span><span>SWEEP</span>
        </div>
        <div id="flow-rows"></div>
      </div>
    </div>

    <!-- GEX -->
    <div id="pane-gex" style="display:none">
      <div style="display:flex;align-items:center;justify-content:space-between;margin-bottom:14px;flex-wrap:wrap;gap:10px">
        <div style="display:flex;align-items:center;gap:10px">
          <div class="sl">GAMMA EXPOSURE</div>
          <span id="gex-src" style="font-size:9px;padding:2px 8px;border-radius:3px;background:#1e293b;color:#64748b;border:1px solid #334155">MANUAL</span>
          <span id="gex-next" style="font-size:10px;color:#334155"></span>
          <button class="btn-ghost" onclick="fetchUWGex(true).then(()=>renderGEX())" style="font-size:9px;padding:2px 8px;border-radius:3px;letter-spacing:1px">â†» RETRY</button>
        </div>
        <div style="display:flex;gap:8px;align-items:center">
          <span style="font-size:10px;color:#475569">Manual:</span>
          <input id="gex-flip-in"  type="number" placeholder="Flip"      style="width:76px;padding:5px 8px;font-size:11px" value="684"/>
          <input id="gex-cwall-in" type="number" placeholder="Call wall" style="width:76px;padding:5px 8px;font-size:11px" value="700"/>
          <input id="gex-pwall-in" type="number" placeholder="Put wall"  style="width:76px;padding:5px 8px;font-size:11px" value="670"/>
          <button class="btn-ghost" onclick="applyManualGEX()" style="font-size:11px;padding:5px 12px;border-radius:4px">APPLY</button>
        </div>
      </div>
      <div class="g2">
        <div class="card" style="padding:20px">
          <div class="sl" style="margin-bottom:12px">KEY LEVELS &nbsp;Â·&nbsp; SPY <span id="gex-price" style="color:#f1f5f9;font-weight:700">â€”</span></div>
          <div id="gex-levels"></div>
        </div>
        <div style="display:flex;flex-direction:column;gap:12px">
          <div class="card" style="padding:18px">
            <div class="sl" style="margin-bottom:8px">GEX REGIME</div>
            <div id="gex-regime" style="font-size:24px;font-weight:700;margin-bottom:6px;color:#10b981">â€”</div>
            <div id="gex-desc" style="font-size:11px;color:#64748b;line-height:1.7"></div>
          </div>
          <div class="card" style="padding:18px">
            <div class="sl" style="margin-bottom:10px">KEY DISTANCES</div>
            <div id="gex-dist"></div>
          </div>
          <div class="card" style="padding:18px;margin-top:14px">
            <div id="dp-levels"><div style="font-size:11px;color:#475569;padding:4px 0">Dark pool levels load on connect.</div></div>
          </div>
        </div>
      </div>
    </div>

    <!-- BACKTEST -->
    <div id="pane-backtest" style="display:none">
      <div class="gsb">
        <div class="card" style="padding:20px;height:fit-content">
          <div class="sl" style="margin-bottom:14px">BACKTEST CONFIG</div>
          <div style="margin-bottom:10px"><label style="font-size:10px;color:#64748b;display:block;margin-bottom:4px">Start Date</label><input type="date" id="bt-start" value="2026-01-01" style="width:100%;padding:8px 10px;font-size:12px"/></div>
          <div style="margin-bottom:10px"><label style="font-size:10px;color:#64748b;display:block;margin-bottom:4px">End Date</label><input type="date" id="bt-end" value="2026-02-21" style="width:100%;padding:8px 10px;font-size:12px"/></div>
          <div style="margin-bottom:10px"><label style="font-size:10px;color:#64748b;display:block;margin-bottom:4px">Min Confidence %</label><input type="number" id="bt-conf" value="82" style="width:100%;padding:8px 10px;font-size:12px"/></div>
          <div style="margin-bottom:10px"><label style="font-size:10px;color:#64748b;display:block;margin-bottom:4px">Target % on option</label><input type="number" id="bt-tpct" value="20" style="width:100%;padding:8px 10px;font-size:12px"/></div>
          <div style="margin-bottom:16px"><label style="font-size:10px;color:#64748b;display:block;margin-bottom:4px">Stop % on option</label><input type="number" id="bt-spct" value="15" style="width:100%;padding:8px 10px;font-size:12px"/></div>
          <div style="padding:12px;background:#080814;border-radius:8px;border:1px solid #1e293b;margin-bottom:14px">
            <div style="display:flex;align-items:center;justify-content:space-between;margin-bottom:6px">
              <span style="font-size:12px;color:#f1f5f9;font-weight:600">â˜… APEX Only Mode</span>
              <div class="tog" id="tog-apex-bt" onclick="toggleApexBT()" style="background:#1e293b"><div class="tog-thumb" style="left:2px"></div></div>
            </div>
            <div style="font-size:10px;color:#475569;line-height:1.6">ON = only simulate trades where ALL rules align.<br>OFF = all individually active rules.</div>
          </div>
          <div id="tradier-note" style="display:none;padding:8px;background:#0a1000;border:1px solid #f59e0b33;border-radius:6px;font-size:10px;color:#f59e0b;margin-bottom:12px">â— Tradier connected â€” real option chain P&L active</div>
          <div style="margin-bottom:14px"><div class="sl" style="margin-bottom:8px">Active Rules</div><div id="bt-checks"></div></div>
          <button class="btn-primary" onclick="runBacktest()" id="bt-run" style="width:100%;padding:10px;border-radius:6px;font-size:12px;letter-spacing:1px">â–¶ RUN BACKTEST</button>
        </div>
        <div id="bt-results"><div style="display:flex;align-items:center;justify-content:center;height:300px;flex-direction:column;gap:12px;color:#475569"><div style="font-size:36px">ğŸ“Š</div><div>Configure and run backtest</div></div></div>
      </div>
    </div>

    <!-- ORDERS -->
    <div id="pane-orders" style="display:none">
      <div id="orders-wrap" style="display:grid;grid-template-columns:1fr;gap:20px">
        <div><div class="sl" style="margin-bottom:14px">STAGED ORDERS â€” ENTER IN WEBULL</div><div id="orders-list"><div style="text-align:center;padding:60px;color:#334155"><div style="font-size:36px;margin-bottom:12px">ğŸ“‹</div><div>No staged orders</div></div></div></div>
        <div id="order-form" style="display:none"></div>
      </div>
    </div>

    <!-- EVENING SUMMARY -->
    <div id="pane-summary" style="display:none">
      <div style="display:flex;align-items:center;justify-content:space-between;margin-bottom:16px">
        <div>
          <div style="font-size:15px;font-weight:700;color:#a855f7;margin-bottom:3px">â˜… APEX Evening Summary</div>
          <div style="font-size:11px;color:#475569">Auto-logged every fire & near-miss. Persists by trading date. Export each evening.</div>
        </div>
        <div style="display:flex;gap:8px">
          <button class="btn-ghost" onclick="sendSummSMS()" style="font-size:11px;padding:7px 14px;border-radius:6px">ğŸ“± TEXT SUMMARY</button>
          <button class="btn-ghost" onclick="exportSummary()" style="font-size:11px;padding:7px 14px;border-radius:6px">â¬‡ EXPORT</button>
          <button class="btn-danger" onclick="clearToday()" style="font-size:11px;padding:7px 14px;border-radius:6px">ğŸ—‘ CLEAR TODAY</button>
        </div>
      </div>
      <div class="g6" style="margin-bottom:16px" id="sum-kpis"></div>
      <div class="g3" style="margin-bottom:16px">
        <div class="card" style="padding:16px;border-top:2px solid #a855f7">
          <div style="display:flex;align-items:center;justify-content:space-between;margin-bottom:10px"><div class="sl" style="color:#a855f7">APEX FIRE LOG</div><span id="sum-fire-cnt" style="font-size:10px;color:#475569"></span></div>
          <div id="sum-fires" style="max-height:400px;overflow-y:auto"></div>
        </div>
        <div class="card" style="padding:16px;border-top:2px solid #ef4444">
          <div class="sl" style="color:#ef4444;margin-bottom:8px">FALSE POSITIVE ANALYSIS</div>
          <div style="font-size:10px;color:#475569;margin-bottom:10px">Signals on losing trades â€” ranked by frequency</div>
          <div id="sum-fp" style="margin-bottom:12px"></div>
          <div id="sum-fp-txt" style="font-size:10px;color:#334155;padding:10px;background:#080814;border-radius:6px;line-height:1.7"></div>
        </div>
        <div class="card" style="padding:16px;border-top:2px solid #f59e0b">
          <div class="sl" style="color:#f59e0b;margin-bottom:8px">APEX BLOCKERS</div>
          <div style="font-size:10px;color:#475569;margin-bottom:10px">Rules that most often prevent APEX from firing</div>
          <div id="sum-bl" style="margin-bottom:12px"></div>
          <div id="sum-bl-txt" style="font-size:10px;color:#334155;padding:10px;background:#080814;border-radius:6px;line-height:1.7"></div>
        </div>
      </div>
      <div class="card" style="padding:22px;border:1px solid #a855f744;background:linear-gradient(135deg,#0a0514,#080814)">
        <div style="display:flex;align-items:center;gap:10px;margin-bottom:14px">
          <span style="font-size:18px">ğŸ“‹</span>
          <div style="font-size:14px;font-weight:700;color:#a855f7">Executive Summary</div>
          <span id="sum-date" style="font-size:11px;color:#475569;margin-left:auto"></span>
        </div>
        <div id="sum-text" style="font-size:11px;color:#94a3b8;line-height:2;white-space:pre-wrap;font-family:'JetBrains Mono',monospace"></div>
        <div style="border-top:1px solid #1e293b;margin-top:16px;padding-top:16px">
          <div class="sl" style="margin-bottom:10px">LOG APEX TRADE OUTCOME</div>
          <div style="display:grid;grid-template-columns:1fr 1fr 1fr auto;gap:10px;align-items:end">
            <div><label style="font-size:10px;color:#64748b;display:block;margin-bottom:4px">APEX Signal</label><select id="out-sel" style="width:100%;padding:7px 10px;font-size:11px;border-radius:6px"></select></div>
            <div><label style="font-size:10px;color:#64748b;display:block;margin-bottom:4px">Outcome</label>
              <select id="out-outcome" style="width:100%;padding:7px 10px;font-size:11px;border-radius:6px">
                <option value="win">âœ… WIN (+20% target hit)</option>
                <option value="loss">âŒ LOSS (-15% stop hit)</option>
                <option value="scratch">â¡ SCRATCH (manual exit)</option>
              </select>
            </div>
            <div><label style="font-size:10px;color:#64748b;display:block;margin-bottom:4px">Notes</label><input type="text" id="out-notes" placeholder="what happened..." style="width:100%;padding:7px 10px;font-size:11px;border-radius:6px"/></div>
            <button class="btn-primary" onclick="logOutcome()" style="padding:8px 16px;border-radius:6px;font-size:11px;white-space:nowrap;height:34px">LOG â†’</button>
          </div>
        </div>
      </div>
    </div>

  </div><!-- /content -->

  <!-- SETTINGS MODAL -->
  <div id="settings-modal" style="display:none;position:fixed;inset:0;background:#00000099;z-index:200;align-items:center;justify-content:center">
    <div class="card" style="width:500px;padding:30px;max-height:88vh;overflow-y:auto">
      <div style="display:flex;align-items:center;justify-content:space-between;margin-bottom:18px">
        <div style="font-size:14px;font-weight:700;color:#f1f5f9">âš™ Settings & API Status</div>
        <button class="btn-ghost" onclick="closeSettings()" style="padding:4px 10px;border-radius:4px;font-size:12px">âœ•</button>
      </div>
      <div id="settings-body"></div>
    </div>
  </div>

  <!-- FOOTER -->
  <div style="border-top:1px solid #1a1a2e;padding:8px 20px;font-size:10px;color:#1e293b;display:flex;justify-content:space-between;flex-shrink:0">
    <span>SPY EDGE v1.6 Â· Polygon Â· Unusual Whales ($250K+ flow + GEX) Â· Tradier Â· Pushover Â· Not financial advice</span>
    <span id="footer-status">â—Œ Demo mode</span>
  </div>
</div>

<script>
/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   PARAMETERS â€” edit these freely, logic is below
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
const P = {
  // â”€â”€ MOMENTUM
  MOM_EMA_TOUCH: 0.40,
  MOM_EMA_STOP: 0.50, MOM_EMA_TGT: 2.50,
  // â”€â”€ GEX GATE â€” required gate, gravitational magnet model
  GEX_MAJOR_SIG: 60,         // â‰¥60 = major level (primary magnet / wall)
  GEX_MOD_SIG:   25,         // 25â€“59 = moderate (respect but not primary)
  GEX_AT_LEVEL:  0.75,       // â‰¤$0.75 from major = "at level"
  GEX_APPROACH:  3.00,       // $0.75â€“$3.00 = "approach zone" (entry trigger)
  GEX_CLR_LOOKBACK: 6,       // lookback candles for moderate-level clearance check
  GEX_CLR_CANDLES: 2,        // consecutive closes needed to confirm level cleared
  GEX_SUPPORT_PROX: 0.75,    // within $0.75 = counts as support touch
  GEX_CONT_MAJOR_AHEAD: 4.0, // Rule 1/3: major must be within $4 ahead for continuation
  GEX_CONT_MOD_AHEAD: 4.0,   // Rule 2: moderate within $4 of last support level
  GEX_CONT_MAJ_FROM_MOD: 6.0,// Rule 2: major within $6 of last moderate support level
  GEX_ABS_MIN_PREM: 15000000,// $15M absolute minimum premium for minor levels to count
  LVL_STOP: 0.75, LVL_TGT: 3.00,
  // â”€â”€ DEX â€” sub-booster inside GEX Gate
  DEX_STRIKE_PCT: 0.03, DEX_MIN_PREM: 100000, DEX_STRONG: 0.60,
  // â”€â”€ FLOW BOOSTER
  FLOW_SWEEP_MIN: 250000,
  FLOW_MOM_THRESH: 0.65,
  FLOW_SM_MIN_PRINTS: 2, FLOW_SM_MINS: 15,
  FLOW_W_0DTE: 10, FLOW_W_1DTE: 8, FLOW_W_2DTE: 5, FLOW_W_3DTE: 3, FLOW_W_7DTE: 1,
  FLOW_DECAY_TODAY_H1: 100, FLOW_DECAY_TODAY_H2: 150,
  FLOW_DECAY_YESTERDAY: 20, FLOW_DECAY_3D: 5, FLOW_DECAY_7D: 1, FLOW_DECAY_30D: 0.2,
  FLOW_STOP: 1.00, FLOW_TGT: 2.50,
  // â”€â”€ GEX defaults
  GEX_FLIP: 584.00, GEX_CWALL: 590.00, GEX_PWALL: 578.00,
  // â”€â”€ DARK POOL
  DP_MIN_PREMIUM: 1000000, DP_PROX: 0.75, DP_LOOKBACK_DAYS: 5,
  // â”€â”€ FLOW GEX PROXY â€” 0DTE primary
  FLOW_GEX_STRIKE_PCT: 0.03, FLOW_GEX_MIN_PREM: 250000,
  FLOW_GEX_0DTE_MIN: 3, FLOW_GEX_1DTE_MIN: 3, FLOW_GEX_LAST_HOUR_START: 15,
  // â”€â”€ APEX â€” GEX gate + boosters
  APEX_CONF: 100,            // composite â‰¥100 to fire (gate score + booster pts)
  APEX_MOM_MAX: 40,          // max Momentum booster contribution
  APEX_FLOW_MAX: 40,         // max Flow booster contribution
  APEX_VEL_MAX: 30,          // max Velocity booster contribution
  APEX_PATH_MAX: 15,         // max Path cleanliness contribution
  // Regime-adjusted thresholds â€” range days demand much higher conviction
  APEX_CONF_TRENDING: 100,
  APEX_CONF_MIXED: 112,
  APEX_CONF_RANGE: 128,
  // Blackout windows (ET minutes from midnight): no APEX during these periods
  APEX_BO_AM_START: 9*60+30, APEX_BO_AM_END: 10*60,     // 9:30â€“10:00am
  APEX_BO_PM_START: 15*60+30, APEX_BO_PM_END: 16*60,    // 3:30â€“4:00pm
  APEX_TGT_MOVE: 4.00, APEX_STOP_BUF: 0.75,
  APEX_TGT_PCT: 20, APEX_STOP_PCT: 15,
  // â”€â”€ DAY-TYPE CLASSIFIER
  DAY_VWAP_SLOPE_CANDLES: 12, // 12 Ã— 5m = 60 min VWAP slope window
  DAY_ATR_RANGE_THRESH: 0.75, // >75% of session ATR used non-directionally by noon = range
  DAY_MIN_CANDLES: 14,        // need â‰¥14 5m candles (70 min) before classifying
  DAY_TREND_THRESH: 60,       // score â‰¥60 = TRENDING
  DAY_RANGE_THRESH: 38,       // score â‰¤38 = RANGE, else MIXED
  // â”€â”€ VELOCITY SCORER
  VEL_VOL_MULT: 1.5,          // current candle volume â‰¥1.5Ã— session avg = fuel
  VEL_AM_START: 10*60,        // 10:00am ET
  VEL_AM_END:   11*60,        // 11:00am ET  (best velocity window)
  VEL_PM_START: 14*60,        // 2:00pm ET
  VEL_PM_END:   14*60+45,     // 2:45pm ET   (secondary window)
  // â”€â”€ PATH CLEANLINESS
  PATH_LOOK_DIST: 4.00,       // check for levels this far toward target
  // â”€â”€ GRAB DETECTION
  GRAB_BODY_THRESH: 0.60,     // wick > 60% of total range = probable grab candle
  GRAB_VOL_RATIO:   0.60,     // follow-through vol < 60% of approach avg = suspect
  GRAB_INVALIDATE:  0.30,     // price returns $0.30 past cleared level = invalidate
  // â”€â”€ TRADIER STREAMING DELTA
  DELTA_TICK_WINDOW: 120,     // rolling window of ticks to track (last 120 prints)
  DELTA_SURGE_THRESH: 0.72,   // â‰¥72% same-direction ticks = surge
  DELTA_SURGE_MIN_TICKS: 30,  // need â‰¥30 ticks before scoring surge
  DELTA_SURGE_MAX: 25,        // max delta imbalance contribution to composite
  DELTA_STALL_THRESH: 0.52,   // delta flips back inside 52% = stall signal
  // â”€â”€ GAMMA FLIP TRANSITION
  GEX_FLIP_LOOKBACK: 8,       // candles to look back for recent flip event
  GEX_FLIP_BONUS: 18,         // gate score bonus when price breaks gamma flip level
  GEX_FLIP_DECAY: 3,          // bonus decays by this amount per candle after flip
  // â”€â”€ VWAP GATE (alternative when GEX in Float)
  VWAP_GATE_PROX: 0.35,       // within $0.35 of VWAP = testing it
  VWAP_GATE_MAX: 65,          // max VWAP gate score (weaker anchor than GEX wall)
  VWAP_GATE_MIN: 40,          // minimum score to activate VWAP gate
  VWAP_DELTA_BOOST: 15,       // delta surge at VWAP adds this to gate score
  SMS_APEX: true, LIVE_MS: 5000, FLOW_MS: 10000,
  // â”€â”€ LEGACY compat
  SWEEP_MIN_PREM: 250000, GEX_DIST: 1.50,
  DP_EMA_BOOST: 5, DP_ORB_BOOST: 5, GEX_REGIME_BOOST: 5,
  HVN_EMA_ALIGN_BOOST: 5, ORB_WINDOW_MINS: 90, GEX_INTERVAL_MIN: 30,
};

// â”€â”€ API KEYS & CONNECTION STATE
let K = { poly:'', uw:'', sg:'', trad:'', ptoken:'', puser:'', cfWorker:'' };
let CON = { poly:false, uw:false, sg:false, trad:false, push:false, stream:false };

// â”€â”€ STREAMING DELTA STATE
let deltaTicks=[];          // rolling window of {price, dir, ts}
let deltaRunning=0;         // cumulative delta: +1 per uptick, -1 per downtick
let deltaLastPrice=0;       // last trade price for uptick/downtick determination
let deltaInflection=null;   // {dir, strength, ts} â€” most recent surge detection
let tradierSessionId=null;  // SSE session token
let tradierSSE=null;        // EventSource instance
let deltaConnectAttempts=0; // reconnect counter

// â”€â”€ GAMMA FLIP STATE
let prevPosGEX=null;        // previous scan's posGEX state for flip detection
let gexFlipEvents=[];       // [{ts, price, toPos, candle}] â€” session flip log

// â”€â”€ APP STATE
let src='mock', live=false;
let liveIv=null, flowIv=null, gexIv=null;
let c5=[], c15=[];
let price=587.13, chg=0, meta={};
let uwFlow=[], sgGEX=null, dpLevels=[];
let sigs=[], orders=[], selSig=null, tab='signals';
let rules={ ema:true, sw:true, dd:true };
let apexBT=false, lastGEXt=0;
let currentMom={}, currentLvl={}, currentFlow={}, currentVWAP=null;

// â”€â”€ MOCK DATA
const MOCK_FLOW=[
  {time:'09:32',type:'CALL',strike:590,expiry:'02/27',premium:712000,size:2300,sentiment:'bullish',sweep:true},
  {time:'09:51',type:'PUT', strike:585,expiry:'02/27',premium:521000,size:1700,sentiment:'bearish',sweep:true},
  {time:'10:04',type:'CALL',strike:592,expiry:'02/28',premium:843000,size:2800,sentiment:'bullish',sweep:true},
  {time:'10:22',type:'PUT', strike:583,expiry:'02/27',premium:156000,size:500, sentiment:'bearish',sweep:false},
  {time:'10:38',type:'CALL',strike:588,expiry:'03/06',premium:921000,size:3100,sentiment:'bullish',sweep:true},
  {time:'10:55',type:'PUT', strike:580,expiry:'02/27',premium:677000,size:2200,sentiment:'bearish',sweep:true},
  {time:'11:08',type:'CALL',strike:595,expiry:'03/06',premium:512000,size:1700,sentiment:'bullish',sweep:false},
  {time:'11:24',type:'CALL',strike:590,expiry:'02/27',premium:888000,size:2900,sentiment:'bullish',sweep:true},
];
function mockGEX(){ return { flipLevel:P.GEX_FLIP, keyLevels:[
  {price:P.GEX_CWALL,       gex:2.8,  type:'call wall'},
  {price:P.GEX_FLIP+6,      gex:1.5,  type:'resistance'},
  {price:price,              gex:0.3,  type:'current'},
  {price:P.GEX_FLIP,        gex:0,    type:'gamma flip'},
  {price:P.GEX_FLIP-6,      gex:-1.3, type:'support'},
  {price:P.GEX_PWALL,       gex:-2.5, type:'put wall'},
]};}
const getFlow=()=> uwFlow.length ? uwFlow : MOCK_FLOW;
const getGEX =()=> sgGEX || mockGEX();

function genCandles(base,n,iv){ const c=[]; let p=base,now=Date.now(); for(let i=n;i>=0;i--){const o=p,ch=(Math.random()-.48)*1.8,cl=Math.max(o+ch,base*.95); c.push({t:now-i*iv*1000,o,h:Math.max(o,cl)+Math.random()*.5,l:Math.min(o,cl)-Math.random()*.5,c:cl,v:Math.floor(700000+Math.random()*500000)}); p=cl;} return c; }

// â”€â”€ MATH
function ema(cs,n){const k=2/(n+1);let e=cs[0].c;return cs.map((c,i)=>({t:c.t,v:i?e=c.c*k+e*(1-k):e}));}
function vwap(cs){let tv=0,vv=0;return cs.map(c=>{const tp=(c.h+c.l+c.c)/3;tv+=tp*c.v;vv+=c.v;return{t:c.t,v:tv/vv}});}
function hvn(cs){const bs=0.25,b={};cs.forEach(c=>{const lo=Math.floor(c.l/bs)*bs,hi=Math.ceil(c.h/bs)*bs;for(let p=lo;p<=hi;p=parseFloat((p+bs).toFixed(2)))b[p]=(b[p]||0)+c.v});return Object.entries(b).map(([p,v])=>({price:+p,vol:v})).sort((a,z)=>z.vol-a.vol).slice(0,6).map(n=>n.price);}
function orb(cs){const o=cs.slice(0,P.ORB_CANDLES);if(o.length<P.ORB_CANDLES)return null;const h=Math.max(...o.map(c=>c.h)),l=Math.min(...o.map(c=>c.l));return{high:h,low:l,mid:(h+l)/2};}
function delta(cs,fl){const r=cs.slice(-P.DELTA_LOOKBACK),up=r.at(-1).c>r[0].c,dn=r.at(-1).c<r[0].c,cd=fl.filter(f=>f.type==='CALL').reduce((a,b)=>a+b.premium,0),pd=fl.filter(f=>f.type==='PUT').reduce((a,b)=>a+b.premium,0);return{bull:dn&&cd>pd*P.DELTA_RATIO,bear:up&&pd>cd*P.DELTA_RATIO,cd,pd};}
function fibs(cs){
  const lookback=cs.slice(-40);
  const hi=Math.max(...lookback.map(c=>c.h)), lo=Math.min(...lookback.map(c=>c.l)), rng=hi-lo;
  return [lo+rng*0.382,lo+rng*0.500,lo+rng*0.618,hi-rng*0.382,hi-rng*0.500,hi-rng*0.618];
}
function nearFib(fibLevels,p){return fibLevels.some(f=>Math.abs(p-f)<P.FIB_PROX);}

// RSI â€” 14-period on 5m candles
function rsi(cs,n=P.RSI_PERIOD){
  if(cs.length<n+1) return 50;
  let gains=0,losses=0;
  for(let i=cs.length-n;i<cs.length;i++){
    const d=cs[i].c-cs[i-1].c;
    if(d>0) gains+=d; else losses+=Math.abs(d);
  }
  const ag=gains/n, al=losses/n;
  return al===0?100:100-(100/(1+ag/al));
}

// Volume filter â€” current 5m candle vs avg of last N x 5m candles
// Only applied between P.RSI_HOUR_START and P.RSI_HOUR_END ET
function volRising(c5){
  const etH=new Date(new Date().toLocaleString('en-US',{timeZone:'America/New_York'})).getHours();
  if(etH<P.RSI_HOUR_START||etH>=P.RSI_HOUR_END) return true;
  if(c5.length<P.VOL_LOOKBACK_5M+1) return true;
  const recent=c5.slice(-(P.VOL_LOOKBACK_5M+1),-1); // last N completed 5m candles
  const avg=recent.reduce((a,c)=>a+c.v,0)/recent.length;
  const cur=c5.at(-1).v;
  return cur>=avg*P.VOL_MIN_RATIO;
}


// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  v1.7 THREE-SIGNAL ENGINE
//  Signal 1: MOMENTUM    â€” EMA trend + 5m retest
//  Signal 2: LEVEL REACT â€” GEX-physics-aware level reaction
//  Signal 3: FLOW CONV   â€” sweeps + clustering + momentum ratio
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// GEX wall velocity tracking â€” stores last 8 applyFlowGEX results
let gexHistory=[];
function trackGEXVelocity(cwall,pwall,flip){
  gexHistory.push({ts:Date.now(),cwall,pwall,flip});
  if(gexHistory.length>8) gexHistory.shift();
}
function gexWallVelocity(){
  if(gexHistory.length<2) return{callV:0,putV:0};
  const old=gexHistory[0],cur=gexHistory.at(-1);
  return{callV:cur.cwall-old.cwall,putV:cur.pwall-old.pwall};
}

// â”€â”€ SIGNAL 1: MOMENTUM
// 15m â€” structural health score (degrades as price loses EMAs)
//   Fresh crossover > established stack > price below 8 > price below 21
// 5m â€” layered boost/penalty on top of 15m anchor
//   Full stack aligned > price above 8 > crossing 8 (neutral) >
//   price crossing 21 (penalty) > 8 cross 21 contra 15m (large penalty)
// Confirmed retest (3-condition): prior impulse + pullback body discipline
//   + confirmation candle closes through retest high/low = extra boost
function scoreMomentum(c5,c15){
  if(c5.length<22||c15.length<4)
    return{active:false,direction:null,score:0,detail:'Insufficient data',
      subItems:[],entry:price,target:price+P.MOM_EMA_TGT,stop:price-P.MOM_EMA_STOP};

  // â”€â”€ 15M STRUCTURE â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  const e8b=ema(c15,8), e21b=ema(c15,21);
  const e8bv=e8b.at(-1).v, e21bv=e21b.at(-1).v;
  const e8bPrev=e8b.at(-2)?.v??e8bv, e21bPrev=e21b.at(-2)?.v??e21bv;
  const L15=c15.at(-1);

  const bull15Cross=e8bPrev<=e21bPrev&&e8bv>e21bv;
  const bear15Cross=e8bPrev>=e21bPrev&&e8bv<e21bv;
  const bull15Stack=e8bv>e21bv;
  const bear15Stack=e8bv<e21bv;

  // Direction is set by EMA stack â€” price position modulates score
  const isBull15=bull15Stack;
  const isBear15=bear15Stack;
  if(!isBull15&&!isBear15)
    return{active:false,direction:null,score:15,detail:'15m EMAs flat â€” no trend',
      subItems:['15m 8/21 EMA flat â€” waiting for direction'],
      entry:price,target:price,stop:price};

  const dir=isBull15?'CALL':'PUT';
  let score=0;
  const items=[];

  // 15m score: fresh crossover gets max, then degrade based on price vs EMAs
  if(bull15Cross||bear15Cross){
    // Fresh crossover â€” strongest 15m signal
    score+=50;
    items.push(bull15Cross?'15m bullish crossover â€” fresh trend start':'15m bearish crossover â€” fresh trend start');
  } else if(isBull15&&L15.c>e8bv){
    // Price above 8 EMA, 8 above 21 â€” full structure intact
    score+=35;
    items.push('15m bullish stack Â· price above 8 EMA');
  } else if(isBear15&&L15.c<e8bv){
    score+=35;
    items.push('15m bearish stack Â· price below 8 EMA');
  } else if(isBull15&&L15.c>e21bv&&L15.c<=e8bv){
    // Price slipped below 8 but still above 21 â€” structure weakening
    score+=18;
    items.push('âš  15m bullish but price below 8 EMA â€” structure weakening');
  } else if(isBear15&&L15.c<e21bv&&L15.c>=e8bv){
    score+=18;
    items.push('âš  15m bearish but price above 8 EMA â€” structure weakening');
  } else {
    // Price through 21 EMA â€” structure effectively broken
    score+=5;
    items.push('âš  Price through 21 EMA â€” 15m structure broken');
  }

  // â”€â”€ 5M STATE â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  const e8_5=ema(c5,8), e21_5=ema(c5,21);
  const e8_5v=e8_5.at(-1).v, e21_5v=e21_5.at(-1).v;
  const e8_5Prev=e8_5.at(-2)?.v??e8_5v, e21_5Prev=e21_5.at(-2)?.v??e21_5v;
  const L5=c5.at(-1), Pv5=c5.at(-2);

  // 5m EMA cross events
  const bull5Cross=e8_5Prev<=e21_5Prev&&e8_5v>e21_5v;
  const bear5Cross=e8_5Prev>=e21_5Prev&&e8_5v<e21_5v;
  const cross5AlignsWithBull=isBull15&&bull5Cross;
  const cross5AlignsWithBear=isBear15&&bear5Cross;
  const cross5Contra=(isBull15&&bear5Cross)||(isBear15&&bull5Cross);

  // Price position relative to 5m EMAs
  const priceAbove8_5=L5.c>e8_5v;
  const priceAbove21_5=L5.c>e21_5v;
  const fullBull5=priceAbove8_5&&e8_5v>e21_5v;   // price above 8, 8 above 21
  const fullBear5=!priceAbove8_5&&e8_5v<e21_5v;   // price below 8, 8 below 21
  const bull5Aligned=isBull15&&fullBull5;
  const bear5Aligned=isBear15&&fullBear5;

  // Price just crossed 8 EMA on 5m (body spans it â€” candle open on one side, close other)
  const crossed8Bull5=Pv5.c<e8_5Prev&&L5.c>e8_5v;  // crossed up
  const crossed8Bear5=Pv5.c>e8_5Prev&&L5.c<e8_5v;  // crossed down
  const crossed8Contra=(isBull15&&crossed8Bear5)||(isBear15&&crossed8Bull5);

  // Price crossed 21 EMA (stronger break)
  const crossed21Bull5=Pv5.c<e21_5Prev&&L5.c>e21_5v;
  const crossed21Bear5=Pv5.c>e21_5Prev&&L5.c<e21_5v;
  const crossed21Contra=(isBull15&&crossed21Bear5)||(isBear15&&crossed21Bull5);
  const crossed21Aligned=(isBull15&&crossed21Bull5)||(isBear15&&crossed21Bear5);

  // Score 5m state
  if(cross5Contra){
    // 8 EMA crossed 21 on 5m against the 15m trend â€” most negative
    score-=20;
    items.push('âš  5m EMA cross contradicts 15m trend â€” momentum reversal on 5m');
  } else if(cross5AlignsWithBull||cross5AlignsWithBear){
    // Fresh 5m cross aligning with 15m â€” strong confirmation
    score+=28;
    items.push('5m bullish cross aligns with 15m trend â€” fresh momentum');
  } else if(crossed21Contra){
    // Price crossed 21 EMA on 5m contra to 15m
    score-=15;
    items.push('âš  Price through 5m 21 EMA â€” contradicts 15m direction');
  } else if(crossed21Aligned){
    score+=20;
    items.push('Price reclaimed 5m 21 EMA in trend direction');
  } else if(bull5Aligned||bear5Aligned){
    // Full 5m stack in trend direction
    score+=22;
    items.push(isBull15?'5m stack confirms 15m â€” price above both EMAs':'5m stack confirms 15m â€” price below both EMAs');
  } else if(crossed8Contra){
    // Just crossed 8 EMA against 15m â€” caution but not disaster yet
    score-=8;
    items.push('âš  Price crossed 5m 8 EMA â€” monitor for 21 test');
  } else if((isBull15&&priceAbove8_5)||(isBear15&&!priceAbove8_5)){
    // Price on right side of 8 EMA, aligned with 15m
    score+=12;
    items.push(isBull15?'Price above 5m 8 EMA â€” supportive of 15m':'Price below 5m 8 EMA â€” supportive of 15m');
  } else if((isBull15&&priceAbove21_5&&!priceAbove8_5)||(isBear15&&!priceAbove21_5&&priceAbove8_5)){
    // Between the two EMAs â€” indecision
    score+=0;
    items.push('Price between 5m EMAs â€” indecision, no boost');
  } else {
    // Price on wrong side of both 5m EMAs
    score-=10;
    items.push('Price through both 5m EMAs â€” contradicts 15m');
  }

  // â”€â”€ 3-CONDITION CONFIRMED RETEST â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // Checks c5.at(-2) as the retest candle, c5.at(-1) as the confirmation candle
  // Condition 1: Prior impulse â€” at least one of the 5 candles before retest
  //              had its close >$0.50 away from 8 EMA in the trend direction
  // Condition 2: Retest candle body closes within $0.30 of 8 EMA AND
  //              body size < avg body of prior 3 candles (pullback, not reversal)
  // Condition 3: Confirmation candle closes through retest candle's high (bull)
  //              or low (bear) â€” the actual "reclaim"
  let retestConfirmed=false, retestDetail='';
  if(c5.length>=8){
    const retestC=Pv5;                         // previous candle = retest candle
    const confirmC=L5;                         // current candle = confirmation
    const e8_at_retest=e8_5Prev;               // 8 EMA value when retest candle formed

    // Condition 1: prior impulse separation
    const preRetestCandles=c5.slice(-7,-2);    // 5 candles before the retest candle
    const preRetestEMAs=e8_5.slice(-7,-2);
    const hadSeparation=preRetestCandles.some((cn,i)=>{
      const emav=preRetestEMAs[i]?.v??e8_at_retest;
      return isBull15?(cn.c-emav>0.50):(emav-cn.c>0.50);
    });

    // Condition 2: retest candle body discipline
    const retestBodySize=Math.abs(retestC.c-retestC.o);
    const avgPriorBody=preRetestCandles.slice(-3).reduce((a,cn)=>a+Math.abs(cn.c-cn.o),0)/3;
    const retestBodyNearEMA=isBull15?
      (Math.abs(retestC.c-e8_at_retest)<0.30&&retestC.c>e8_at_retest-0.15):  // closed near/above EMA
      (Math.abs(retestC.c-e8_at_retest)<0.30&&retestC.c<e8_at_retest+0.15);  // closed near/below EMA
    const retestBodySmall=retestBodySize<avgPriorBody;

    // Condition 3: confirmation closes through retest candle's extreme
    const confirmReclaims=isBull15?
      (confirmC.c>retestC.h):  // closed above retest candle high
      (confirmC.c<retestC.l);  // closed below retest candle low

    if(hadSeparation&&retestBodyNearEMA&&retestBodySmall&&confirmReclaims){
      retestConfirmed=true;
      // Volume check: extra boost if confirmation candle has above-avg volume
      const avgVol=c5.slice(-6,-1).reduce((a,cn)=>a+cn.v,0)/5;
      const strongVol=confirmC.v>avgVol;
      score+=strongVol?22:15;
      retestDetail=`Confirmed retest of 5m 8 EMA${strongVol?' Â· strong volume':''}`;
      items.push(`âœ“ ${retestDetail}`);
    }
  }

  // â”€â”€ VWAP â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  const vwv=vwap(c5).at(-1).v;
  const abVwap=L5.c>vwv;
  if((isBull15&&abVwap)||(isBear15&&!abVwap)){
    score+=8; items.push('VWAP aligned');
  } else {
    items.push('VWAP not aligned');
  }

  score=Math.min(Math.max(score,0),100);

  // Active: needs meaningful positive score AND price not through both 5m EMAs against trend
  const hardBlock=(isBull15&&!priceAbove21_5&&!bull5Cross)||
                  (isBear15&&priceAbove21_5&&!bear5Cross);
  const active=score>=45&&!hardBlock;

  // EMA distance fields used by scaled contrary penalty in detectApex
  const ema8Dist=Math.abs(L5.c-e8_5v);
  const ema21Dist=Math.abs(L5.c-e21_5v);
  const bothEMAsAgainstCall=!priceAbove8_5&&e8_5v<e21_5v;
  const bothEMAsAgainstPut=priceAbove8_5&&e8_5v>e21_5v;
  const synthTag=c15.at(-1)?.synthetic?' Â· [synth candle]':'';
  const emaDebug=`15m 8/${e8bv.toFixed(2)} 21/${e21bv.toFixed(2)}${synthTag} Â· 5m 8/${e8_5v.toFixed(2)} 21/${e21_5v.toFixed(2)}`;
  const detail=items[0]+(items[1]?` Â· ${items[1]}`:'')+` Â· ${emaDebug}`;
  return{active,direction:dir,score,detail,subItems:items,
    entry:L5.c,
    target:isBull15?L5.c+P.MOM_EMA_TGT:L5.c-P.MOM_EMA_TGT,
    stop:isBull15?L5.c-P.MOM_EMA_STOP:L5.c+P.MOM_EMA_STOP,
    retestConfirmed,ema8Dist,ema21Dist,
    bothEMAsAgainst:dir==='CALL'?bothEMAsAgainstCall:bothEMAsAgainstPut,
    isBull15,isBear15,priceAbove8_5,priceAbove21_5,
    e8bv,e21bv,e8_5v,e21_5v};
}

// â”€â”€ BLACKOUT HELPER â€” APEX never fires in pre-10am or post-3:30pm windows
function isBlackout(){
  const et=new Date(new Date().toLocaleString('en-US',{timeZone:'America/New_York'}));
  const m=et.getHours()*60+et.getMinutes();
  return (m>=P.APEX_BO_AM_START&&m<P.APEX_BO_AM_END)||(m>=P.APEX_BO_PM_START&&m<P.APEX_BO_PM_END);
}
function blackoutLabel(){
  const et=new Date(new Date().toLocaleString('en-US',{timeZone:'America/New_York'}));
  const m=et.getHours()*60+et.getMinutes();
  if(m>=P.APEX_BO_AM_START&&m<P.APEX_BO_AM_END) return'BUILDING (pre-10am)';
  if(m>=P.APEX_BO_PM_START&&m<P.APEX_BO_PM_END) return'CLOSED (post-3:30pm)';
  return null;
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  GEX GATE â€” CONTINUATION ARCHITECTURE
//  Session state tracks confirmed cleared/support levels so the gate
//  can recognise trend continuation, not just static level proximity.
//
//  LEVEL TIERS (session-relative, normalised to dominant = 100)
//    Major    â‰¥60  : call/put walls, gamma flip, large DP clusters
//    Moderate 25â€“59: meaningful S/R with institutional footprint
//    Minor    <25  : noise â€” ignored UNLESS absolutePremium â‰¥ $15M
//
//  CONTINUATION RULES
//    Rule 1 â€” Major cleared as support, NOTHING within $4 ahead â†’ FLOAT
//    Rule 2 â€” Moderate cleared/absorbed, moderate/major within $4
//             AND major within $6 of that moderate â†’ STEPPING_STONE
//    Rule 3 â€” Major cleared as support, another major within $4 ahead
//             â†’ MAJOR_TO_MAJOR (highest conviction)
//
//  CLEARANCE CONFIRMATION (liquidity grab filter)
//    A level is "confirmed cleared" only when 2+ consecutive candle
//    closes are on the far side AND clearance candles are larger-bodied
//    than approach candles (momentum, not exhaustion).
//
//  DEX runs at every stage â€” at cleared level it confirms support
//  character; in continuation it evaluates dealer positioning at
//  the destination major (approach vs through-break modes).
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// Session-persistent state â€” reset at session start via resetGEXState()
let gexLevelState={
  clearedMajors:[],    // [{price,type,side,confirmedAt,refPrice,sig}]
  clearedModerates:[], // [{price,type,side,confirmedAt,refPrice,sig}]
  supportAnchors:[],   // [{price,type,tier,side,lastSeenAt}]
  lastResetDate:'',
};
function resetGEXState(){
  const d=new Date().toLocaleDateString('en-US',{timeZone:'America/New_York'});
  if(gexLevelState.lastResetDate!==d){
    gexLevelState={clearedMajors:[],clearedModerates:[],supportAnchors:[],lastResetDate:d};
  }
}

// Returns true if last N candles all closed on far side of levelPrice in dir
function isConfirmedClear(c5,levelPrice,dir,n=2){
  const recent=c5.slice(-n);
  if(recent.length<n) return false;
  return dir==='CALL'?recent.every(cn=>cn.c>levelPrice):recent.every(cn=>cn.c<levelPrice);
}

// Returns true if clearance candles are larger-bodied than approach (momentum, not grab)
function isDecisiveClear(c5,n=2){
  const clearCandles=c5.slice(-n);
  const approachCandles=c5.slice(-(n+3),-n);
  if(!approachCandles.length) return true; // can't check, assume ok
  const avgClear=clearCandles.reduce((a,cn)=>a+Math.abs(cn.c-cn.o),0)/clearCandles.length;
  const avgApproach=approachCandles.reduce((a,cn)=>a+Math.abs(cn.c-cn.o),0)/approachCandles.length;
  return avgClear>=avgApproach*0.7; // clearance candles at least 70% size of approach
}

// Returns true if price touched this level as support/resistance within lookback candles
function isSupportTouch(c5,levelPrice,dir,lookback=6){
  const recent=c5.slice(-lookback);
  return recent.some(cn=>{
    const dist=Math.abs(cn.l-levelPrice); // bull: wick low near level
    const distH=Math.abs(cn.h-levelPrice); // bear: wick high near level
    return dir==='CALL'?(dist<=P.GEX_SUPPORT_PROX&&cn.c>levelPrice):
                        (distH<=P.GEX_SUPPORT_PROX&&cn.c<levelPrice);
  });
}

function scoreGEXGate(c5,gx,fl){
  resetGEXState();
  const nil={active:false,direction:null,gateScore:0,score:0,zone:'NO_DATA',
    detail:'GEX data building',subItems:['Waiting for 0DTE flow data'],
    entry:price,target:price,stop:price,levelName:'â€”'};
  if(!gx||!gx.keyLevels||c5.length<5) return nil;

  const L=c5.at(-1),prev=c5.at(-2);
  const vel=gexWallVelocity();
  const posGEX=L.c>gx.flipLevel;
  const dex=fl&&fl.length?computeDEX(fl):{direction:null,strong:false,detail:'No data'};

  // â”€â”€ BUILD NORMALISED LEVEL HIERARCHY â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  const raw=[];
  for(const kl of gx.keyLevels){
    if(kl.type==='current') continue;
    raw.push({price:kl.price,type:kl.type,gexVal:kl.gex,
      rawSig:Math.round(Math.abs(kl.gex)/2.8*100),prem:0,
      dist:Math.abs(L.c-kl.price),side:kl.price>L.c?'above':'below'});
  }
  for(const dp of dpLevels.slice(0,6))
    raw.push({price:dp.price,type:`DP $${(dp.totalPremium/1e6).toFixed(0)}M`,gexVal:0,
      rawSig:Math.min(80,Math.round(dp.totalPremium/2e6*100)),prem:dp.totalPremium,
      dist:Math.abs(L.c-dp.price),side:dp.price>L.c?'above':'below'});
  for(const h of hvn(c5))
    raw.push({price:h,type:'HVN',gexVal:0,rawSig:40,prem:0,
      dist:Math.abs(L.c-h),side:h>L.c?'above':'below'});

  if(!raw.length) return nil;
  const maxSig=Math.max(...raw.map(l=>l.rawSig),1);
  const allLevels=raw.map(l=>({...l,
    sig:Math.round(l.rawSig/maxSig*100),
    tier:l.rawSig/maxSig>=0.60?'major':l.rawSig/maxSig>=0.25?'moderate':'minor',
  })).filter(l=>{
    if(l.tier==='minor'&&l.prem>0&&l.prem<P.GEX_ABS_MIN_PREM) return false; // absolute minor floor
    return l.dist<18;
  }).sort((a,b)=>a.dist-b.dist);

  const majors=allLevels.filter(l=>l.tier==='major');
  const moderates=allLevels.filter(l=>l.tier==='moderate');

  // â”€â”€ UPDATE SESSION STATE â€” clearances and support touches â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // Check all known levels for new confirmed clearances this scan
  for(const lv of allLevels){
    // Clearance check: both CALL and PUT directions
    for(const dir of['CALL','PUT']){
      const cleared=isConfirmedClear(c5,lv.price,dir,P.GEX_CLR_CANDLES);
      const decisive=cleared&&isDecisiveClear(c5,P.GEX_CLR_CANDLES);
      if(!cleared||!decisive) continue;

      if(lv.tier==='major'){
        const already=gexLevelState.clearedMajors.find(m=>Math.abs(m.price-lv.price)<0.5&&m.dir===dir);
        if(!already) gexLevelState.clearedMajors.push({...lv,dir,confirmedAt:Date.now(),refPrice:L.c});
      } else if(lv.tier==='moderate'){
        const already=gexLevelState.clearedModerates.find(m=>Math.abs(m.price-lv.price)<0.5&&m.dir===dir);
        if(!already) gexLevelState.clearedModerates.push({...lv,dir,confirmedAt:Date.now(),refPrice:L.c});
      }
    }
    // Support touch check
    for(const dir of['CALL','PUT']){
      if(isSupportTouch(c5,lv.price,dir)){
        const already=gexLevelState.supportAnchors.find(s=>Math.abs(s.price-lv.price)<0.5&&s.dir===dir);
        if(!already) gexLevelState.supportAnchors.push({...lv,dir,lastSeenAt:Date.now()});
        else already.lastSeenAt=Date.now();
      }
    }
  }
  // Expire old state entries (older than 4 hours)
  const expiry=4*60*60*1000;
  gexLevelState.clearedMajors=gexLevelState.clearedMajors.filter(m=>Date.now()-m.confirmedAt<expiry);
  gexLevelState.clearedModerates=gexLevelState.clearedModerates.filter(m=>Date.now()-m.confirmedAt<expiry);
  gexLevelState.supportAnchors=gexLevelState.supportAnchors.filter(s=>Date.now()-s.lastSeenAt<expiry);

  // â”€â”€ HELPER: levels in direction from a reference price â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  const levelsAhead=(refP,dir,tiers=['major','moderate'])=>
    allLevels.filter(lv=>tiers.includes(lv.tier)&&(dir==='CALL'?lv.price>refP:lv.price<refP));
  const nearestAhead=(refP,dir,tiers)=>{
    const ahead=levelsAhead(refP,dir,tiers);
    return ahead.length?ahead.reduce((a,b)=>Math.abs(b.price-refP)<Math.abs(a.price-refP)?b:a):null;
  };
  const distFromRef=(lv,refP)=>Math.abs(lv.price-refP);

  // â”€â”€ CONTINUATION MODE CHECK â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // Look for cleared majors behind price that have support anchor character
  const contDir=posGEX?null:null; // will be set below
  let contMode=null; // 'MAJOR_TO_MAJOR'|'STEPPING_STONE'|null

  // Find cleared major that is now BEHIND current price (used as support)
  const anchoredMajor=gexLevelState.clearedMajors.find(cm=>{
    const behindBull=cm.dir==='CALL'&&cm.price<L.c&&(L.c-cm.price)>0.5;
    const behindBear=cm.dir==='PUT'&&cm.price>L.c&&(cm.price-L.c)>0.5;
    return behindBull||behindBear;
  });

  // Find cleared moderate that is now BEHIND current price (stepping stone)
  const anchoredModerate=gexLevelState.clearedModerates.find(cm=>{
    const behindBull=cm.dir==='CALL'&&cm.price<L.c&&(L.c-cm.price)>0.5;
    const behindBear=cm.dir==='PUT'&&cm.price>L.c&&(cm.price-L.c)>0.5;
    return behindBull||behindBear;
  });

  let contAnchor=null, contDirection=null, contLabel='', gs=0, items=[];

  if(anchoredMajor){
    contDirection=anchoredMajor.dir;
    const refP=anchoredMajor.refPrice; // price when cleared

    // What's ahead of current price in continuation direction?
    const nextMajor=nearestAhead(L.c,contDirection,['major']);
    const nextModerate=nearestAhead(L.c,contDirection,['moderate']);

    // RULE 3 â€” Major ahead within $4 of current price â†’ MAJOR_TO_MAJOR
    if(nextMajor&&distFromRef(nextMajor,L.c)<=P.GEX_CONT_MAJOR_AHEAD){
      contMode='MAJOR_TO_MAJOR';
      contAnchor=anchoredMajor;
      contLabel=`Major-to-major: ${anchoredMajor.type} support â†’ ${nextMajor.type}`;
      const distToNext=distFromRef(nextMajor,L.c);
      const pct=Math.max(0,1-distToNext/P.GEX_CONT_MAJOR_AHEAD);
      gs=Math.round(55+pct*25+anchoredMajor.sig*0.10+nextMajor.sig*0.10);
      items.push(`${contLabel} $${nextMajor.price.toFixed(2)} Â· ${distToNext.toFixed(2)} away`);

      // DEX at destination major â€” approach vs through-break mode
      if(dex.direction&&dex.strong){
        const dexResists=(contDirection==='CALL'&&dex.direction==='PUT')||(contDirection==='PUT'&&dex.direction==='CALL');
        if(dexResists){
          // Dealers resist at destination â€” approach mode, expect reaction
          gs-=5;
          items.push(`DEX: dealers resist at ${nextMajor.type} â€” approach mode, watch for reaction`);
        } else {
          // Dealers must accelerate through â€” through-break mode
          gs+=15;
          items.push(`DEX: dealers forced through ${nextMajor.type} â€” breakout mode`);
        }
      }

      // 1DTE
      if(gx.agreement==='agree'){gs+=8;items.push('1DTE agrees with continuation');}
      else if(gx.agreement==='disagree'){gs-=10;items.push('âš  1DTE disagrees â€” tomorrow conflicts');}

    // RULE 1 â€” Nothing useful within $4 â†’ FLOAT (no trigger)
    } else if(!nextMajor||(nextModerate&&distFromRef(nextModerate,L.c)>P.GEX_CONT_MOD_AHEAD)){
      // Nothing within striking distance â€” float, no continuation trigger
      gs=Math.min(25,Math.round(anchoredMajor.sig*0.20));
      const nearLabel=nextMajor?`nearest major $${nextMajor.price.toFixed(0)} $${distFromRef(nextMajor,L.c).toFixed(1)} away`:'no major ahead';
      return{active:false,direction:contDirection,gateScore:gs,score:gs,zone:'FLOAT',
        detail:`Float â€” ${anchoredMajor.type} support behind, ${nearLabel} Â· no trigger`,
        subItems:[
          `Cleared major support: ${anchoredMajor.type} $${anchoredMajor.price.toFixed(2)}`,
          `Rule 1: nothing within $${P.GEX_CONT_MAJOR_AHEAD} ahead â€” no continuation trigger`,
          nearLabel,
        ],
        entry:L.c,target:contDirection==='CALL'?L.c+P.LVL_TGT:L.c-P.LVL_TGT,
        stop:contDirection==='CALL'?L.c-P.LVL_STOP:L.c+P.LVL_STOP,
        levelName:anchoredMajor.type,posGEX,levels:allLevels,majors,moderates};

    } else if(nextModerate&&distFromRef(nextModerate,L.c)<=P.GEX_CONT_MOD_AHEAD){
      // Moderate ahead but no major within $4 â€” check major within $6 of the moderate
      const majorNearModerate=nearestAhead(nextModerate.price,contDirection,['major']);
      if(majorNearModerate&&distFromRef(majorNearModerate,nextModerate.price)<=P.GEX_CONT_MAJ_FROM_MOD){
        // Treat as stepping stone to major
        contMode='STEPPING_STONE';
        contAnchor=anchoredMajor;
        contLabel=`Stepping stone: ${anchoredMajor.type} â†’ ${nextModerate.type} â†’ ${majorNearModerate.type}`;
        const distToMod=distFromRef(nextModerate,L.c);
        const pct=Math.max(0,1-distToMod/P.GEX_CONT_MOD_AHEAD);
        gs=Math.round(42+pct*18+anchoredMajor.sig*0.08+majorNearModerate.sig*0.08);
        items.push(`${contLabel}`);
        items.push(`Next moderate: $${nextModerate.price.toFixed(2)} Â· major destination: $${majorNearModerate.price.toFixed(2)}`);
        if(dex.direction&&dex.strong){
          if(dex.direction===contDirection){gs+=10;items.push('DEX confirms continuation direction');}
          else{gs-=8;items.push('âš  DEX contradicts continuation â€” reduced confidence');}
        }
        if(gx.agreement==='agree'){gs+=8;items.push('1DTE agrees');}
        else if(gx.agreement==='disagree'){gs-=10;items.push('âš  1DTE disagrees');}
      } else {
        // Moderate ahead but no major within $6 of it â€” float
        gs=Math.min(20,Math.round(anchoredMajor.sig*0.15));
        return{active:false,direction:contDirection,gateScore:gs,score:gs,zone:'FLOAT',
          detail:`Float â€” moderate ahead but no major within $${P.GEX_CONT_MAJ_FROM_MOD} Â· no trigger`,
          subItems:[
            `Cleared major: ${anchoredMajor.type} $${anchoredMajor.price.toFixed(2)} support`,
            `Moderate ${nextModerate.type} $${nextModerate.price.toFixed(2)} ahead but no supporting major`,
            `Rule 1: structure insufficient for continuation trigger`,
          ],
          entry:L.c,target:contDirection==='CALL'?L.c+P.LVL_TGT:L.c-P.LVL_TGT,
          stop:contDirection==='CALL'?L.c-P.LVL_STOP:L.c+P.LVL_STOP,
          levelName:anchoredMajor.type,posGEX,levels:allLevels,majors,moderates};
      }
    }

  } else if(anchoredModerate&&!anchoredMajor){
    // RULE 2 â€” Moderate cleared as support, check for structure ahead
    contDirection=anchoredModerate.dir;
    const nextMajInRange=nearestAhead(anchoredModerate.price,contDirection,['major']);
    const nextModInRange=nearestAhead(L.c,contDirection,['moderate','major']);

    const majWithin6=nextMajInRange&&distFromRef(nextMajInRange,anchoredModerate.price)<=P.GEX_CONT_MAJ_FROM_MOD;
    const modOrMajWithin4=nextModInRange&&distFromRef(nextModInRange,L.c)<=P.GEX_CONT_MOD_AHEAD;

    if(majWithin6&&modOrMajWithin4){
      contMode='STEPPING_STONE';
      contAnchor=anchoredModerate;
      contLabel=`Moderate support: ${anchoredModerate.type} â†’ ${nextModInRange.type}`;
      const distToNext=distFromRef(nextModInRange,L.c);
      const pct=Math.max(0,1-distToNext/P.GEX_CONT_MOD_AHEAD);
      gs=Math.round(38+pct*16+anchoredModerate.sig*0.08+(nextMajInRange?nextMajInRange.sig*0.08:0));
      items.push(`Rule 2 â€” ${contLabel}`);
      items.push(`Next level: $${nextModInRange.price.toFixed(2)} Â· major within $6: $${nextMajInRange?nextMajInRange.price.toFixed(2):'none'}`);
      if(dex.direction&&dex.strong){
        if(dex.direction===contDirection){gs+=10;items.push('DEX confirms direction');}
        else{gs-=8;items.push('âš  DEX contradicts');}
      }
      if(gx.agreement==='agree'){gs+=8;items.push('1DTE agrees');}
      else if(gx.agreement==='disagree'){gs-=10;items.push('âš  1DTE disagrees');}
    }
  }

  // â”€â”€ CONTINUATION RESULT â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  if(contMode&&contDirection&&gs>0){
    // Minor/moderate scoring: only count if major exists within $4 in direction
    const majAheadForMinors=nearestAhead(L.c,contDirection,['major']);
    const majClose=majAheadForMinors&&distFromRef(majAheadForMinors,L.c)<=P.GEX_CONT_MAJOR_AHEAD;
    const lookbackC=c5.slice(-(P.GEX_CLR_LOOKBACK+1),-1);
    const oldP2=lookbackC.length?lookbackC[0].c:L.c;
    const absorbedModeratesAhead=moderates.filter(m=>{
      if(!majClose) return false; // no major ahead = ignore minor/moderate
      return contDirection==='CALL'?(oldP2<m.price&&L.c>m.price):(oldP2>m.price&&L.c<m.price);
    });
    if(absorbedModeratesAhead.length){
      gs+=12;
      items.push(`Absorbed ${absorbedModeratesAhead.length} moderate level${absorbedModeratesAhead.length>1?'s':''} en route â€” momentum confirmed`);
    }

    // Significance bonus for anchor
    if(contAnchor&&contAnchor.sig>=80) items.push(`Anchor dominance (sig ${contAnchor.sig})`);

    // Wall velocity
    if(contDirection==='CALL'&&vel.callV<-0.5){gs+=8;items.push(`Call wall compressing $${vel.callV.toFixed(1)}`);}
    if(contDirection==='PUT'&&vel.putV>0.5){gs+=8;items.push(`Put wall compressing +$${vel.putV.toFixed(1)}`);}

    if(gx.source) items.push(`GEX source: ${gx.source}`);
    gs=Math.min(gs,100);
    const active=gs>=45;
    const zoneLabel=contMode==='MAJOR_TO_MAJOR'?'MAJOR_TO_MAJOR':'STEPPING_STONE';
    return{active,direction:contDirection,gateScore:gs,score:gs,zone:zoneLabel,
      detail:`${contLabel} Â· ${posGEX?'Pos':'Neg'} GEX${dex.strong?' Â· DEX '+dex.direction:''}`,
      subItems:items,entry:L.c,
      target:contDirection==='CALL'?L.c+P.LVL_TGT:L.c-P.LVL_TGT,
      stop:contDirection==='CALL'?L.c-P.LVL_STOP:L.c+P.LVL_STOP,
      levelName:contAnchor?contAnchor.type:'â€”',posGEX,isBreakout:false,dex,
      contMode,contAnchor,levels:allLevels,majors,moderates};
  }

  // â”€â”€ STATIC ZONE LOGIC (no cleared anchor â€” original APPROACH/AT_LEVEL) â”€â”€
  const nm=majors.length?majors.reduce((a,b)=>a.dist<b.dist?a:b):null;

  if(!nm||nm.dist>P.GEX_APPROACH){
    // FLOAT â€” gravitational pull only
    let bullPull=0,bearPull=0;
    for(const m of majors){const p=m.sig/Math.max(m.dist*m.dist,0.1);m.side==='above'?bullPull+=p:bearPull+=p;}
    const net=bullPull-bearPull;
    const pullDir=net>2?'CALL':net<-2?'PUT':null;
    const pullScore=Math.min(30,Math.round(Math.abs(net)*0.4));
    const nearLabel=nm?`${nm.type} $${nm.price.toFixed(0)} $${nm.dist.toFixed(1)} away`:'no major levels';
    return{active:false,direction:pullDir,gateScore:pullScore,score:pullScore,zone:'FLOAT',
      detail:`Float â€” ${nearLabel} Â· ${pullDir?pullDir+' bias':'neutral gravity'}`,
      subItems:[`Nearest major: ${nearLabel}`,
        pullDir?`Net gravitational pull: ${pullDir} (${net.toFixed(1)})`:'Balanced level gravity â€” no clear pull',
        `Majors: ${majors.length} Â· Moderates: ${moderates.length}`,
      ],
      entry:L.c,target:pullDir==='CALL'?L.c+P.LVL_TGT:L.c-P.LVL_TGT,
      stop:pullDir==='CALL'?L.c-P.LVL_STOP:L.c+P.LVL_STOP,
      levelName:nm?nm.type:'â€”',posGEX,levels:allLevels,majors,moderates};
  }

  // APPROACH or AT_LEVEL
  const zone=nm.dist<=P.GEX_AT_LEVEL?'AT_LEVEL':'APPROACH';
  let dir,modeLabel,isBreakout=false;
  if(zone==='APPROACH'){
    dir=nm.side==='above'?'CALL':'PUT';
    modeLabel=`Approaching ${nm.type}`;
  } else {
    if(posGEX){dir=nm.side==='above'?'PUT':'CALL';modeLabel=`Pos GEX fade â€” ${nm.type}`;isBreakout=false;}
    else{dir=nm.side==='above'?'CALL':'PUT';modeLabel=`Neg GEX breakout â€” ${nm.type}`;isBreakout=true;}
  }

  let gs2=0; const items2=[];

  if(zone==='AT_LEVEL'){
    gs2+=50+Math.round((P.GEX_AT_LEVEL-nm.dist)/P.GEX_AT_LEVEL*20);
    items2.push(`${modeLabel} $${nm.price.toFixed(2)} Â· sig ${nm.sig}`);
    const abLvl=L.c>nm.price;
    const rejecting=abLvl?(L.h>nm.price&&L.c<nm.price&&L.c<prev.c):(L.l<nm.price&&L.c>nm.price&&L.c>prev.c);
    const breaking=abLvl?(L.c>nm.price&&prev.c<nm.price):(L.c<nm.price&&prev.c>nm.price);
    if(rejecting){gs2+=20;items2.push('Rejection candle confirmed (dealer selling)');}
    else if(breaking){gs2+=20;items2.push('Level broken â€” dealer acceleration expected');}
    else items2.push(posGEX?'Touching â€” watching for rejection candle':'Pressing â€” watching for break candle');
  } else {
    const pct=(P.GEX_APPROACH-nm.dist)/P.GEX_APPROACH;
    gs2+=Math.round(20+pct*35+nm.sig*0.15);
    items2.push(`${modeLabel} $${nm.price.toFixed(2)} Â· $${nm.dist.toFixed(2)} away Â· sig ${nm.sig}`);
  }

  // Minor/moderate clearance only counts if major within $4 in direction
  const majAheadStatic=nearestAhead(L.c,dir,['major']);
  const majCloseStatic=majAheadStatic&&distFromRef(majAheadStatic,L.c)<=P.GEX_CONT_MAJOR_AHEAD;
  const lookbackS=c5.slice(-(P.GEX_CLR_LOOKBACK+1),-1);
  const oldPS=lookbackS.length?lookbackS[0].c:L.c;
  const clearedMods=moderates.filter(m=>m.dist<=P.GEX_APPROACH&&majCloseStatic&&
    (dir==='CALL'?(oldPS<m.price&&L.c>m.price):(oldPS>m.price&&L.c<m.price)));
  if(clearedMods.length){gs2+=15;items2.push(`Cleared ${clearedMods.length} moderate level${clearedMods.length>1?'s':''} â€” magnet pull confirmed`);}

  if(nm.sig>=80){gs2+=8;items2.push(`Dominant wall (sig ${nm.sig})`);}
  else if(nm.sig>=60) items2.push(`Significant level (sig ${nm.sig})`);

  if(dex.direction&&dex.strong){
    if(dex.direction===dir){gs2+=12;items2.push(`DEX confirms â€” dealers must ${dir==='CALL'?'buy':'sell'} here`);}
    else{gs2-=8;items2.push('âš  DEX contradicts â€” dealer delta resists direction');}
  }
  if(gx.agreement==='agree'){gs2+=8;items2.push(`1DTE agrees${gx.isLastHour?' (last hour blend)':''}`);}
  else if(gx.agreement==='disagree'){gs2-=10;items2.push('âš  1DTE disagrees â€” tomorrow conflicts with today');}
  if(dir==='CALL'&&vel.callV<-0.5){gs2+=8;items2.push(`Call wall compressing $${vel.callV.toFixed(1)}`);}
  if(dir==='PUT'&&vel.putV>0.5){gs2+=8;items2.push(`Put wall compressing +$${vel.putV.toFixed(1)}`);}
  if(gx.source) items2.push(`GEX source: ${gx.source}`);
  gs2=Math.min(gs2,100);

  return{active:gs2>=45&&dir!==null,direction:dir,gateScore:gs2,score:gs2,zone,
    detail:`${modeLabel} $${nm.price.toFixed(2)} Â· ${zone==='AT_LEVEL'?'At level':'Approach'} Â· ${posGEX?'Pos':'Neg'} GEX${dex.strong?' Â· DEX '+dex.direction:''}`,
    subItems:items2,entry:L.c,
    target:dir==='CALL'?L.c+P.LVL_TGT:L.c-P.LVL_TGT,
    stop:dir==='CALL'?L.c-P.LVL_STOP:L.c+P.LVL_STOP,
    levelName:nm.type,levelPrice:nm.price,zone,posGEX,isBreakout,dex,
    nearestMajor:nm,levels:allLevels,majors,moderates};
}
// Legacy alias
function scoreLevelReaction(c5,gx,fl){return scoreGEXGate(c5,gx,fl);}

// â”€â”€ DEX (Delta Exposure) â€” net dealer delta at each strike band
// Dealers are short calls (negative delta) and short puts (positive delta).
// Net dealer delta = -(callDelta) + (putDelta) per strike.
// Where strongly negative â†’ dealers must BUY on rally (accelerant).
// Where strongly positive â†’ dealers must SELL on rally (resistance).
// We approximate delta from moneyness and DTE â€” no need for exact Black-Scholes.
function computeDEX(fl){
  if(!fl.length) return{netDelta:0,callDelta:0,putDelta:0,direction:null,strong:false,nearStrike:null,detail:'No data'};
  const band=price*P.DEX_STRIKE_PCT;
  const nearPrints=fl.filter(f=>f.premium>=P.DEX_MIN_PREM&&f.strike&&Math.abs(f.strike-price)<=band&&f.daysToExp!==null&&f.daysToExp<=7);
  if(!nearPrints.length) return{netDelta:0,callDelta:0,putDelta:0,direction:null,strong:false,nearStrike:null,detail:'No near-term prints in band'};

  // Estimate delta: 0DTE ATM â‰ˆ 0.5, decays with moneyness; scales up as DTEâ†’0
  const estimateDelta=(f)=>{
    const moneyness=Math.abs(f.strike-price)/price; // 0 = ATM
    const dteFactor=f.daysToExp===0?1.0:f.daysToExp===1?0.85:f.daysToExp<=3?0.65:0.50;
    const baseDelta=Math.max(0.05, 0.55 - moneyness*8) * dteFactor;
    return baseDelta;
  };

  // Weight by expiry (soonest = highest weight) and premium
  const expiryWeight=(dte)=>{
    if(dte===0) return P.FLOW_W_0DTE;
    if(dte===1) return P.FLOW_W_1DTE;
    if(dte===2) return P.FLOW_W_2DTE;
    if(dte===3) return P.FLOW_W_3DTE;
    return P.FLOW_W_7DTE;
  };

  let callDelta=0, putDelta=0, totalWeight=0;
  const byStrike={};
  for(const f of nearPrints){
    const d=estimateDelta(f);
    const w=expiryWeight(f.daysToExp);
    const wPrem=f.premium*w;
    if(f.type==='CALL'){
      callDelta+=d*wPrem;
      // Dealer is SHORT the call â†’ negative dealer delta
    } else {
      putDelta+=d*wPrem; // Dealer is SHORT the put â†’ positive dealer delta (puts gain value as price drops)
    }
    totalWeight+=wPrem;
    if(!byStrike[f.strike]) byStrike[f.strike]={calls:0,puts:0};
    byStrike[f.strike][f.type==='CALL'?'calls':'puts']+=wPrem;
  }

  if(!totalWeight) return{netDelta:0,callDelta:0,putDelta:0,direction:null,strong:false,nearStrike:null,detail:'No weighted prints'};

  // Dealer net delta: short calls (negative) + short puts (positive)
  const dealerNetDelta=(putDelta-callDelta)/totalWeight; // negative = dealers short delta = must buy rallies
  const ratio=callDelta/(callDelta+putDelta||1);
  const strong=ratio>=P.DEX_STRONG||ratio<=(1-P.DEX_STRONG);
  const direction=ratio>=P.DEX_STRONG?'PUT':ratio<=(1-P.DEX_STRONG)?'CALL':null; // dealer must buy = bullish for price
  // Most concentrated strike in the band
  const topStrike=Object.entries(byStrike).sort((a,b)=>(b[1].calls+b[1].puts)-(a[1].calls+a[1].puts))[0];
  const nearStrike=topStrike?+topStrike[0]:null;
  return{netDelta:dealerNetDelta,callDelta,putDelta,ratio,direction,strong,nearStrike,
    detail:`DEX ${direction||'neutral'} Â· ${Math.round(ratio*100)}% call-weighted Â· ${nearPrints.length} prints`};
}

// â”€â”€ SIGNAL 3: FLOW CONVICTION
// Three layers:
//   1. Time-weighted positional (30d, exponential recency decay, â‰¤7 DTE only)
//   2. Same-day acceleration check (first vs second half of today's session)
//   3. Live sweeps (30m) + strike magnet (15m, â‰¤3DTE)
function scoreFlowConviction(fl){
  if(!fl.length) return{active:false,direction:null,score:0,detail:'No flow data',subItems:[],entry:price,target:price,stop:price,ratio:0.5,dex:null};

  const now=Date.now();
  const todayOpen=new Date(); // use market open: 9:30am ET today
  todayOpen.setHours(0,0,0,0); // midnight as proxy â€” we'll check ts

  // â”€â”€ RECENCY DECAY WEIGHT
  // Exponential: today's prints dominate, older prints provide context only.
  // Within today we split session in half for acceleration detection.
  const et=new Date(new Date().toLocaleString('en-US',{timeZone:'America/New_York'}));
  const etMins=et.getHours()*60+et.getMinutes();
  const sessionStart=9*60+30; // 9:30am
  const sessionMid=sessionStart+Math.max(0,(etMins-sessionStart)/2); // midpoint of elapsed session
  const sessionMidMs=Date.now()-(etMins-sessionMid)*60*1000;

  const recencyWeight=(f)=>{
    const ageMs=now-f.ts;
    const ageH=ageMs/(1000*60*60);
    if(ageH<1) return P.FLOW_DECAY_TODAY_H2;        // last hour â€” highest weight
    const isTodayH2=f.ts>=sessionMidMs;
    if(isTodayH2) return P.FLOW_DECAY_TODAY_H2;
    const ageD=ageMs/(1000*60*60*24);
    if(ageD<1) return P.FLOW_DECAY_TODAY_H1;         // earlier today
    if(ageD<2) return P.FLOW_DECAY_YESTERDAY;
    if(ageD<4) return P.FLOW_DECAY_3D;
    if(ageD<8) return P.FLOW_DECAY_7D;
    return P.FLOW_DECAY_30D;                          // 8-30 days ago
  };

  // â”€â”€ LAYER 1: TIME-WEIGHTED POSITIONAL (â‰¤7 DTE, all history)
  const positional=fl.filter(f=>f.daysToExp!==null&&f.daysToExp<=7&&f.premium>=P.FLOW_SWEEP_MIN);
  const exW=(dte)=>{
    if(dte===0) return P.FLOW_W_0DTE;
    if(dte===1) return P.FLOW_W_1DTE;
    if(dte===2) return P.FLOW_W_2DTE;
    if(dte===3) return P.FLOW_W_3DTE;
    return P.FLOW_W_7DTE;
  };
  let wCallPrem=0,wPutPrem=0;
  for(const f of positional){
    const w=exW(f.daysToExp)*recencyWeight(f);  // combine expiry weight Ã— recency weight
    if(f.type==='CALL') wCallPrem+=f.premium*w;
    else wPutPrem+=f.premium*w;
  }
  const wTotal=wCallPrem+wPutPrem||1;
  const wRatio=wCallPrem/wTotal;
  const isBullPos=wRatio>=P.FLOW_MOM_THRESH;
  const isBearPos=wRatio<=(1-P.FLOW_MOM_THRESH);

  // â”€â”€ LAYER 2: SAME-DAY ACCELERATION
  // Compare first-half vs second-half weighted ratio for today only.
  // If ratio getting MORE extreme â†’ flow is accelerating â†’ boost
  // If ratio fading back toward 50% â†’ flow decelerating â†’ reduce
  const todayAll=fl.filter(f=>f.daysToExp!==null&&f.daysToExp<=7&&f.premium>=P.FLOW_SWEEP_MIN&&now-f.ts<24*60*60*1000);
  const todayH1=todayAll.filter(f=>f.ts<sessionMidMs);
  const todayH2=todayAll.filter(f=>f.ts>=sessionMidMs);
  let accelDir=null,accelStr='';
  if(todayH1.length>=2&&todayH2.length>=2){
    const r=(arr)=>{const c=arr.filter(f=>f.type==='CALL').reduce((a,f)=>a+f.premium*exW(f.daysToExp),0);const p=arr.filter(f=>f.type==='PUT').reduce((a,f)=>a+f.premium*exW(f.daysToExp),0);return c/(c+p||1);};
    const ratio1=r(todayH1), ratio2=r(todayH2);
    const delta=ratio2-ratio1; // positive = more calls in second half
    if(Math.abs(delta)>0.08){
      accelDir=delta>0?'CALL':'PUT';
      const pct=Math.round(Math.abs(delta)*100);
      accelStr=delta>0?`Call flow accelerating +${pct}% into second half`:`Put flow accelerating +${pct}% into second half`;
    } else if(Math.abs(delta)>0.03){
      accelStr=`Flow stable (${ratio2>0.5?'call':'put'} bias holding)`;
    } else {
      accelStr='Flow mixed â€” no clear intraday acceleration';
    }
  }

  // â”€â”€ LAYER 3: LIVE SWEEPS (30m)
  const sweepCutoff=now-30*60*1000;
  const recentSweeps=fl.filter(f=>f.ts>=sweepCutoff&&f.sweep&&f.premium>=P.FLOW_SWEEP_MIN);
  const callSweeps=recentSweeps.filter(f=>f.type==='CALL').length;
  const putSweeps=recentSweeps.filter(f=>f.type==='PUT').length;
  const sweepDir=callSweeps>putSweeps?'CALL':putSweeps>callSweeps?'PUT':null;
  const sweepAligned=sweepDir&&((isBullPos&&sweepDir==='CALL')||(isBearPos&&sweepDir==='PUT'));

  // â”€â”€ LAYER 4: STRIKE MAGNET (15m, â‰¤3 DTE)
  const smCutoff=now-P.FLOW_SM_MINS*60*1000;
  const smBand=price*0.03;
  const smPrints=fl.filter(f=>f.ts>=smCutoff&&f.premium>=P.FLOW_SWEEP_MIN&&f.strike&&Math.abs(f.strike-price)<=smBand&&f.daysToExp!==null&&f.daysToExp<=3);
  const sc={};
  for(const f of smPrints){
    if(!sc[f.strike])sc[f.strike]={c:0,p:0,tot:0,prem:0};
    sc[f.strike][f.type==='CALL'?'c':'p']++;
    sc[f.strike].tot++;sc[f.strike].prem+=f.premium;
  }
  const dominated=Object.entries(sc).find(([,d])=>d.tot>=P.FLOW_SM_MIN_PRINTS&&(d.c===0||d.p===0));

  // â”€â”€ SCORE
  let score=0,dir=null;
  const items=[];

  // Foundation: positional bias
  if(isBullPos){
    score+=30; dir='CALL';
    const todayCallPct=Math.round(wRatio*100);
    items.push(`${todayCallPct}% weighted call flow (${positional.length} prints â‰¤7 DTE, recency-adjusted)`);
    const urgentCalls=positional.filter(f=>f.daysToExp<=1&&f.type==='CALL');
    if(urgentCalls.length) items.push(`${urgentCalls.length} call prints expiring today/tomorrow â€” high urgency`);
  } else if(isBearPos){
    score+=30; dir='PUT';
    const todayPutPct=Math.round((1-wRatio)*100);
    items.push(`${todayPutPct}% weighted put flow (${positional.length} prints â‰¤7 DTE, recency-adjusted)`);
    const urgentPuts=positional.filter(f=>f.daysToExp<=1&&f.type==='PUT');
    if(urgentPuts.length) items.push(`${urgentPuts.length} put prints expiring today/tomorrow â€” high urgency`);
  } else {
    items.push(`Mixed: ${Math.round(wRatio*100)}% calls / ${Math.round((1-wRatio)*100)}% puts (recency-weighted)`);
  }

  // Acceleration layer
  if(accelDir&&accelDir===dir){
    score+=20; items.push(`âœ“ ${accelStr}`);
  } else if(accelDir&&accelDir!==dir&&dir){
    score-=10; items.push(`âš  ${accelStr} â€” contra positional`);
  } else if(accelStr){
    items.push(accelStr);
  }

  // Live sweeps
  if(sweepAligned){
    score+=20;
    items.push(`${dir==='CALL'?callSweeps:putSweeps} ${dir==='CALL'?'call':'put'} sweeps (30m) confirm direction`);
  } else if(sweepDir&&!sweepAligned){
    score-=10;
    items.push(`âš  ${sweepDir} sweeps contradict positional â€” mixed intent`);
  } else {
    items.push('No recent sweeps â€” positional read only');
  }

  // Strike magnet
  if(dominated){
    const[s,dm]=dominated;
    const md=dm.c>0?'CALL':'PUT';
    if(!dir||dir===md){
      score+=15; dir=md;
      items.push(`Strike magnet $${s} â€” ${dm.tot} prints $${(dm.prem/1e6).toFixed(1)}M â‰¤3DTE`);
    }
  }

  // Urgent premium (money expiring soon = must-resolve pressure)
  const urgentPrem=positional.filter(f=>f.daysToExp<=2).reduce((a,f)=>a+f.premium,0)/1e6;
  if(urgentPrem>3){score+=10;items.push(`$${urgentPrem.toFixed(1)}M expiring â‰¤2 days`);}
  else if(urgentPrem>1){score+=5;items.push(`$${urgentPrem.toFixed(1)}M expiring â‰¤2 days`);}

  score=Math.min(score,100);
  const active=score>=50&&dir!==null&&(isBullPos||isBearPos);
  const entry=price;
  const dex=computeDEX(fl);
  return{active,direction:dir,score,
    detail:items[0]||'Flow building',subItems:items,
    entry,target:dir==='CALL'?entry+P.FLOW_TGT:entry-P.FLOW_TGT,
    stop:dir==='CALL'?entry-P.FLOW_STOP:entry+P.FLOW_STOP,
    ratio:wRatio,callPrem:wCallPrem,putPrem:wPutPrem,
    positionalCount:positional.length,accelDir,dex};
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  DAY-TYPE CLASSIFIER
//  Runs from 10am onward once â‰¥14 5m candles available.
//  Output: { type:'TRENDING'|'MIXED'|'RANGE', score:0-100, evidence:[] }
//
//  Evidence sources (each contributes to a 0-100 trend score):
//   +VWAP slope â€” consistently rising/falling over last 60 min
//   +Hourly displacement â€” each new hour making net progress vs prior
//   +Level rejection pattern â€” clears count as trend, rejections as range
//   âˆ’Grab events count double (grabs = range boundary behaviour)
//   âˆ’ATR utilisation â€” >75% of ATR used non-directionally by noon
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
let dayClassCache={type:'MIXED',score:50,evidence:[],lastCandle:0};

function classifyDayType(c5){
  const et=new Date(new Date().toLocaleString('en-US',{timeZone:'America/New_York'}));
  const etMins=et.getHours()*60+et.getMinutes();

  // Not enough data yet â€” stay neutral
  if(c5.length<P.DAY_MIN_CANDLES||etMins<P.VEL_AM_START)
    return{type:'MIXED',score:50,evidence:['Insufficient data â€” classification begins at 10am']};

  // Cache: only recompute when new candle arrives
  if(dayClassCache.lastCandle===c5.at(-1).t) return dayClassCache;

  let trendPts=0, rangePts=0;
  const evidence=[];

  // â”€â”€ 1. VWAP SLOPE â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  const vw=vwap(c5);
  const slopeWindow=Math.min(P.DAY_VWAP_SLOPE_CANDLES,vw.length-1);
  const vwOld=vw.at(-slopeWindow-1).v, vwNew=vw.at(-1).v;
  const vwSlope=vwNew-vwOld;
  const risingVWAP=vwSlope>0.30;
  const fallingVWAP=vwSlope<-0.30;
  const flatVWAP=Math.abs(vwSlope)<0.10;
  if(risingVWAP||fallingVWAP){
    trendPts+=25;
    evidence.push(`VWAP trending ${risingVWAP?'up':'down'} $${Math.abs(vwSlope).toFixed(2)} over 60m`);
  } else if(flatVWAP){
    rangePts+=20;
    evidence.push(`VWAP flat ($${Math.abs(vwSlope).toFixed(2)}) â€” sideways character`);
  } else {
    evidence.push(`VWAP mild slope $${vwSlope.toFixed(2)}`);
  }

  // â”€â”€ 2. HOURLY DISPLACEMENT â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // Compare the open of the 2nd-to-last complete hour vs the close of the last complete hour.
  // Net displacement in consistent direction = trending evidence.
  const sessionCandles=c5.filter(cn=>{
    const d=new Date(cn.t);
    const m=d.getHours()*60+d.getMinutes();
    return m>=570&&m<960; // 9:30amâ€“4pm
  });
  if(sessionCandles.length>=12){
    const firstSixteen=sessionCandles.slice(0,12);
    const lastTwelve=sessionCandles.slice(-12);
    const earlyMid=(Math.max(...firstSixteen.map(c=>c.h))+Math.min(...firstSixteen.map(c=>c.l)))/2;
    const lateMid=(Math.max(...lastTwelve.map(c=>c.h))+Math.min(...lastTwelve.map(c=>c.l)))/2;
    const disp=lateMid-earlyMid;
    // Check if the ranges overlap heavily (range) vs displaced (trend)
    const earlyHigh=Math.max(...firstSixteen.map(c=>c.h));
    const earlyLow=Math.min(...firstSixteen.map(c=>c.l));
    const lateHigh=Math.max(...lastTwelve.map(c=>c.h));
    const lateLow=Math.min(...lastTwelve.map(c=>c.l));
    const overlap=Math.max(0,Math.min(earlyHigh,lateHigh)-Math.max(earlyLow,lateLow));
    const earlyRange=earlyHigh-earlyLow||0.01;
    const overlapPct=overlap/earlyRange;
    if(overlapPct>0.85){
      rangePts+=20;
      evidence.push(`High range overlap ${Math.round(overlapPct*100)}% â€” price revisiting same area`);
    } else if(overlapPct<0.40&&Math.abs(disp)>0.80){
      trendPts+=20;
      evidence.push(`Net displacement $${disp.toFixed(2)} â€” directional expansion`);
    } else {
      evidence.push(`Mixed displacement $${disp.toFixed(2)}`);
    }
  }

  // â”€â”€ 3. LEVEL REJECTION PATTERN from session state â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  const state=gexLevelState;
  const clearedCount=state.clearedMajors.length+state.clearedModerates.length;
  const grabCount=state.clearedMajors.filter(m=>m.grabSuspected).length+
                  state.clearedModerates.filter(m=>m.grabSuspected).length;
  const rejCount=state.supportAnchors.filter(s=>s.rejectionCount&&s.rejectionCount>=2).length;
  if(clearedCount>0&&grabCount===0){
    trendPts+=Math.min(15,clearedCount*8);
    evidence.push(`${clearedCount} clean level clear${clearedCount>1?'s':''} â€” trend day evidence`);
  }
  if(grabCount>0){
    rangePts+=Math.min(20,grabCount*10);
    evidence.push(`${grabCount} grab event${grabCount>1?'s':''} â€” range boundary behaviour`);
  }
  if(rejCount>0){
    rangePts+=Math.min(15,rejCount*8);
    evidence.push(`${rejCount} level${rejCount>1?'s':''} tested 2+ times â€” range resistance`);
  }

  // â”€â”€ 4. ATR UTILISATION (pre-noon check) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  if(etMins<13*60){ // before 1pm
    const todayCandles=sessionCandles;
    if(todayCandles.length>=4){
      const sessionHigh=Math.max(...todayCandles.map(c=>c.h));
      const sessionLow=Math.min(...todayCandles.map(c=>c.l));
      const sessionRange=sessionHigh-sessionLow;
      // Typical SPY ATR proxy: last 5 days' ranges
      const atrProxy=c5.length>78?
        c5.slice(-78,-78+13).reduce((acc,c)=>acc+c.h-c.l,0)/13:sessionRange;
      const atrUsed=sessionRange/Math.max(atrProxy,0.50);
      if(atrUsed>P.DAY_ATR_RANGE_THRESH&&Math.abs(c5.at(-1).c-c5[0].c)<sessionRange*0.35){
        // Large range used but net movement small = choppy
        rangePts+=15;
        evidence.push(`ATR ${Math.round(atrUsed*100)}% used, net move small â€” chop signature`);
      }
    }
  }

  // â”€â”€ FINAL SCORE â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  const total=trendPts+rangePts||1;
  const trendScore=Math.round(trendPts/(trendPts+rangePts)*100);
  const type=trendScore>=P.DAY_TREND_THRESH?'TRENDING':
             trendScore<=P.DAY_RANGE_THRESH?'RANGE':'MIXED';
  dayClassCache={type,score:trendScore,evidence,lastCandle:c5.at(-1).t};
  return dayClassCache;
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  VELOCITY SCORER
//  Answers: "does this moment have kinetic energy to complete a
//  $2-3 move in <15 minutes?"
//
//  Components:
//   Candle momentum: last 2 candles both closing in signal dir,
//                    expanding bodies = +15, mixed = -10
//   Volume fuel:     current candle â‰¥1.5Ã— session avg = +10,
//                    below avg = -5
//   Time window:     10â€“11am = +10 (best), 2â€“2:45pm = +5
//
//  Returns: { score, detail, items, timeWindow }
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function scoreVelocity(c5,dir){
  if(c5.length<5) return{score:0,detail:'Insufficient data',items:[],timeWindow:'â€”'};

  const L=c5.at(-1), P1=c5.at(-2), P2=c5.at(-3);
  let score=0;
  const items=[];

  // â”€â”€ Candle momentum â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  const L_body=Math.abs(L.c-L.o);
  const P1_body=Math.abs(P1.c-P1.o);
  const P2_body=Math.abs(P2.c-P2.o);
  const L_bull=L.c>L.o, P1_bull=P1.c>P1.o;
  const bothInDir=dir==='CALL'?(L_bull&&P1_bull):(! L_bull&&!P1_bull);
  const expanding=L_body>=P1_body&&P1_body>=P2_body*0.8;
  const mixedBars=dir==='CALL'?(L_bull!==P1_bull):(L_bull===P1_bull);
  const insideBars=L.h<=P1.h&&L.l>=P1.l;

  if(bothInDir&&expanding){
    score+=15;
    items.push(`Expanding ${dir==='CALL'?'bullish':'bearish'} candles â€” move already in progress`);
  } else if(bothInDir){
    score+=8;
    items.push(`Consecutive ${dir==='CALL'?'bullish':'bearish'} candles â€” directional`);
  } else if(insideBars){
    score-=10;
    items.push('Inside bar â€” price contracting, no kinetic energy yet');
  } else if(mixedBars){
    score-=8;
    items.push('Mixed candle direction â€” indecision, velocity uncertain');
  }

  // â”€â”€ Volume fuel â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  const sessionVols=c5.slice(-13,-1).map(c=>c.v);
  const avgVol=sessionVols.reduce((a,b)=>a+b,0)/Math.max(sessionVols.length,1);
  const volRatio=L.v/Math.max(avgVol,1);
  if(volRatio>=P.VEL_VOL_MULT){
    score+=10;
    items.push(`Volume ${Math.round(volRatio*10)/10}Ã— session avg â€” institutional fuel`);
  } else if(volRatio>=1.2){
    score+=5;
    items.push(`Volume ${Math.round(volRatio*10)/10}Ã— session avg â€” above average`);
  } else if(volRatio<0.7){
    score-=5;
    items.push(`Volume ${Math.round(volRatio*10)/10}Ã— session avg â€” thin, move may lack fuel`);
  } else {
    items.push(`Volume ${Math.round(volRatio*10)/10}Ã— session avg`);
  }

  // â”€â”€ Time window â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  const et=new Date(new Date().toLocaleString('en-US',{timeZone:'America/New_York'}));
  const etMins=et.getHours()*60+et.getMinutes();
  let timeWindow='â€”';
  if(etMins>=P.VEL_AM_START&&etMins<P.VEL_AM_END){
    score+=10; timeWindow='AM PRIME (10â€“11am)';
    items.push('AM prime window â€” highest directional velocity probability');
  } else if(etMins>=P.VEL_PM_START&&etMins<P.VEL_PM_END){
    score+=5; timeWindow='PM WINDOW (2â€“2:45pm)';
    items.push('PM reactivation window â€” secondary velocity opportunity');
  } else if(etMins>=11*60&&etMins<14*60){
    timeWindow='MIDDAY';
    items.push('Midday â€” lower velocity probability, require higher conviction');
  } else {
    timeWindow='STANDARD';
  }

  score=Math.max(-15,Math.min(P.APEX_VEL_MAX,score));
  const detail=items[0]||'Velocity neutral';
  return{score,detail,items,timeWindow};
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  PATH CLEANLINESS SCORER
//  Checks all levels between current price and target (Â±PATH_LOOK_DIST).
//  Clean air to target = positive score, obstacles = penalties.
//  Designed for <15 min trade style â€” obstacles cause delays/reversals.
//
//  Returns: { score, detail, obstacles, items }
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function scorePath(gate,dir){
  if(!gate||!gate.levels) return{score:0,detail:'No level data',obstacles:[],items:[]};

  // Always use live price as entry â€” gate.entry is frozen from creation time
  const entryP=price;
  const targetP=dir==='CALL'?entryP+P.PATH_LOOK_DIST:entryP-P.PATH_LOOK_DIST;
  const pathLo=Math.min(entryP,targetP);
  const pathHi=Math.max(entryP,targetP);

  // Levels that sit BETWEEN entry and target (not at entry, not beyond target)
  const inPath=gate.levels.filter(lv=>{
    const inRange=lv.price>pathLo+0.15&&lv.price<pathHi-0.15;
    return inRange;
  });

  let score=0;
  const items=[];
  const obstacles=[];

  if(!inPath.length){
    score+=15;
    items.push(`Clean air to target â€” no levels in $${P.PATH_LOOK_DIST} path`);
  } else {
    for(const lv of inPath){
      obstacles.push(lv);
      if(lv.tier==='major'){
        score-=8;
        items.push(`âš  Major ${lv.type} $${lv.price.toFixed(2)} in path â€” potential stall/reversal`);
      } else if(lv.tier==='moderate'){
        // Only penalise if a major exists in overall direction (otherwise moderate is noise)
        const majAhead=gate.majors&&gate.majors.some(m=>dir==='CALL'?m.price>entryP:m.price<entryP);
        if(majAhead){ score-=4; items.push(`Moderate ${lv.type} $${lv.price.toFixed(2)} in path`); }
      }
      // grabSuspected levels are extra dangerous in path
      if(lv.grabSuspected){score-=6;items.push(`âš  Prior grab at $${lv.price.toFixed(2)} â€” range boundary in path`);}
    }
    if(!items.length) items.push(`${inPath.length} minor level${inPath.length>1?'s':''} in path â€” likely absorbed`);
  }

  score=Math.max(-20,Math.min(P.APEX_PATH_MAX,score));
  const majorCount=inPath.filter(l=>l.tier==='major').length;
  const modCount=inPath.filter(l=>l.tier==='moderate').length;
  const detail=inPath.length===0?`Clean air $${P.PATH_LOOK_DIST}`:
    `${majorCount?majorCount+' major':''} ${modCount?modCount+' mod':''} in path`.trim()||`${inPath.length} level${inPath.length>1?'s':''} in path`;
  return{score,detail,obstacles,items};
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  GRAB DETECTION HELPERS
//  isGrabCandle: spike with wick >60% of range, body stays near level
//  volumeAsymmetry: follow-through vol < 60% of approach = suspect
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function isGrabCandle(candle,levelPrice,dir){
  const totalRange=candle.h-candle.l||0.01;
  const bodyTop=Math.max(candle.o,candle.c);
  const bodyBot=Math.min(candle.o,candle.c);
  if(dir==='CALL'){
    // Bull grab: wick above level, body closes near or below level
    const wickAbove=candle.h-bodyTop;
    if(wickAbove/totalRange>P.GRAB_BODY_THRESH&&bodyTop<levelPrice+0.20) return true;
  } else {
    // Bear grab: wick below level, body closes near or above level
    const wickBelow=bodyBot-candle.l;
    if(wickBelow/totalRange>P.GRAB_BODY_THRESH&&bodyBot>levelPrice-0.20) return true;
  }
  return false;
}

function volumeAsymmetryWeak(c5,n=2){
  const approach=c5.slice(-(n+3),-n);
  const followThru=c5.slice(-n);
  if(!approach.length||!followThru.length) return false;
  const avgApproach=approach.reduce((a,c)=>a+c.v,0)/approach.length;
  const avgFollow=followThru.reduce((a,c)=>a+c.v,0)/followThru.length;
  return avgFollow<avgApproach*P.GRAB_VOL_RATIO;
}

// Per-scan: invalidate any cleared level where price has returned past it
function invalidateStaleClears(c5){
  const L=c5.at(-1);
  for(const cm of gexLevelState.clearedMajors){
    const returnedPast=cm.dir==='CALL'?(L.c<cm.price-P.GRAB_INVALIDATE):(L.c>cm.price+P.GRAB_INVALIDATE);
    if(returnedPast&&!cm.grabSuspected){
      cm.grabSuspected=true;
      cm.grabAt=Date.now();
      // increment rejection count on the underlying support anchor if found
      const anchor=gexLevelState.supportAnchors.find(s=>Math.abs(s.price-cm.price)<0.5);
      if(anchor){anchor.rejectionCount=(anchor.rejectionCount||0)+1;}
    }
  }
  for(const cm of gexLevelState.clearedModerates){
    const returnedPast=cm.dir==='CALL'?(L.c<cm.price-P.GRAB_INVALIDATE):(L.c>cm.price+P.GRAB_INVALIDATE);
    if(returnedPast&&!cm.grabSuspected){
      cm.grabSuspected=true;
      cm.grabAt=Date.now();
      const anchor=gexLevelState.supportAnchors.find(s=>Math.abs(s.price-cm.price)<0.5);
      if(anchor){anchor.rejectionCount=(anchor.rejectionCount||0)+1;}
    }
  }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  POLYGON WEBSOCKET â€” TICK-LEVEL CUMULATIVE DELTA
//  Uses Polygon.io WebSocket (wss://socket.polygon.io/stocks) which
//  is available on paid plans and has no CORS restrictions.
//  Subscribes to T.SPY (trades) â€” every print with price + size.
//  Cumulative delta: uptick = +1, downtick = -1, rolling 120-tick window.
//  Surge detection: â‰¥72% same direction in last 30+ ticks = inflection.
//  No Cloudflare Worker needed â€” direct browser WebSocket.
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
let polyWS=null;

async function initTradierStream(){
  // Entry point name kept for compatibility â€” now uses Polygon WebSocket
  if(!K.poly) return;
  connectDeltaStream();
}

function connectDeltaStream(){
  if(polyWS){try{polyWS.close();}catch(e){} polyWS=null;}
  try{
    polyWS=new WebSocket('wss://socket.polygon.io/stocks');

    polyWS.onopen=()=>{
      // Authenticate
      polyWS.send(JSON.stringify({action:'auth',params:K.poly}));
    };

    polyWS.onmessage=(e)=>{
      try{
        const msgs=JSON.parse(e.data);
        for(const msg of msgs){
          if(msg.ev==='status'&&msg.status==='auth_success'){
            // Subscribe to SPY trades after auth
            polyWS.send(JSON.stringify({action:'subscribe',params:'T.SPY'}));
            CON.stream=true;
            deltaConnectAttempts=0;
            console.log('Polygon delta stream connected');
          } else if(msg.ev==='status'&&msg.status==='auth_failed'){
            console.warn('Polygon WS auth failed');
            CON.stream=false;
            polyWS.close();
          } else if(msg.ev==='T'&&msg.sym==='SPY'){
            // Trade event: p=price, s=size
            processDeltaTick(+msg.p, +msg.s||100);
          }
        }
      }catch(err){}
    };

    polyWS.onerror=()=>{
      CON.stream=false;
    };

    polyWS.onclose=()=>{
      CON.stream=false;
      deltaConnectAttempts++;
      if(deltaConnectAttempts<5){
        setTimeout(()=>connectDeltaStream(),
          Math.min(5000*Math.pow(2,deltaConnectAttempts-1),60000));
      }
    };
  }catch(e){
    console.warn('Polygon WS init failed:',e.message);
    CON.stream=false;
  }
}

async function reconnectDeltaStream(){
  connectDeltaStream();
}

function processDeltaTick(tickPrice, tickSize){
  const ts=Date.now();
  let dir=0;
  if(deltaLastPrice>0){
    if(tickPrice>deltaLastPrice) dir=1;       // uptick = buying aggression
    else if(tickPrice<deltaLastPrice) dir=-1; // downtick = selling aggression
    // zero = same price = inherit last direction (most platforms do this)
    else dir=deltaTicks.length?deltaTicks.at(-1).dir:0;
  }
  deltaLastPrice=tickPrice;
  if(dir===0) return; // skip flat ticks at open

  deltaRunning+=dir;
  deltaTicks.push({price:tickPrice,dir,ts,size:tickSize});

  // Keep rolling window
  if(deltaTicks.length>P.DELTA_TICK_WINDOW) deltaTicks.shift();

  // Detect inflection surge
  detectDeltaSurge();
}

function detectDeltaSurge(){
  if(deltaTicks.length<P.DELTA_SURGE_MIN_TICKS) return;
  const window=deltaTicks.slice(-P.DELTA_SURGE_MIN_TICKS);
  const ups=window.filter(t=>t.dir>0).length;
  const dns=window.filter(t=>t.dir<0).length;
  const total=ups+dns||1;
  const upRatio=ups/total;
  const dnRatio=dns/total;

  if(upRatio>=P.DELTA_SURGE_THRESH){
    deltaInflection={dir:'CALL',strength:upRatio,ts:Date.now(),
      detail:`${Math.round(upRatio*100)}% buying ticks â€” aggressive demand`};
  } else if(dnRatio>=P.DELTA_SURGE_THRESH){
    deltaInflection={dir:'PUT',strength:dnRatio,ts:Date.now(),
      detail:`${Math.round(dnRatio*100)}% selling ticks â€” aggressive supply`};
  } else if(deltaInflection&&Date.now()-deltaInflection.ts>2*60*1000){
    // Clear stale inflection after 2 minutes of no surge
    deltaInflection=null;
  }
}

// Returns current delta state for scoring
function getDeltaState(){
  if(!CON.stream||deltaTicks.length<10)
    return{active:false,direction:null,strength:0,score:0,
      detail:CON.stream?'Building tick data...':'Polygon WebSocket â€” delta estimated from price',
      running:0,tickCount:0};

  const recentWindow=deltaTicks.slice(-P.DELTA_SURGE_MIN_TICKS);
  const ups=recentWindow.filter(t=>t.dir>0).length;
  const dns=recentWindow.filter(t=>t.dir<0).length;
  const total=ups+dns||1;
  const upRatio=ups/total;
  const surge=deltaInflection&&Date.now()-deltaInflection.ts<2*60*1000;

  const dir=surge?deltaInflection.dir:upRatio>0.55?'CALL':upRatio<0.45?'PUT':null;
  const strength=surge?deltaInflection.strength:Math.max(upRatio,1-upRatio);
  const score=surge?Math.round(strength*P.DELTA_SURGE_MAX):
    dir?Math.round((strength-0.5)*2*P.DELTA_SURGE_MAX*0.5):0;

  return{active:!!dir&&score>=8,direction:dir,strength,score:Math.max(0,score),
    detail:surge?deltaInflection.detail:`Delta ${Math.round(upRatio*100)}% bull / ${Math.round((1-upRatio)*100)}% bear Â· ${deltaTicks.length} ticks`,
    running:deltaRunning,tickCount:deltaTicks.length,surge};
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  GAMMA FLIP TRANSITION TRACKER
//  Detects when price crosses the gamma flip level (posGEX changes).
//  Logs event with timestamp and provides gate score bonus that decays
//  over GEX_FLIP_LOOKBACK candles.
//  Flip toward NEGATIVE GEX (suppression â†’ amplification) = larger bonus.
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function trackGammaFlip(posGEX, flipLevel){
  if(prevPosGEX===null){prevPosGEX=posGEX; return;}
  if(posGEX!==prevPosGEX){
    // Flip detected
    gexFlipEvents.push({
      ts:Date.now(),
      price:price,
      flipLevel,
      toNegative:!posGEX,   // true = flipped into negative gamma (amplification starts)
      toPositive:posGEX,    // true = flipped into positive gamma (suppression resumes)
      candleIndex:c5.length
    });
    // Keep last 5 flips this session
    if(gexFlipEvents.length>5) gexFlipEvents.shift();
    prevPosGEX=posGEX;
  }
}

function getFlipBonus(c5len){
  if(!gexFlipEvents.length) return{bonus:0,detail:''};
  const recent=gexFlipEvents.at(-1);
  const candlesAgo=c5len-recent.candleIndex;
  if(candlesAgo>P.GEX_FLIP_LOOKBACK) return{bonus:0,detail:''};

  // Decay: full bonus on flip candle, reduces each candle after
  const decay=candlesAgo*P.GEX_FLIP_DECAY;
  const rawBonus=recent.toNegative?P.GEX_FLIP_BONUS:Math.round(P.GEX_FLIP_BONUS*0.6);
  const bonus=Math.max(0, rawBonus-decay);
  const detail=recent.toNegative?
    `Gamma flip â†’ NEGATIVE ${candlesAgo===0?'now':candlesAgo+'c ago'} â€” volatility amplification begins`:
    `Gamma flip â†’ POSITIVE ${candlesAgo===0?'now':candlesAgo+'c ago'} â€” suppression resumes`;
  return{bonus,detail,toNegative:recent.toNegative,candlesAgo};
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  VWAP GATE â€” alternative gate when GEX is in FLOAT
//  Activates when price tests VWAP (within $0.35) and flow/delta confirm.
//  Weaker structural anchor than GEX wall â†’ max score 65 (vs 100).
//  Delta surge at VWAP adds +15 â€” this is the "ignition" signal.
//  Gamma flip near VWAP is the highest-conviction VWAP setup possible.
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function scoreVWAPGate(c5,fl,gexGate){
  // Only activate when GEX gate is in FLOAT (no major nearby)
  if(gexGate&&gexGate.zone!=='FLOAT') return null;
  if(c5.length<5) return null;

  const L=c5.at(-1),prev=c5.at(-2);
  const vwv=vwap(c5).at(-1).v;
  const distToVWAP=Math.abs(L.c-vwv);

  // Must be testing VWAP
  if(distToVWAP>P.VWAP_GATE_PROX) return null;

  let gs=0;
  const items=[];

  // Base score from proximity â€” closer = more meaningful test
  const proxPct=1-(distToVWAP/P.VWAP_GATE_PROX);
  gs+=Math.round(20+proxPct*15);

  // Direction: is price approaching from below (CALL) or above (PUT)?
  const aboveVWAP=L.c>vwv;
  const prevAbove=prev.c>vwv;
  let dir=null;

  if(!aboveVWAP&&prevAbove){
    // Just crossed below VWAP â€” potential PUT setup (failed to hold)
    dir='PUT'; gs+=10;
    items.push(`VWAP breakdown â€” crossed below $${vwv.toFixed(2)}`);
  } else if(aboveVWAP&&!prevAbove){
    // Just crossed above VWAP â€” potential CALL setup (reclaim)
    dir='CALL'; gs+=10;
    items.push(`VWAP reclaim â€” crossed above $${vwv.toFixed(2)}`);
  } else if(aboveVWAP){
    // Testing from above â€” CALL (holding VWAP as support)
    dir='CALL'; gs+=6;
    items.push(`Testing VWAP from above $${vwv.toFixed(2)} â€” support hold`);
  } else {
    // Testing from below â€” PUT (VWAP as resistance)
    dir='PUT'; gs+=6;
    items.push(`Testing VWAP from below $${vwv.toFixed(2)} â€” resistance test`);
  }

  // Delta surge at VWAP â€” the ignition signal
  const delta=getDeltaState();
  if(delta.active&&delta.direction===dir&&delta.surge){
    gs+=P.VWAP_DELTA_BOOST;
    items.push(`âœ“ Delta surge ${delta.direction} â€” aggressive order flow at VWAP`);
  } else if(delta.active&&delta.direction===dir){
    gs+=8;
    items.push(`Delta confirms ${delta.direction} at VWAP`);
  } else if(delta.active&&delta.direction!==dir){
    gs-=10;
    items.push(`âš  Delta contradicts â€” ${delta.direction} flow fighting VWAP test`);
  } else {
    items.push(`Delta: ${delta.detail}`);
  }

  // Gamma flip near VWAP â€” highest conviction VWAP setup
  const flip=getFlipBonus(c5.length);
  if(flip.bonus>0){
    gs+=Math.min(flip.bonus,12); // cap flip bonus inside VWAP gate
    items.push(`âœ“ ${flip.detail}`);
  }

  // Flow alignment
  const flowDir=fl&&fl.length?(()=>{
    const cs=fl.filter(f=>f.type==='CALL').reduce((a,b)=>a+b.premium,0);
    const ps=fl.filter(f=>f.type==='PUT').reduce((a,b)=>a+b.premium,0);
    const r=cs/(cs+ps||1);
    return r>0.60?'CALL':r<0.40?'PUT':null;
  })():null;
  if(flowDir===dir){gs+=8;items.push('Flow confirms VWAP direction');}
  else if(flowDir&&flowDir!==dir){gs-=6;items.push('âš  Flow contradicts VWAP direction');}

  // DEX confirmation
  const dex=fl&&fl.length?computeDEX(fl):{direction:null,strong:false};
  if(dex.direction&&dex.strong){
    if(dex.direction===dir){gs+=8;items.push(`DEX confirms â€” dealer delta supports ${dir}`);}
    else{gs-=6;items.push('âš  DEX contradicts VWAP direction');}
  }

  gs=Math.min(gs,P.VWAP_GATE_MAX);
  const active=gs>=P.VWAP_GATE_MIN&&dir!==null;
  if(!active) return null;

  return{active,direction:dir,gateScore:gs,score:gs,zone:'VWAP_TEST',
    detail:`VWAP ${dir==='CALL'?'support':'resistance'} $${vwv.toFixed(2)} Â· $${distToVWAP.toFixed(2)} away${delta.surge?' Â· DELTA SURGE':''}`,
    subItems:items,entry:L.c,
    target:dir==='CALL'?L.c+P.LVL_TGT:L.c-P.LVL_TGT,
    stop:dir==='CALL'?L.c-P.LVL_STOP:L.c+P.LVL_STOP,
    levelName:'VWAP',levelPrice:vwv,posGEX:null,isBreakout:false,dex,
    vwapPrice:vwv,deltaState:delta,flipBonus:flip.bonus>0};
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  SCALED CONTRIBUTION HELPERS
//  Each function returns a value that can be NEGATIVE when the
//  component actively contradicts the signal direction.
//  Negative = real evidence against the trade, not just "no help".
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// Momentum: -25 to +40
// Contra penalty scales by: how strong is the opposing structure?
// How far is price from the 8 EMA? (striking distance = smaller penalty)
function scaledMomContrib(mom, dir){
  if(!mom||!mom.direction) return 0;
  if(mom.direction===dir){
    // Aligned â€” positive contribution (existing logic preserved)
    const aligned=mom.active;
    const partial=!mom.active&&mom.score>25;
    return aligned?Math.round(mom.score/100*P.APEX_MOM_MAX):
           partial?Math.round(mom.score/100*P.APEX_MOM_MAX*0.5):0;
  }
  // Contrary â€” scaled negative
  const dist=mom.ema8Dist||0;
  const str=mom.score; // 0-100: how strong is the opposing structure
  // Base penalty by opposing strength
  let penalty;
  if(str>70) penalty=-22;
  else if(str>50) penalty=-18;
  else if(str>30) penalty=-12;
  else penalty=-5;
  // Distance modifier: close to EMA = striking distance, reduces penalty
  // Far from EMA = extended against signal, increases penalty
  const distMod=dist<0.50?+5:dist<1.50?0:-3;
  const result=Math.max(-25, penalty+distMod);
  return result;
}

// Flow: -20 to +40
// Scaled by how dominant opposing premium is (wRatio-based)
function scaledFlowContrib(flow, dir){
  if(!flow) return 0;
  const ratio=flow.ratio??0.5;
  // sigRatio = fraction of premium in signal direction
  const sigRatio=dir==='CALL'?ratio:1-ratio;
  if(sigRatio>=0.75)
    return Math.round(flow.score/100*P.APEX_FLOW_MAX);        // +40 max
  if(sigRatio>=0.65)
    return Math.round(flow.score/100*P.APEX_FLOW_MAX*0.70);   // ~+28 max
  if(sigRatio>=0.55)
    return Math.round(flow.score/100*P.APEX_FLOW_MAX*0.40);   // ~+16 max
  if(sigRatio>=0.45) return 0;                                 // neutral
  if(sigRatio>=0.35) return -8;                                // mild opposing
  if(sigRatio>=0.25) return -14;                               // moderate opposing
  return -20;                                                   // strong opposing
}

// Delta: -20 to +25
// Sustained opposing surge hurts more than a brief contrary blip
function scaledDeltaScore(delta, dir){
  if(!delta||!delta.direction) return 0;
  if(delta.direction===dir) return Math.max(0,delta.score);
  // Opposing: scale by surge strength and tick count
  if(delta.surge&&delta.tickCount>=60) return -20;  // sustained opposing surge
  if(delta.surge) return -14;                        // brief opposing surge
  if(delta.score>=8) return -8;                      // mild lean opposing
  return 0;                                          // not meaningful enough
}

// â”€â”€ APEX ENGINE â€” GEX gate required; Momentum + Flow are additive boosters
// Architecture:
//   Primary gate: GEX Gate (0â€“100) â€” required when active
//   Fallback gate: VWAP Gate (0â€“65) â€” activates when GEX is in Float
//   momBoost   (0â€“40)  = Momentum booster
//   flowBoost  (0â€“40)  = Flow booster
//   velScore   (-15â€“30)= Velocity
//   pathScore  (-20â€“15)= Path cleanliness
//   deltaScore (0â€“25)  = Cumulative delta surge (Tradier stream)
//   flipBonus  (0â€“18)  = Gamma flip transition event
//
//   Threshold adjusts by regime:
//     TRENDING â†’ 100  MIXED â†’ 112  RANGE â†’ 128
//   Blackout: 9:30â€“10am and 3:30â€“4pm ET
let lastApexFiredAt=0,lastApexKey='';
function detectApex(mom,gate,flow,regime,vwapGate){
  if(isBlackout()) return null;
  const activeGate=(gate.active?gate:null)||(vwapGate&&vwapGate.active?vwapGate:null);
  if(!activeGate) return null;

  const thresh=regime==='TRENDING'?P.APEX_CONF_TRENDING:
                regime==='RANGE'?P.APEX_CONF_RANGE:P.APEX_CONF_MIXED;
  const delta=getDeltaState();
  const flip=getFlipBonus(c5.length);

  for(const dir of['CALL','PUT']){
    if(activeGate.direction!==dir) continue;
    const gateScore=activeGate.gateScore||0;

    const momBoost=scaledMomContrib(mom,dir);
    const flowBoost=scaledFlowContrib(flow,dir);
    const deltaScore=scaledDeltaScore(delta,dir);
    const flipScore=flip.bonus>0?(flip.toNegative?flip.bonus:Math.round(flip.bonus*0.6)):0;

    // Still require at least one booster contributing positively
    if(Math.max(momBoost,0)+Math.max(flowBoost,0)<10) continue;

    const vel=scoreVelocity(c5,dir);
    const path=scorePath(activeGate,dir);

    const composite=gateScore+momBoost+flowBoost+vel.score+path.score+deltaScore+flipScore;
    if(composite<thresh) continue;

    const key=`${dir}-${Math.round(price/2)*2}`;
    if(key===lastApexKey&&Date.now()-lastApexFiredAt<5*60*1000) continue;

    const entry=activeGate.entry;
    const target=dir==='CALL'?entry+P.APEX_TGT_MOVE:entry-P.APEX_TGT_MOVE;
    const stop=dir==='CALL'?entry-P.APEX_STOP_BUF:entry+P.APEX_STOP_BUF;
    const t=new Date().toLocaleTimeString('en-US',{hour:'2-digit',minute:'2-digit'});
    const boosts=[];
    if(momBoost>0) boosts.push(`Mom +${momBoost}`);
    else if(momBoost<0) boosts.push(`Mom ${momBoost}`);
    if(flowBoost>0) boosts.push(`Flow +${flowBoost}`);
    else if(flowBoost<0) boosts.push(`Flow ${flowBoost}`);
    if(vel.score>0) boosts.push(`Vel +${vel.score}`);
    if(deltaScore>0) boosts.push(`Î” +${deltaScore}`);
    else if(deltaScore<0) boosts.push(`Î” ${deltaScore}`);
    if(flipScore>0) boosts.push(`Flip +${flipScore}`);
    const gateType=activeGate===vwapGate?'VWAP':'GEX';
    const fmt=n=>n>0?`+${n}`:String(n);
    return{id:Date.now(),type:dir,isApex:true,conf:composite,price:entry,target,stop,
      strike:Math.round(entry),expiry:'1DTE',time:t,
      gateScore,momBoost,flowBoost,velScore:vel.score,pathScore:path.score,
      deltaScore,flipScore,gateType,
      momScore:mom.score,flowScore:flow.score,
      regime,thresh,
      // Lifecycle fields
      state:'ACTIVE', firedAt:Date.now(), firedPrice:entry,
      currentComp:composite, degradeDetail:null, resolvedAt:null,
      boosts,
      detail:`${gateType} ${gateScore} + Mom ${fmt(momBoost)} + Flow ${fmt(flowBoost)} + Vel ${fmt(vel.score)} + Path ${fmt(path.score)} + Î” ${fmt(deltaScore)} + Flip +${flipScore} = ${composite}`,
      rule:'â˜… APEX',levelName:activeGate.levelName||'â€”',
      zone:activeGate.zone,isBreakout:activeGate.isBreakout,
      velDetail:vel.detail,pathDetail:path.detail,
      timeWindow:vel.timeWindow,pathObstacles:path.obstacles.length,
      deltaDetail:delta.detail,flipDetail:flip.detail};
  }
  return null;
}

function apexComposite(gate,mom,flow,dir,regime,vwapGate){
  // Use best available gate â€” prefer active gate, fall back to inactive gate for display
  const activeGate=(gate&&gate.active?gate:null)||(vwapGate&&vwapGate.active?vwapGate:null);
  const anyGate=activeGate||gate||vwapGate;
  if(!anyGate) return 0;
  const d=dir||anyGate.direction;
  if(!d||!anyGate.direction||anyGate.direction!==d) return 0;
  const gs=anyGate.gateScore||0;
  const mb=scaledMomContrib(mom,d);
  const fb=scaledFlowContrib(flow,d);
  const vel=scoreVelocity(c5,d);
  const path=scorePath(anyGate,d);
  const delta=getDeltaState();
  const deltaScore=scaledDeltaScore(delta,d);
  const flip=getFlipBonus(c5.length);
  const flipScore=flip.bonus>0?(flip.toNegative?flip.bonus:Math.round(flip.bonus*0.6)):0;
  return gs+mb+fb+vel.score+path.score+deltaScore+flipScore;
}

function apexThreshold(regime){
  return regime==='TRENDING'?P.APEX_CONF_TRENDING:
         regime==='RANGE'?P.APEX_CONF_RANGE:P.APEX_CONF_MIXED;
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  API INTEGRATIONS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// POLYGON
function tradingDate(){const n=new Date(),d=n.getDay(),dt=new Date(n);dt.setDate(dt.getDate()-(d===6?1:d===0?2:0));return dt.toISOString().split('T')[0];}
function isMarket(){const et=new Date(new Date().toLocaleString('en-US',{timeZone:'America/New_York'})),d=et.getDay(),m=et.getHours()*60+et.getMinutes();return d>=1&&d<=5&&m>=570&&m<960;}
async function polyGet(path){const r=await fetch(`https://api.polygon.io${path}${path.includes('?')?'&':'?'}apiKey=${K.poly}`);const d=await r.json();if(d.status==='ERROR'||d.status==='FORBIDDEN')throw new Error(d.error||'Polygon error');return d;}
async function fetchPolygon(){
  const td=tradingDate();
  const ago30=(()=>{const d=new Date(td);d.setDate(d.getDate()-30);return d.toISOString().split('T')[0]})();
  const ago5=(()=>{const d=new Date(td);d.setDate(d.getDate()-5);return d.toISOString().split('T')[0]})();
  const[r5,r15,rq,rvx]=await Promise.all([
    polyGet(`/v2/aggs/ticker/SPY/range/5/minute/${td}/${td}?adjusted=true&sort=asc&limit=500`),
    polyGet(`/v2/aggs/ticker/SPY/range/15/minute/${ago30}/${td}?adjusted=true&sort=asc&limit=500`),
    polyGet('/v2/snapshot/locale/us/markets/stocks/tickers/SPY'),
    polyGet('/v2/snapshot/locale/us/markets/stocks/tickers/VXX').catch(()=>null),
  ]);
  if(!r5.results?.length) throw new Error('No 5m data â€” market may be closed');
  c5=r5.results.map(r=>({t:r.t,o:r.o,h:r.h,l:r.l,c:r.c,v:r.v}));
  const raw15=r15.results?.map(r=>({t:r.t,o:r.o,h:r.h,l:r.l,c:r.c,v:r.v}))||[];

  // â”€â”€ Synthesize the current in-progress 15m candle from 5m data
  // 15m bars align to: 9:30, 9:45, 10:00, 10:15... (every 15 min from open)
  // Find which 5m candles belong to the current incomplete 15m period
  if(c5.length){
    const lastComplete15t=raw15.length?raw15.at(-1).t:0;
    const inProgress=c5.filter(c=>c.t>lastComplete15t);
    if(inProgress.length){
      const synth={
        t:inProgress[0].t,
        o:inProgress[0].o,
        h:Math.max(...inProgress.map(c=>c.h)),
        l:Math.min(...inProgress.map(c=>c.l)),
        c:inProgress.at(-1).c,
        v:inProgress.reduce((a,c)=>a+c.v,0),
        synthetic:true
      };
      c15=[...raw15,synth];
    } else {
      c15=raw15;
    }
  } else {
    c15=raw15;
  }

  const sn=rq.ticker; price=sn.day?.c||sn.prevDay?.c||price; chg=sn.todaysChange||0;
  meta={open:sn.day?.o||0,high:sn.day?.h||0,low:sn.day?.l||0,vol:sn.day?.v||0};
  if(rvx?.ticker){const vx=rvx.ticker.day?.c||0;const el=document.getElementById('sb-vix');el.textContent=vx.toFixed(2);el.style.color=vx>25?'#ef4444':vx>18?'#f59e0b':'#10b981';}
  src='live';
}

// UNUSUAL WHALES â€” accumulate flow across refreshes, deduplicated
// flowHistory stores all prints seen this session for 30-day positional scoring
let flowHistory=[];

async function fetchUW(){
  if(!K.uw) return;
  try{
    const res=await fetch('https://api.unusualwhales.com/api/option-trades/flow-alerts?ticker=SPY&limit=500',{headers:{'Authorization':`Bearer ${K.uw}`,'Accept':'application/json'}});
    if(!res.ok) throw new Error(`UW ${res.status}`);
    const d=await res.json(), trades=d.data||d||[];
    const parsed=trades.map(t=>{
      const ot=(t.type||'').toLowerCase();
      const type=(ot==='call')?'CALL':'PUT';
      const exDate=t.expiry?new Date(t.expiry):null;
      const daysToExp=exDate?Math.max(0,Math.round((exDate-new Date())/(1000*60*60*24))):null;
      return{
        id:t.id||`${t.created_at}-${t.strike}-${t.type}`,
        ts:new Date(t.created_at||Date.now()).getTime(),
        time:new Date(t.created_at||Date.now()).toLocaleTimeString('en-US',{hour:'2-digit',minute:'2-digit'}),
        type,strike:+t.strike||0,expiry:t.expiry||'',
        daysToExp,  // null if no expiry, 0 = 0DTE, 1 = 1DTE, etc.
        premium:+t.total_premium||0,size:+t.total_size||+t.volume||0,
        sentiment:type==='CALL'?'bullish':'bearish',
        sweep:!!(t.has_sweep||false),
      };
    }).filter(t=>{
      if(t.premium<P.SWEEP_MIN_PREM) return false;
      if(t.strike&&price>0&&Math.abs(t.strike-price)>price*0.20) return false;
      return true;
    });
    // Deduplicate into history by id â€” keeps growing until page refresh
    const existingIds=new Set(flowHistory.map(f=>f.id));
    const newPrints=parsed.filter(f=>!existingIds.has(f.id));
    flowHistory=[...flowHistory,...newPrints];
    // Trim to last 30 days to prevent unbounded growth
    const cutoff30=Date.now()-30*24*60*60*1000;
    flowHistory=flowHistory.filter(f=>f.ts>=cutoff30);
    // uwFlow = what we show in the flow tab (last 500 by time)
    uwFlow=[...flowHistory].sort((a,b)=>b.ts-a.ts).slice(0,500);
    CON.uw=true;
    setBadge('flow-src',`UW LIVE (${flowHistory.length} prints)`,'#10b98122','#10b981','#10b98144');
    document.getElementById('flow-updated').textContent='Updated '+new Date().toLocaleTimeString();
    renderFlow(); updateDots();
    applyFlowGEX();
  }catch(e){console.warn('UW:',e.message);}
}

// FLOW-BASED GEX PROXY
// Architecture:
//   PRIMARY  = 0DTE prints (explosive gamma â€” today's actual dealer pins)
//   MODIFIER = 1DTE prints (agree/disagree flag, + blended into primary last hour)
//   FALLBACK = 1DTE as primary when 0DTE is thin (<3 qualifying prints)
//
// Last hour (â‰¥3pm ET): 1DTE blends into primary computation because those
// contracts will BE the 0DTE tomorrow and dealers start adjusting hedges.
//
// Agreement check: compare 0DTE and 1DTE flip sides and wall proximity.
//   AGREE   â†’ confidence boost, badge shows âœ“
//   DISAGREEâ†’ warning flag, badge shows âš , scoreLevelReaction docks points
let gexLastRefresh=null, gexDataValid=false;
let gex1dteAgreement=null; // null | 'agree' | 'disagree' | 'nodata'

function etHour(){
  return new Date(new Date().toLocaleString('en-US',{timeZone:'America/New_York'})).getHours();
}
function isLastHour(){
  return etHour()>=P.FLOW_GEX_LAST_HOUR_START; // â‰¥3pm ET
}

// Compute walls+flip from a set of filtered prints
function _gexFromPrints(prints, spyP){
  const band=spyP*P.FLOW_GEX_STRIKE_PCT;
  const relevant=prints.filter(f=>
    f.premium>=P.FLOW_GEX_MIN_PREM &&
    f.strike && Math.abs(f.strike-spyP)<=band
  );
  if(relevant.length<1) return null;
  const byStrike={};
  for(const f of relevant){
    if(!byStrike[f.strike]) byStrike[f.strike]={calls:0,puts:0};
    if(f.type==='CALL') byStrike[f.strike].calls+=f.premium;
    else byStrike[f.strike].puts+=f.premium;
  }
  const strikes=Object.keys(byStrike).map(Number).sort((a,b)=>a-b);
  if(strikes.length<2) return null;
  const cwall=strikes.reduce((best,s)=>byStrike[s].calls>byStrike[best].calls?s:best,strikes[0]);
  const pwall=strikes.reduce((best,s)=>byStrike[s].puts>byStrike[best].puts?s:best,strikes[0]);
  let cum=0,flip=strikes[Math.floor(strikes.length/2)];
  for(let i=0;i<strikes.length;i++){
    const prev=cum; cum+=byStrike[strikes[i]].calls-byStrike[strikes[i]].puts;
    if(prev<0&&cum>=0){flip=strikes[i];break;}
  }
  return{cwall,pwall,flip,prints:relevant.length,strikes:strikes.length,byStrike};
}

function computeFlowGEX(){
  const spyP=price||P.GEX_FLIP;
  const zdte=uwFlow.filter(f=>f.daysToExp===0);
  const odte=uwFlow.filter(f=>f.daysToExp===1);

  const r0=_gexFromPrints(zdte,spyP);
  const r1=_gexFromPrints(odte,spyP);
  const have0=r0&&r0.prints>=P.FLOW_GEX_0DTE_MIN;
  const have1=r1&&r1.prints>=P.FLOW_GEX_1DTE_MIN;

  // Determine agreement between 0DTE and 1DTE
  let agreement='nodata';
  if(have0&&have1){
    const flipSame=(r0.flip>spyP)===(r1.flip>spyP); // same side of price
    const cwallClose=Math.abs(r0.cwall-r1.cwall)<3.0;
    const pwallClose=Math.abs(r0.pwall-r1.pwall)<3.0;
    agreement=(flipSame&&cwallClose&&pwallClose)?'agree':'disagree';
  } else if(have1&&!have0){
    agreement='nodata'; // only 1DTE data, no comparison possible
  }
  gex1dteAgreement=agreement;

  // Primary computation
  let primary=null, source='';
  if(have0&&!isLastHour()){
    // Standard: 0DTE only
    primary=r0; source='0DTE';
  } else if(have0&&isLastHour()&&have1){
    // Last hour: blend 1DTE into 0DTE â€” gives forward-looking level set
    // Weight: 0DTE 60%, 1DTE 40% in last hour
    const blended={};
    const w0=0.60, w1=0.40;
    const allStrikes=new Set([...Object.keys(r0.byStrike),...Object.keys(r1.byStrike)].map(Number));
    for(const s of allStrikes){
      const d0=r0.byStrike[s]||{calls:0,puts:0};
      const d1=r1.byStrike[s]||{calls:0,puts:0};
      blended[s]={
        calls:d0.calls*w0+d1.calls*w1,
        puts: d0.puts*w0 +d1.puts*w1,
      };
    }
    const bStrikes=Object.keys(blended).map(Number).sort((a,b)=>a-b);
    const bcwall=bStrikes.reduce((best,s)=>blended[s].calls>blended[best].calls?s:best,bStrikes[0]);
    const bpwall=bStrikes.reduce((best,s)=>blended[s].puts>blended[best].puts?s:best,bStrikes[0]);
    let bcum=0,bflip=bStrikes[Math.floor(bStrikes.length/2)];
    for(let i=0;i<bStrikes.length;i++){
      const prev=bcum; bcum+=blended[bStrikes[i]].calls-blended[bStrikes[i]].puts;
      if(prev<0&&bcum>=0){bflip=bStrikes[i];break;}
    }
    primary={cwall:bcwall,pwall:bpwall,flip:bflip,
      prints:r0.prints+r1.prints,strikes:bStrikes.length,byStrike:blended};
    source='0DTE+1DTE blend';
  } else if(have0){
    // Last hour but no 1DTE data â€” 0DTE only
    primary=r0; source='0DTE';
  } else if(have1){
    // Fallback: 0DTE thin, use 1DTE
    primary=r1; source='1DTE (fallback)';
  } else {
    return null; // no usable data
  }

  return{...primary, source, agreement, r1DTE:r1};
}

function applyFlowGEX(){
  const spyP=price||P.GEX_FLIP;
  const result=computeFlowGEX();
  if(!result){
    gexDataValid=false;
    setBadge('gex-src','GEX: BUILDING','#f59e0b22','#f59e0b','#f59e0b44');
    const nextEl=document.getElementById('gex-next');
    const z=uwFlow.filter(f=>f.daysToExp===0&&f.premium>=P.FLOW_GEX_MIN_PREM).length;
    const o=uwFlow.filter(f=>f.daysToExp===1&&f.premium>=P.FLOW_GEX_MIN_PREM).length;
    if(nextEl) nextEl.textContent=`Â· 0DTE: ${z} prints Â· 1DTE: ${o} prints Â· Need ${P.FLOW_GEX_0DTE_MIN}+ to compute`;
    return;
  }

  P.GEX_FLIP=result.flip; P.GEX_CWALL=result.cwall; P.GEX_PWALL=result.pwall;
  trackGEXVelocity(result.cwall,result.pwall,result.flip);
  gexLastRefresh=new Date(); gexDataValid=true;

  const res2dist=Math.round((result.cwall-result.flip)*0.4)||3;
  const sup2dist=Math.round((result.flip-result.pwall)*0.4)||3;

  // Store agreement on sgGEX so scoreLevelReaction can use it
  sgGEX={
    flipLevel:result.flip,
    keyLevels:[
      {price:result.cwall,         gex:2.8,  type:'call wall'},
      {price:result.flip+res2dist, gex:1.5,  type:'resistance'},
      {price:spyP,                 gex:0.3,  type:'current'},
      {price:result.flip,          gex:0,    type:'gamma flip'},
      {price:result.flip-sup2dist, gex:-1.3, type:'support'},
      {price:result.pwall,         gex:-2.5, type:'put wall'},
    ],
    source:result.source,
    agreement:result.agreement,
    r1DTE:result.r1DTE,
    isLastHour:isLastHour(),
  };

  CON.sg=true;

  // Badge: show source + agreement flag
  const agrStr=result.agreement==='agree'?'âœ“ 1DTE agrees':
    result.agreement==='disagree'?'âš  1DTE disagrees':
    result.source.includes('fallback')?'fallback':'';
  const badgeColor=result.agreement==='disagree'?'#f59e0b':'#10b981';
  const badgeText=`FLOW GEX Â· ${result.source}${agrStr?' Â· '+agrStr:''}`;
  setBadge('gex-src',badgeText,`${badgeColor}22`,badgeColor,`${badgeColor}44`);

  const nextEl=document.getElementById('gex-next');
  if(nextEl){
    const z=uwFlow.filter(f=>f.daysToExp===0&&f.premium>=P.FLOW_GEX_MIN_PREM).length;
    const o=uwFlow.filter(f=>f.daysToExp===1&&f.premium>=P.FLOW_GEX_MIN_PREM).length;
    nextEl.textContent=`Â· 0DTE: ${z} Â· 1DTE: ${o} Â· ${result.prints} total Â· ${gexLastRefresh.toLocaleTimeString('en-US',{hour:'2-digit',minute:'2-digit'})}`;
  }
  renderGEX(); updateDots();
}

// Keep fetchUWGex as a no-op alias â€” flow GEX runs via applyFlowGEX after fetchUW
async function fetchUWGex(force=false){ applyFlowGEX(); }
// Keep fetchSG as alias so any stray references donâ€™t break
const fetchSG=fetchUWGex;

// DARK POOL â€” fetch significant SPY prints, cluster into S/R levels
async function fetchDarkPool(){
  if(!K.uw) return;
  try{
    const res=await fetch(
      'https://api.unusualwhales.com/api/darkpool/SPY?limit=500',
      {headers:{'Authorization':`Bearer ${K.uw}`,'Accept':'application/json'}}
    );
    if(!res.ok) throw new Error(`DP ${res.status}`);
    const json=await res.json();
    const trades=(json.data||json||[]);
    const sig=trades.filter(t=>+(t.premium||0)>=P.DP_MIN_PREMIUM||+(t.size||0)>=50000);
    const clusters=[];
    for(const t of sig){
      const p=+(t.price||0); if(!p) continue;
      const ex=clusters.find(c=>Math.abs(c.price-p)<1.00);
      if(ex){
        ex.totalPremium+=+(t.premium||0);
        ex.totalSize+=+(t.size||0);
        ex.count++;
        ex.price=parseFloat(((ex.price*(ex.count-1)+p)/ex.count).toFixed(2));
      } else {
        clusters.push({price:p,totalPremium:+(t.premium||0),totalSize:+(t.size||0),count:1});
      }
    }
    dpLevels=clusters.sort((a,b)=>b.totalPremium-a.totalPremium).slice(0,8);
    if(dpLevels.length) renderDPLevels();
    console.log(`Dark pool: ${dpLevels.length} significant levels loaded`);
  }catch(e){console.warn('Dark pool:',e.message);}
}
function nearDP(p){return dpLevels.find(d=>Math.abs(d.price-p)<P.DP_PROX)||null;}

function applyManualGEX(){
  const flip=+document.getElementById('gex-flip-in').value||P.GEX_FLIP;
  const cwall=+document.getElementById('gex-cwall-in').value||P.GEX_CWALL;
  const pwall=+document.getElementById('gex-pwall-in').value||P.GEX_PWALL;
  P.GEX_FLIP=flip; P.GEX_CWALL=cwall; P.GEX_PWALL=pwall;
  sgGEX={flipLevel:flip,keyLevels:[
    {price:cwall,gex:2.8,type:'call wall'},{price:flip+4,gex:1.4,type:'resistance'},
    {price:price,gex:0.2,type:'current'},{price:flip,gex:0,type:'gamma flip'},
    {price:flip-4,gex:-1.2,type:'support'},{price:pwall,gex:-2.4,type:'put wall'},
  ]};
  setBadge('gex-src','MANUAL','#f59e0b22','#f59e0b','#f59e0b44');
  renderGEX();
}

// TRADIER â€” real options chain for backtest P&L
async function tradierChain(expiry){
  if(!K.trad) return null;
  try{
    const res=await fetch(`https://api.tradier.com/v1/markets/options/chains?symbol=SPY&expiration=${expiry}&greeks=true`,{headers:{'Authorization':`Bearer ${K.trad}`,'Accept':'application/json'}});
    if(!res.ok) throw new Error(`Tradier ${res.status}`);
    const d=await res.json(); return d.options?.option||null;
  }catch(e){console.warn('Tradier:',e.message); return null;}
}
async function tradierMid(dir,strike,expiry){
  const chain=await tradierChain(expiry); if(!chain) return null;
  const opt=chain.find(o=>o.option_type===(dir==='CALL'?'call':'put')&&Math.abs(o.strike-strike)<2.5);
  return opt?((opt.bid+opt.ask)/2):null;
}

// PUSHOVER NOTIFICATIONS
async function sendSMS(body){
  if(!K.ptoken||!K.puser) return false;
  try{
    const res=await fetch('https://api.pushover.net/1/messages.json',{
      method:'POST',
      headers:{'Content-Type':'application/x-www-form-urlencoded'},
      body:new URLSearchParams({token:K.ptoken,user:K.puser,message:body,title:'SPY Edge'}).toString(),
    });
    const d=await res.json();
    if(d.status===1){CON.push=true;updateDots();return true;}
    return false;
  }catch(e){return false;}
}

function apexSMS(apex){
  const d=new Date().toLocaleDateString('en-US',{month:'short',day:'numeric'});
  return `â˜… APEX FIRED â€” ${d} ${apex.time}\n${apex.type==='CALL'?'ğŸ“ˆ CALL':'ğŸ“‰ PUT'}  $${apex.strike} ${apex.expiry}\nEntry $${apex.price.toFixed(2)}  Conf ${apex.conf}%\nTarget $${apex.target.toFixed(2)} (+${P.APEX_TGT_PCT}%)\nStop   $${apex.stop.toFixed(2)} (-${P.APEX_STOP_PCT}%)\n${(apex.componentSigs||[]).length} signals aligned\nSPY Edge v1.6`;
}

function sendAMBrief(){
  const log=loadLog(),td=todayKey();
  const yd=Object.keys(log).sort().slice(-2,-1)[0];
  const ydDay=yd?log[yd]:{fires:[]};
  const w=ydDay.fires.filter(f=>f.outcome==='win').length,l=ydDay.fires.filter(f=>f.outcome==='loss').length;
  const wr=w+l>0?Math.round(w/(w+l)*100)+'%':'N/A';
  const spyP=price||0;

  // GEX validity block
  let gexBlock;
  if(!gexDataValid){
    gexBlock=`GEX DATA UNAVAILABLE â€” verify UW connection\nLast attempt: ${gexLastRefresh?gexLastRefresh.toLocaleTimeString('en-US',{hour:'2-digit',minute:'2-digit'}):'never'}`;
  } else {
    const flipDist=(spyP-P.GEX_FLIP).toFixed(2);
    const cwDist=(P.GEX_CWALL-spyP).toFixed(2);
    const pwDist=(spyP-P.GEX_PWALL).toFixed(2);
    const regime=spyP>P.GEX_FLIP?'POSITIVE GEX (above flip)':'NEGATIVE GEX (below flip)';
    const refreshed=gexLastRefresh?gexLastRefresh.toLocaleTimeString('en-US',{hour:'2-digit',minute:'2-digit'}):'unknown';
    gexBlock=`GEX Â· ${regime}\nFlip  $${P.GEX_FLIP}  (${flipDist>0?'+':''}${flipDist} from price)\nCWall $${P.GEX_CWALL}  (+${cwDist} away)\nPWall $${P.GEX_PWALL}  (-${pwDist} away)\nRefreshed ${refreshed}`;
  }

  const txt=`â˜… SPY EDGE â€” AM BRIEF\n${new Date().toLocaleDateString('en-US',{weekday:'short',month:'short',day:'numeric'})}\nSPY $${spyP.toFixed(2)}\n\n${gexBlock}\n\nYesterday: ${ydDay.fires.length} APEX fires Â· Win rate ${wr}\n\nPush on every APEX fire. Good luck.`;
  sendSMS(txt).then(ok=>ok?alert('AM Brief sent âœ“'):alert('Push notification failed â€” check Pushover keys in Settings'));
}

function sendSummSMS(){
  const log=loadLog(),td=todayKey(),day=log[td]||{fires:[]};
  const f=day.fires||[],w=f.filter(x=>x.outcome==='win').length,l=f.filter(x=>x.outcome==='loss').length;
  const txt=`â˜… SPY EDGE EVENING\n${td}\n\nAPEX fires: ${f.length}\nWins ${w}  Losses ${l}\nWin rate: ${w+l>0?Math.round(w/(w+l)*100)+'%':'N/A'}\nOpen/unlogged: ${f.filter(x=>x.outcome===null).length}\n\nSee dashboard for full analysis.`;
  sendSMS(txt).then(ok=>ok?alert('Summary sent âœ“'):alert('Push notification failed â€” check Pushover keys'));
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  CONNECT / LAUNCH
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
async function connectAll(){
  const btn=document.getElementById('connect-btn');
  btn.textContent='VALIDATING...'; btn.disabled=true; setErr('');
  try{
    const poly=document.getElementById('k-poly').value.trim();
    if(!poly){setErr('Polygon API key is required.');return;}
    K={poly,uw:g('k-uw'),trad:g('k-trad'),cfWorker:g('k-cfworker'),ptoken:g('k-ptoken'),puser:g('k-puser')};
    try{
      const t=await polyGet('/v2/aggs/ticker/SPY/prev?adjusted=true');
      if(!t.results) throw new Error('No data returned');
      CON.poly=true;
    }catch(e){setErr('Polygon key error: '+e.message);return;}
    localStorage.setItem('sek',JSON.stringify(K));
    await fetchPolygon().catch(()=>{});
    await Promise.all([fetchUW(),fetchDarkPool()]).catch(()=>{});
    if(K.trad){
      btn.textContent='CHECKING TRADIER...';
      try{const c=await tradierChain(tradingDate());if(c)CON.trad=true;}catch(e){}
    }
    // Delta stream via Polygon WebSocket â€” no Worker needed
    btn.textContent='CONNECTING DELTA STREAM...';
    await initTradierStream();
    if(K.ptoken&&K.puser){const ok=await sendSMS('SPY Edge connected âœ“'+(CON.stream?' Â· Î” live':'')+'.');if(ok)CON.push=true;}
    resetGEXState();
    prevPosGEX=null; gexFlipEvents=[];
    deltaRunning=0; deltaTicks=[]; deltaLastPrice=0; deltaInflection=null;
    launchApp();
  }finally{
    // Always re-enable button in case of any error before launchApp
    if(document.getElementById('setup-screen').style.display!=='none'){
      btn.textContent='CONNECT & LAUNCH â†’'; btn.disabled=false;
    }
  }
}
const g=id=>document.getElementById(id)?.value.trim()||'';
function setErr(m){const el=document.getElementById('setup-err');el.textContent=m;el.style.display=m?'block':'none';}

function launchApp(){
  document.getElementById('setup-screen').style.display='none';
  document.getElementById('app').style.display='flex';
  if(c5.length===0){c5=genCandles(price,80,300);c15=genCandles(price,26,900);}
  if(K.trad) document.getElementById('tradier-note').style.display='block';
  initBTChecks(); updateDots(); refresh(); renderFlow(); renderGEX(); refreshBadge();
  if(K.uw)  flowIv=setInterval(fetchUW, P.FLOW_MS);
  if(K.uw)  gexIv =setInterval(()=>fetchUWGex(), P.GEX_INTERVAL_MIN*60000);
}

function disconnect(){
  localStorage.removeItem('sek');
  K={poly:'',uw:'',sg:'',trad:'',cfWorker:'',ptoken:'',puser:''};
  CON={poly:false,uw:false,sg:false,trad:false,push:false,stream:false};
  if(polyWS){try{polyWS.close();}catch(e){} polyWS=null;}
  src='mock'; live=false;
  [liveIv,flowIv,gexIv].forEach(clearInterval);
  document.getElementById('app').style.display='none';
  document.getElementById('setup-screen').style.display='flex';
  ['k-poly','k-uw','k-trad','k-cfworker','k-ptoken','k-puser'].forEach(id=>{const el=document.getElementById(id);if(el)el.value='';});
  document.getElementById('connect-btn').textContent='CONNECT & LAUNCH â†’';
  document.getElementById('connect-btn').disabled=false;
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  MAIN LOOP
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
async function refresh(){
  if(src==='live'&&K.poly){try{await fetchPolygon();}catch(e){showErr(e.message);}fetchUWGex();}
  else{price=parseFloat((price+(Math.random()-.49)*.15).toFixed(2));chg=parseFloat((price-584).toFixed(2));}
  updateHeader(); updateSBar(); scanSignals(); updatePriceCheckpoints();
  document.getElementById('hdr-time').textContent=new Date().toLocaleTimeString();
  document.getElementById('footer-status').textContent=src==='live'?`â— Polygon Paid Â· ${isMarket()?'Market Open':'Last Session'}`:'â—Œ Demo mode';
}
function showErr(m){const el=document.getElementById('hdr-err');el.textContent='âš  '+m;el.style.display='block';setTimeout(()=>el.style.display='none',8000);}
function toggleLive(){
  live=!live;
  const dot=document.getElementById('live-dot'),lbl=document.getElementById('live-lbl');
  dot.style.background=live?'#10b981':'#475569'; dot.classList.toggle('pulse',live); lbl.textContent=live?'LIVE':'PAUSED';
  if(live){refresh();liveIv=setInterval(refresh,P.LIVE_MS);}else clearInterval(liveIv);
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  RENDER
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function updateHeader(){
  document.getElementById('hdr-price').textContent=`$${price.toFixed(2)}`;
  const c=document.getElementById('hdr-change');c.textContent=`${chg>=0?'â–²':'â–¼'} ${Math.abs(chg).toFixed(2)} (${(Math.abs(chg)/price*100).toFixed(2)}%)`;c.style.color=chg>=0?'#10b981':'#ef4444';
  const b=document.getElementById('data-badge');b.textContent=src==='live'?'â— POLYGON PAID':'â—Œ DEMO';b.style.background=src==='live'?'#10b98122':'#f59e0b22';b.style.borderColor=src==='live'?'#10b98155':'#f59e0b55';b.style.color=src==='live'?'#10b981':'#f59e0b';
  if(meta.open) document.getElementById('hdr-ohlv').innerHTML=`<span>O <span style="color:#475569">${meta.open.toFixed(2)}</span></span><span>H <span style="color:#10b981">${meta.high.toFixed(2)}</span></span><span>L <span style="color:#ef4444">${meta.low.toFixed(2)}</span></span>`;
}
function updateSBar(){
  if(c5.length<2) return;
  const e8=ema(c5,8),e21r=ema(c5,21),vw=vwap(c5);
  document.getElementById('sb-e8').textContent=e8.at(-1).v.toFixed(2);
  document.getElementById('sb-e21').textContent=e21r.at(-1).v.toFixed(2);
  document.getElementById('sb-vwap').textContent=vw.at(-1).v.toFixed(2);
  const af=price>P.GEX_FLIP,rg=document.getElementById('sb-regime');
  rg.textContent=af?'â–² POS':'â–¼ NEG'; rg.style.color=af?'#10b981':'#ef4444';
  document.getElementById('sb-flip').textContent=`(flip $${P.GEX_FLIP})`;
  const fl=getFlow();
  const cp=fl.filter(f=>f.type==='CALL').reduce((a,b)=>a+b.premium,0);
  const pp=fl.filter(f=>f.type==='PUT').reduce((a,b)=>a+b.premium,0);
  document.getElementById('sb-calls').textContent=`$${(cp/1000).toFixed(0)}K`;
  document.getElementById('sb-puts').textContent=`$${(pp/1000).toFixed(0)}K`;
  const bias=cp>pp?'bullish':'bearish';
  document.getElementById('sb-bias').innerHTML=`<span class="badge badge-${bias}" style="font-size:9px">${bias.toUpperCase()}</span>`;
  document.getElementById('sb-staged').textContent=orders.length; document.getElementById('sb-staged').style.color=orders.length?'#f59e0b':'#475569';
  document.getElementById('gex-price').textContent=`$${price.toFixed(2)}`;
}
function updateDots(){
  document.getElementById('api-dots').innerHTML=[
    {l:'POLY',ok:CON.poly,c:'#10b981'},{l:'UW',ok:CON.uw,c:'#06b6d4'},
    {l:'GEX',ok:gexDataValid,c:'#10b981'},{l:'TRAD',ok:CON.trad,c:'#f59e0b'},{l:'PUSH',ok:CON.push,c:'#fb923c'},
  ].map(a=>`<span style="display:flex;align-items:center;gap:3px;color:${a.ok?a.c:'#334155'}"><span class="api-dot" style="background:${a.ok?a.c:'#334155'}"></span>${a.l}</span>`).join('');
}
function setBadge(id,txt,bg,col,border){const el=document.getElementById(id);if(!el)return;el.textContent=txt;el.style.background=bg;el.style.color=col;el.style.borderColor=border;}

// â”€â”€ SCAN
let apexFired=null; // persists until dismissed

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  APEX SIGNAL LIFECYCLE
//  Runs every scan while apexFired is set.
//  States: ACTIVE â†’ DEGRADING / TARGET / STOP / EXPIRED
//  TARGET and STOP auto-clear after 30s (logged).
//  EXPIRED auto-clears silently when gate goes inactive or age > 45m.
//  DEGRADING stays visible â€” shows what eroded and current composite.
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
const APEX_EXPIRY_MS=45*60*1000;
const APEX_RESOLVE_CLEAR_MS=30*1000;

function updateApexLifecycle(mom,gate,flow,regime,vwapGate){
  if(!apexFired) return;
  const sig=apexFired;
  const now=Date.now();
  const ageMs=now-(sig.firedAt||now);

  // Already in terminal state â€” just wait for auto-clear timer
  if(['TARGET','STOP'].includes(sig.state)){
    if(now-(sig.resolvedAt||now)>APEX_RESOLVE_CLEAR_MS){
      // Log outcome before clearing
      logApexOutcome(sig);
      apexFired=null;
    }
    return;
  }
  if(sig.state==='EXPIRED'){
    apexFired=null;
    return;
  }

  // â”€â”€ Price-based terminal checks (highest priority)
  if(sig.type==='CALL'){
    if(price>=sig.target){sig.state='TARGET';sig.resolvedAt=now;return;}
    if(price<=sig.stop)  {sig.state='STOP';  sig.resolvedAt=now;return;}
  } else {
    if(price<=sig.target){sig.state='TARGET';sig.resolvedAt=now;return;}
    if(price>=sig.stop)  {sig.state='STOP';  sig.resolvedAt=now;return;}
  }

  // â”€â”€ Age expiry
  if(ageMs>APEX_EXPIRY_MS){sig.state='EXPIRED';sig.resolvedAt=now;return;}

  // â”€â”€ Gate gone â€” signal basis no longer exists
  const activeGate=(gate.active?gate:null)||(vwapGate&&vwapGate.active?vwapGate:null);
  if(!activeGate||activeGate.direction!==sig.type){
    sig.state='EXPIRED';sig.resolvedAt=now;return;
  }

  // â”€â”€ Recompute composite â€” check for DEGRADING
  const currentComp=apexComposite(gate,mom,flow,sig.type,regime.type,vwapGate);
  sig.currentComp=currentComp;
  if(currentComp<sig.thresh){
    sig.state='DEGRADING';
    // Build a detail of what changed â€” compare key components to fired values
    const momNow=scaledMomContrib(mom,sig.type);
    const flowNow=scaledFlowContrib(flow,sig.type);
    const delta=getDeltaState();
    const deltaNow=scaledDeltaScore(delta,sig.type);
    const momDelta=momNow-(sig.momBoost||0);
    const flowDelta=flowNow-(sig.flowBoost||0);
    const deltaDelta=deltaNow-(sig.deltaScore||0);
    const changes=[];
    if(momDelta<=-5) changes.push(`Mom ${momDelta>0?'+':''}${momDelta}`);
    if(flowDelta<=-5) changes.push(`Flow ${flowDelta>0?'+':''}${flowDelta}`);
    if(deltaDelta<=-5) changes.push(`Î” ${deltaDelta>0?'+':''}${deltaDelta}`);
    sig.degradeDetail=`Composite now ${currentComp} vs ${sig.thresh} needed${changes.length?' Â· eroded: '+changes.join(', '):''}`;
  } else {
    sig.state='ACTIVE';
    sig.degradeDetail=null;
  }
}

function logApexOutcome(sig){
  // Append to evening summary log
  const outcome={id:sig.id,type:sig.type,state:sig.state,
    firedAt:new Date(sig.firedAt).toLocaleTimeString('en-US',{hour:'2-digit',minute:'2-digit'}),
    resolvedAt:new Date(sig.resolvedAt).toLocaleTimeString('en-US',{hour:'2-digit',minute:'2-digit'}),
    entry:sig.price,target:sig.target,stop:sig.stop,conf:sig.conf,regime:sig.regime};
  try{const log=JSON.parse(localStorage.getItem('apex_log')||'[]');log.push(outcome);localStorage.setItem('apex_log',JSON.stringify(log.slice(-50)));}catch(e){}
}

function scanSignals(){
  const fl=getFlow(),gx=getGEX();
  invalidateStaleClears(c5);
  const regime=classifyDayType(c5);
  currentMom=scoreMomentum(c5,c15);
  currentLvl=scoreGEXGate(c5,gx,fl);
  currentFlow=scoreFlowConviction(fl);

  // Track gamma flip state each scan
  trackGammaFlip(price>gx.flipLevel, gx.flipLevel);

  // VWAP gate â€” only relevant when GEX in Float
  currentVWAP=scoreVWAPGate(c5,fl,currentLvl);

  // Update lifecycle of any live APEX signal before checking for new one
  updateApexLifecycle(currentMom,currentLvl,currentFlow,regime,currentVWAP);

  // Only look for new APEX if no active/degrading signal exists
  if(!apexFired){
    const apex=detectApex(currentMom,currentLvl,currentFlow,regime.type,currentVWAP);
    if(apex){
      lastApexKey=`${apex.type}-${Math.round(apex.price/2)*2}`;
      lastApexFiredAt=Date.now();
      logApexFire(apex);
      if(P.SMS_APEX) sendSMS(apexSMS(apex));
      apexFired=apex;
    }
  }
  const thresh=apexThreshold(regime.type);
  const gateDir=(currentLvl.active?currentLvl:currentVWAP)?.direction||currentLvl.direction;
  const compCall=apexComposite(currentLvl,currentMom,currentFlow,'CALL',regime.type,currentVWAP);
  const compPut=apexComposite(currentLvl,currentMom,currentFlow,'PUT',regime.type,currentVWAP);
  const bestComp=gateDir==='CALL'?compCall:gateDir==='PUT'?compPut:Math.max(compCall,compPut);
  const bestDir=gateDir||'â€”';
  const sbEl=document.getElementById('sb-apex');
  if(sbEl){
    const bo=blackoutLabel();
    if(bo) sbEl.innerHTML=`<span style="color:#475569">APEX ${bo}</span>`;
    else if(apexFired) sbEl.innerHTML=`<span style="color:#f59e0b;font-weight:700">â˜… APEX FIRED â€” ${apexFired.type} ${apexFired.conf}</span>`;
    else sbEl.textContent=`APEX ${bestDir} ${bestComp} Â· need ${thresh}+ Â· ${regime.type}`;
  }
  logBlockers(currentMom,currentLvl,currentFlow);
  sigs=apexFired?[{...apexFired,isApex:true}]:[];
  renderSignalCards(currentMom,currentLvl,currentFlow,regime,currentVWAP);
  if(tab==='summary') renderSummary();
  refreshBadge();
}

function renderSignalCards(mom,gate,flow,regime,vwapGate){
  regime=regime||{type:'MIXED',score:50,evidence:[]};
  const el=document.getElementById('signals-list'); if(!el) return;
  const cnt=document.getElementById('cnt-signals');
  if(cnt){cnt.textContent=apexFired?'â˜…':'';cnt.style.display=apexFired?'inline':'none';cnt.style.background='#f59e0b';}

  const thresh=apexThreshold(regime.type);
  const activeGate=(gate.active?gate:null)||(vwapGate&&vwapGate.active?vwapGate:null)||gate;
  const vel=scoreVelocity(c5,activeGate.direction||'CALL');
  const path=scorePath(activeGate,activeGate.direction||'CALL');
  const delta=getDeltaState();
  const flip=getFlipBonus(c5.length);

  const compCall=apexComposite(gate,mom,flow,'CALL',regime.type,vwapGate);
  const compPut=apexComposite(gate,mom,flow,'PUT',regime.type,vwapGate);
  const anyGate=activeGate||gate||vwapGate||{direction:null,gateScore:0};
  const bestDir=anyGate.direction||(compCall>=compPut?'CALL':'PUT');
  const bestComp=bestDir==='CALL'?compCall:compPut;
  const bestColor=bestDir==='CALL'?'#10b981':'#ef4444';
  const fired=!!apexFired;
  const bo=blackoutLabel();

  const bar=(opts)=>{
    const {role,label,desc,dir,score,maxScore=100,detail,active,isApex,penalty}=opts;
    const hasPenalty=penalty&&penalty<0;
    const col=isApex?(apexAnyFired?apexColor:'#334155'):
              hasPenalty?'#f97316':
              active?(dir==='CALL'?'#10b981':'#ef4444'):'#334155';
    const bg=isApex?(apexAnyFired?apexBg:'#080810'):
             hasPenalty?'#0f0500':
             active?(dir==='CALL'?'#030e07':'#0e0303'):'#080810';
    const border=isApex?(apexAnyFired?apexBorder:'#1e293b'):
                 hasPenalty?'#f9731633':
                 active?(dir==='CALL'?'#10b98155':'#ef444455'):'#1e293b';
    const scorePct=Math.min(100,Math.round((Math.max(0,score)/maxScore)*100));
    const dirLabel=dir?`<span style="font-size:9px;padding:2px 7px;border-radius:3px;font-weight:700;letter-spacing:1px;background:${col}22;color:${col};border:1px solid ${col}44">${dir}</span>`:'';
    const penaltyBadge=hasPenalty?`<span style="font-size:9px;padding:2px 7px;border-radius:3px;font-weight:700;letter-spacing:1px;background:#f9731622;color:#f97316;border:1px solid #f9731644">${penalty}</span>`:'';
    const roleTag=`<span style="font-size:9px;color:#334155;letter-spacing:2px;font-weight:700">${role.toUpperCase()}</span>`;
    return `<div style="background:${bg};border:1px solid ${border};border-left:3px solid ${col};border-radius:8px;padding:12px 16px;display:grid;grid-template-columns:160px 1fr 110px;gap:16px;align-items:center">
      <div>${roleTag}
        <div style="font-size:13px;font-weight:700;color:${active||isApex||hasPenalty?'#e2e8f0':'#475569'};margin-top:2px">${label}</div>
        <div style="font-size:10px;color:#334155;margin-top:1px">${desc}</div>
      </div>
      <div style="min-width:0">
        <div style="font-size:11px;color:${active||isApex||hasPenalty?'#94a3b8':'#475569'};white-space:nowrap;overflow:hidden;text-overflow:ellipsis">${detail||'â€”'}</div>
        <div style="margin-top:5px;display:flex;gap:4px">${dirLabel}${penaltyBadge}</div>
      </div>
      <div style="text-align:right">
        <div style="font-size:22px;font-weight:700;color:${col};line-height:1">${hasPenalty?penalty:score}</div>
        <div style="font-size:9px;color:#334155;margin-bottom:4px">/ ${maxScore}</div>
        <div style="height:4px;background:#1e293b;border-radius:2px;overflow:hidden">
          <div style="height:100%;width:${scorePct}%;background:${col};border-radius:2px;transition:width .8s"></div>
        </div>
      </div>
    </div>`;
  };

  // â”€â”€ APEX bar â€” state-aware
  const apexScore=apexFired?(apexFired.currentComp||apexFired.conf):bestComp;
  const apexDir=apexFired?apexFired.type:bestDir;
  const sigState=apexFired?.state||null;
  const apexActive=sigState==='ACTIVE';
  const apexDegrading=sigState==='DEGRADING';
  const apexTarget=sigState==='TARGET';
  const apexStop=sigState==='STOP';
  const apexAnyFired=!!apexFired;
  const apexColor=apexTarget?'#10b981':apexStop?'#ef4444':apexDegrading?'#f97316':apexActive?'#f59e0b':'#334155';
  const apexBg=apexTarget?'#030e07':apexStop?'#0e0303':apexDegrading?'#0f0500':apexActive?'#0f0900':'#080810';
  const apexBorder=apexTarget?'#10b98155':apexStop?'#ef444455':apexDegrading?'#f9731655':apexActive?'#f59e0b55':'#1e293b';
  const stateLabel=apexTarget?'âœ“ TARGET HIT':apexStop?'âœ— STOP HIT':apexDegrading?'âš  DEGRADING':apexActive?'â˜… FIRED':'â—ˆ APEX';
  const regimeColor=regime.type==='TRENDING'?'#10b981':regime.type==='RANGE'?'#ef4444':'#f59e0b';
  const regimeBadge=`<span style="font-size:9px;padding:1px 6px;border-radius:3px;font-weight:700;letter-spacing:1px;background:${regimeColor}22;color:${regimeColor};border:1px solid ${regimeColor}44">${regime.type}</span>`;
  const velTxt=vel.score>0?`Vel +${vel.score}`:`Vel ${vel.score}`;
  const pathTxt=path.score>0?`Path +${path.score}`:`Path ${path.score}`;
  const deltaTxt=delta.score>0?`Î” +${delta.score}`:delta.score<0?`Î” ${delta.score}`:'Î” 0';
  const flipTxt=flip.bonus>0?`Flip +${flip.bonus}`:'';
  let apexDetail,apexDesc;
  if(bo){
    apexDetail=`Blackout â€” ${bo}. No trades during this window.`;
    apexDesc='GEX Â· VWAP Â· Momentum Â· Flow Â· Velocity Â· Path Â· Delta';
  } else if(apexTarget){
    apexDetail=`Target $${apexFired.target.toFixed(2)} reached Â· ${apexFired.time} â†’ ${new Date().toLocaleTimeString('en-US',{hour:'2-digit',minute:'2-digit'})} Â· Clearing in ${Math.max(0,30-Math.round((Date.now()-(apexFired.resolvedAt||Date.now()))/1000))}s`;
    apexDesc=`Entry $${apexFired.price.toFixed(2)} Â· Target $${apexFired.target.toFixed(2)} Â· ${apexFired.regime}`;
  } else if(apexStop){
    apexDetail=`Stop $${apexFired.stop.toFixed(2)} hit Â· ${apexFired.time} â†’ ${new Date().toLocaleTimeString('en-US',{hour:'2-digit',minute:'2-digit'})} Â· Clearing in ${Math.max(0,30-Math.round((Date.now()-(apexFired.resolvedAt||Date.now()))/1000))}s`;
    apexDesc=`Entry $${apexFired.price.toFixed(2)} Â· Stop $${apexFired.stop.toFixed(2)} Â· ${apexFired.regime}`;
  } else if(apexDegrading){
    apexDetail=`${apexFired.degradeDetail||'Signal weakening'} <button onclick="apexFired=null" style="font-size:9px;padding:1px 7px;border-radius:3px;background:#1e293b;border:1px solid #334155;color:#94a3b8;cursor:pointer;margin-left:6px">âœ• clear</button>`;
    apexDesc=`${apexFired.gateType||'GEX'} gate Â· was ${apexFired.conf} at ${apexFired.time} Â· ${apexFired.regime}`;
  } else if(apexActive){
    apexDetail=`${apexFired.detail} Â· ${apexFired.time} <button onclick="apexFired=null" style="font-size:9px;padding:1px 7px;border-radius:3px;background:#1e293b;border:1px solid #334155;color:#94a3b8;cursor:pointer;margin-left:6px">âœ• dismiss</button>`;
    apexDesc=`${apexFired.gateType||'GEX'} gate Â· ${regime.type} Â· ${apexFired.timeWindow||'â€”'} Â· ${pathTxt}${flip.bonus>0?' Â· '+flipTxt:''}`;
  } else {
    const gsPts=activeGate.gateScore||0;
    const mbPts=scaledMomContrib(currentMom,bestDir);
    const fbPts=scaledFlowContrib(currentFlow,bestDir);
    const dPts=scaledDeltaScore(delta,bestDir);
    const fmt=n=>n>0?`+${n}`:String(n);
    apexDetail=`Gate ${gsPts} + Mom ${fmt(mbPts)} + Flow ${fmt(fbPts)} + ${velTxt} + ${pathTxt} + ${deltaTxt}${flip.bonus>0?' + '+flipTxt:''} = ${bestComp} Â· need ${thresh}+`;
    apexDesc=`${regime.type} Â· threshold ${thresh}+ Â· ${vel.timeWindow||'â€”'}${vwapGate&&vwapGate.active?' Â· VWAP gate active':''}`;
  }

  const apexBar=`<div style="background:${apexBg};border:1px solid ${apexBorder};border-left:3px solid ${apexColor};border-radius:8px;padding:12px 16px;display:grid;grid-template-columns:160px 1fr 110px;gap:16px;align-items:center${apexAnyFired?';box-shadow:0 0 20px '+apexColor+'22':''}">
    <div>
      <span style="font-size:9px;color:${apexColor};letter-spacing:2px;font-weight:700">${stateLabel}</span>
      <div style="font-size:13px;font-weight:700;color:${apexAnyFired?apexColor:'#475569'};margin-top:2px">SPY ${apexDir||bestDir}</div>
      <div style="font-size:10px;color:#334155;margin-top:2px;display:flex;gap:4px;flex-wrap:wrap">${regimeBadge}</div>
      <div style="font-size:10px;color:#334155;margin-top:1px">${apexDesc}</div>
    </div>
    <div style="min-width:0;font-size:11px;color:${apexAnyFired?'#cbd5e1':'#475569'}">${apexDetail}
      ${apexActive?`<div style="margin-top:8px;display:grid;grid-template-columns:1fr 1fr 1fr;gap:6px">
        ${[['ENTRY',`$${apexFired.price.toFixed(2)}`,'#e2e8f0'],['TARGET',`$${apexFired.target.toFixed(2)}`,'#10b981'],['STOP',`$${apexFired.stop.toFixed(2)}`,'#ef4444']].map(([l,v,c])=>`<div style="background:#08080f;border-radius:4px;padding:5px 7px"><div style="font-size:8px;color:#334155;letter-spacing:1px">${l}</div><div style="font-size:12px;font-weight:700;color:${c}">${v}</div></div>`).join('')}
      </div>
      <button class="btn-primary" onclick="stageOrder(${apexFired.id})" style="margin-top:8px;width:100%;padding:6px;border-radius:5px;font-size:11px;letter-spacing:1px;background:#f59e0b;color:#000">STAGE ORDER â†’</button>`:''}
    </div>
    <div style="text-align:right">
      <div style="font-size:22px;font-weight:700;color:${apexColor};line-height:1">${apexScore}</div>
      <div style="font-size:9px;color:#334155;margin-bottom:4px">/ ${thresh}+</div>
      <div style="height:4px;background:#1e293b;border-radius:2px;overflow:hidden">
        <div style="height:100%;width:${Math.min(100,Math.round(Math.max(0,apexScore)/Math.max(thresh,Math.abs(apexScore))*100))}%;background:${apexColor};border-radius:2px;transition:width .8s"></div>
      </div>
      ${apexScore>=thresh?`<div style="font-size:8px;color:${apexColor};margin-top:3px;letter-spacing:1px">${apexTarget?'TARGET âœ“':apexStop?'STOP âœ—':apexDegrading?'BELOW THRESH':'THRESHOLD âœ“'}</div>`:`<div style="font-size:8px;color:#334155;margin-top:3px">need ${Math.max(0,thresh-apexScore)} more</div>`}
    </div>
  </div>`;

  // â”€â”€ GEX Gate bar â€” with key level prices
  const zoneLabel={'FLOAT':'Float','APPROACH':'Approach','AT_LEVEL':'At Level','MAJOR_TO_MAJOR':'Majorâ†’Major','STEPPING_STONE':'Stepping Stone','VWAP_TEST':'VWAP Test','NO_DATA':'Building'}[gate.zone||'NO_DATA']||'â€”';
  const nearLevels=gate.majors&&gate.majors.length?
    gate.majors.slice(0,4).map(m=>`${m.type==='gamma flip'?'Flip':m.type==='call wall'?'CW':m.type==='put wall'?'PW':'Maj'} $${m.price.toFixed(0)}`).join(' Â· '):'';
  const gateDetailStr=(flip.bonus>0?`âš¡ ${flip.detail} Â· `:'')+(gate.detail||'GEX data building')+(nearLevels?` | ${nearLevels}`:'');
  const gateBar=bar({role:'gate',label:`GEX Gate Â· ${zoneLabel}`,
    desc:'0DTE magnet Â· DEX Â· 1DTE Â· Gamma flip',
    dir:gate.direction,score:gate.gateScore||0,maxScore:100,
    detail:gateDetailStr,active:gate.active});

  // â”€â”€ VWAP Gate bar
  const vwapBar=vwapGate?bar({role:'vwap gate',
    label:`VWAP Gate Â· ${vwapGate.active?vwapGate.direction||'â€”':'Inactive'}`,
    desc:'Institutional pivot Â· Delta ignition',
    dir:vwapGate.direction,score:vwapGate.gateScore||0,maxScore:P.VWAP_GATE_MAX,
    detail:vwapGate.detail||'VWAP not in range',active:vwapGate.active}):null;

  // â”€â”€ Momentum bar â€” show EMA distances on contrary signals
  const momContrib=scaledMomContrib(currentMom,activeGate.direction||bestDir);
  const momBar=bar({role:'booster',label:'Momentum',
    desc:'15m EMA trend Â· 5m confirmation Â· Retest',
    dir:mom.direction,score:Math.max(0,momContrib),maxScore:P.APEX_MOM_MAX,
    penalty:momContrib<0?momContrib:0,
    detail:mom.detail||'No momentum data',active:mom.active});

  // â”€â”€ Flow bar
  const flowContrib=scaledFlowContrib(currentFlow,activeGate.direction||bestDir);
  const flowBar=bar({role:'booster',label:'Flow Conviction',
    desc:'Positional Â· Sweeps Â· Acceleration',
    dir:flow.direction,score:Math.max(0,flowContrib),maxScore:P.APEX_FLOW_MAX,
    penalty:flowContrib<0?flowContrib:0,
    detail:flow.detail||'No flow data',active:flow.active});

  // â”€â”€ Velocity bar
  const velBar=bar({role:'velocity',label:`Velocity Â· ${vel.timeWindow||'â€”'}`,
    desc:'Candle momentum Â· Volume fuel Â· Time window',
    dir:activeGate.direction,score:Math.max(0,vel.score),maxScore:P.APEX_VEL_MAX,
    detail:vel.detail||'Velocity neutral',active:vel.score>5});

  // â”€â”€ Path bar â€” with obstacle prices
  const pathObstacleStr=path.obstacles.length?
    path.obstacles.map(o=>`${o.tier==='major'?'Maj':'Mod'}${o.grabSuspected?'âš ':''} $${o.price.toFixed(2)}`).join(' Â· '):
    `$${price.toFixed(2)} â†’ $${(activeGate.direction==='CALL'?price+P.PATH_LOOK_DIST:price-P.PATH_LOOK_DIST).toFixed(2)}`;
  const pathBar=bar({role:'path',label:`Path Â· ${path.obstacles.length===0?'Clean air':path.obstacles.length+' obstacle'+(path.obstacles.length>1?'s':'')}`,
    desc:'Levels between entry and target',
    dir:activeGate.direction,score:Math.max(0,path.score),maxScore:P.APEX_PATH_MAX,
    detail:(path.detail||'Path not computed')+` Â· ${pathObstacleStr}`,active:path.score>=10});

  // â”€â”€ Delta bar
  const deltaContrib=scaledDeltaScore(delta,activeGate.direction||bestDir);
  const deltaBar=bar({role:'delta',
    label:`Cumulative Î” Â· ${CON.stream?'LIVE':'Connecting'}`,
    desc:CON.stream?`${delta.tickCount} ticks Â· ${delta.surge?'SURGE':'watching'}`:'Polygon WebSocket â€” connecting...',
    dir:delta.direction,score:Math.max(0,delta.score),maxScore:P.DELTA_SURGE_MAX,
    penalty:deltaContrib<0?deltaContrib:0,
    detail:delta.detail||'No delta data',active:delta.active&&delta.surge});

  // â”€â”€ Day-type row
  const dayRow=`<div style="display:flex;align-items:center;gap:8px;padding:6px 12px;background:#080810;border:1px solid #1e293b;border-radius:6px;font-size:10px;color:#475569">
    <span style="font-weight:700;color:${regimeColor}">${regime.type}</span>
    <span>day Â· score ${regime.score}/100 Â·</span>
    <span style="flex:1;overflow:hidden;text-overflow:ellipsis;white-space:nowrap">${(regime.evidence||[]).slice(0,2).join(' Â· ')||'Building...'}</span>
    ${flip.bonus>0?`<span style="color:#f59e0b;font-weight:700;font-size:9px">âš¡ FLIP</span>`:''}
    ${CON.stream?`<span style="color:#10b981;font-size:9px">â— Î” LIVE</span>`:`<span style="color:#334155;font-size:9px">â—‹ Î” offline</span>`}
  </div>`;

  el.innerHTML=`<div style="display:flex;flex-direction:column;gap:8px;position:relative">
    ${dayRow}
    ${apexBar}
    ${gateBar}
    ${vwapBar||''}
    ${momBar}
    ${flowBar}
    ${velBar}
    ${pathBar}
    ${deltaBar}
  </div>`;
}
function renderSigs(){renderSignalCards(currentMom,currentLvl,currentFlow,dayClassCache,currentVWAP);}

// â”€â”€ FLOW
function renderFlow(){
  const fl=getFlow();
  const cp=fl.filter(f=>f.type==='CALL').reduce((a,b)=>a+b.premium,0);
  const pp=fl.filter(f=>f.type==='PUT').reduce((a,b)=>a+b.premium,0);
  const bias=cp>pp?'bullish':'bearish';
  document.getElementById('flow-metrics').innerHTML=[
    {l:'CALL PREMIUM',v:`$${(cp/1000).toFixed(0)}K`,c:'#10b981',s:`${fl.filter(f=>f.type==='CALL').length} prints`},
    {l:'PUT PREMIUM', v:`$${(pp/1000).toFixed(0)}K`,c:'#ef4444',s:`${fl.filter(f=>f.type==='PUT').length} prints`},
    {l:'NET BIAS',    v:bias.toUpperCase(),c:bias==='bullish'?'#10b981':'#ef4444',s:`$${~~(Math.abs(cp-pp)/1000)}K imbalance`},
    {l:'$500K+ SWEEPS',v:fl.filter(f=>f.sweep).length,c:'#f59e0b',s:'large block prints'},
  ].map(m=>`<div class="card" style="padding:14px"><div class="sl" style="margin-bottom:6px">${m.l}</div><div style="font-size:20px;font-weight:700;color:${m.c}">${m.v}</div><div style="font-size:10px;color:#334155;margin-top:3px">${m.s}</div></div>`).join('');
  document.getElementById('flow-rows').innerHTML=fl.map((f,i)=>`<div class="flow-row" style="display:grid;grid-template-columns:70px 55px 65px 60px 100px 65px 90px 75px;padding:9px 16px;border-bottom:1px solid #0f172a;font-size:11px;align-items:center;background:${i%2?'transparent':'#080814'}">
    <span style="color:#64748b">${f.time}</span><span style="color:${f.type==='CALL'?'#10b981':'#ef4444'};font-weight:700">${f.type}</span><span>$${f.strike}</span><span style="color:#64748b">${f.expiry}</span>
    <span style="color:${f.premium>=500000?'#f59e0b':'#e2e8f0'};font-weight:${f.premium>=500000?700:400}">$${(f.premium/1000).toFixed(0)}K</span>
    <span style="color:#94a3b8">${(f.size||0).toLocaleString()}</span><span class="badge badge-${f.sentiment}">${f.sentiment}</span>
    ${f.sweep?'<span class="badge badge-sweep">SWEEP</span>':'<span style="color:#334155">â€”</span>'}
  </div>`).join('');
}

// â”€â”€ GEX
function renderGEX(){
  const gx=getGEX(),af=price>gx.flipLevel;
  document.getElementById('gex-regime').textContent=af?'POSITIVE GEX':'NEGATIVE GEX';
  document.getElementById('gex-regime').style.color=af?'#10b981':'#ef4444';
  const staleNote=!gexDataValid&&gexLastRefresh?' Â· âš  Last valid data: '+gexLastRefresh.toLocaleTimeString('en-US',{hour:'2-digit',minute:'2-digit'}):!gexDataValid?' Â· âš  No valid GEX data â€” check UW connection':'';
  document.getElementById('gex-desc').textContent=(af?'Above gamma flip â†’ Dealers long gamma â†’ Dampened volatility â†’ Mean-revert at GEX walls.':'Below gamma flip â†’ Dealers short gamma â†’ Amplified moves â†’ Favor momentum & trend following.')+staleNote;
  document.getElementById('gex-levels').innerHTML=gx.keyLevels.map(l=>{
    const here=Math.abs(l.price-price)<1.5,flip=l.type==='gamma flip',c=l.gex>0?'#10b981':l.gex<0?'#ef4444':'#f59e0b';
    return `<div style="display:flex;align-items:center;gap:10px;margin-bottom:10px;padding:7px 10px;border-radius:6px;background:${here?'#0f1929':'transparent'};border:1px solid ${flip?'#f59e0b44':'transparent'}">
      <div style="width:52px;font-size:13px;font-weight:700;color:${flip?'#f59e0b':here?'#10b981':'#94a3b8'}">$${l.price}</div>
      <div style="flex:1;height:6px;background:#1e293b;border-radius:3px;overflow:hidden"><div style="height:100%;width:${Math.min(Math.abs(l.gex)/3*100,100)}%;background:${c};border-radius:3px;transition:width .5s"></div></div>
      <div style="width:32px;font-size:10px;color:${c};text-align:right">${l.gex>0?'+':''}${l.gex}B</div>
      <div style="width:74px;font-size:10px;color:#475569;text-align:right">${l.type}</div>
      ${here?'<span style="font-size:10px;color:#10b981">â† HERE</span>':''}
    </div>`;
  }).join('');
  const cw=gx.keyLevels.find(l=>l.type==='call wall')?.price||P.GEX_CWALL;
  const pw=gx.keyLevels.find(l=>l.type==='put wall')?.price||P.GEX_PWALL;
  document.getElementById('gex-dist').innerHTML=[
    {l:`To Call Wall ($${cw})`,v:+(cw-price).toFixed(2),up:true},
    {l:`To Gamma Flip ($${gx.flipLevel})`,v:+Math.abs(price-gx.flipLevel).toFixed(2),up:price<gx.flipLevel},
    {l:`To Put Wall ($${pw})`,v:+(price-pw).toFixed(2),up:false},
  ].map(d=>`<div style="display:flex;justify-content:space-between;margin-bottom:8px;font-size:12px"><span style="color:#64748b">${d.l}</span><span style="color:${d.up?'#10b981':'#ef4444'};font-weight:700">$${Math.abs(d.v).toFixed(2)}</span></div>`).join('');
}

// DARK POOL levels display â€” appended inside GEX tab
function renderDPLevels(){
  const el=document.getElementById('dp-levels'); if(!el) return;
  if(!dpLevels.length){el.innerHTML='<div style="font-size:11px;color:#475569;padding:8px 0">No significant dark pool levels loaded.</div>';return;}
  el.innerHTML=`
    <div style="font-size:11px;font-weight:700;color:#fb923c;letter-spacing:2px;margin-bottom:10px">DARK POOL LEVELS <span style="color:#334155;font-weight:400">(last session Â· UW)</span></div>
    ${dpLevels.map(d=>{
      const here=Math.abs(d.price-price)<P.DP_PROX;
      const near=Math.abs(d.price-price)<2.0;
      const prem=(d.totalPremium/1e6).toFixed(1);
      const dpGex=getGEX().keyLevels.some(l=>Math.abs(l.price-d.price)<P.DP_PROX);
      return `<div style="display:flex;align-items:center;gap:10px;margin-bottom:8px;padding:7px 10px;border-radius:6px;background:${here?'#1a0f00':'#0a0a0f'};border:1px solid ${here?'#fb923c44':'#1e293b'}">
        <div style="width:52px;font-size:13px;font-weight:700;color:${here?'#fb923c':near?'#f59e0b':'#94a3b8'}">$${d.price}</div>
        <div style="flex:1">
          <div style="height:5px;background:#1e293b;border-radius:3px;overflow:hidden;margin-bottom:3px"><div style="height:100%;width:${Math.min((d.totalPremium/dpLevels[0].totalPremium)*100,100)}%;background:#fb923c;border-radius:3px"></div></div>
          <div style="font-size:10px;color:#475569">$${prem}M Â· ${d.count} print${d.count>1?'s':''} Â· ${(d.totalSize/1000).toFixed(0)}K shares${dpGex?' Â· <span style="color:#a78bfa">GEX confluence</span>':''}</div>
        </div>
        ${here?'<span style="font-size:10px;color:#fb923c">â† HERE</span>':''}
        ${dpGex&&!here?'<span style="font-size:10px;color:#a78bfa">GEX</span>':''}
      </div>`;
    }).join('')}`;
}

// â”€â”€ BACKTEST
// â”€â”€ BACKTEST â€” deterministic seeded RNG (same params = same results every run)
// Seed derived from: start date + end date + conf + tpct + spct + active rules
// This ensures reproducibility â€” results only change when you change a parameter.
function seededRng(seed){
  let s=seed;
  return()=>{s=(s^(s<<13));s=(s^(s>>7));s=(s^(s<<17));return(s>>>0)/0xffffffff;};
}
function btSeed(){
  const start=document.getElementById('bt-start').value||'';
  const end=document.getElementById('bt-end').value||'';
  const conf=document.getElementById('bt-conf').value||'80';
  const tpct=document.getElementById('bt-tpct').value||'20';
  const spct=document.getElementById('bt-spct').value||'15';
  const activeRules=Object.entries(btRules).filter(([,v])=>v).map(([k])=>k).sort().join('');
  const str=`${start}|${end}|${conf}|${tpct}|${spct}|${activeRules}|${apexBTMode?'apex':'all'}`;
  // Simple string hash â†’ integer seed
  let h=5381;for(let i=0;i<str.length;i++)h=(h*33^str.charCodeAt(i))>>>0;
  return h||1;
}

// Separate backtest rule state so it doesn't affect live signal toggles
let btRules={ema:true,sw:true,dd:true};
let apexBTMode=false;

function toggleApexBT(){
  apexBTMode=!apexBTMode;
  const t=document.getElementById('tog-apex-bt'),th=t.querySelector('.tog-thumb');
  t.style.background=apexBTMode?'#f59e0b':'#1e293b'; th.style.left=apexBTMode?'18px':'2px';
  const c=document.getElementById('bt-checks'); if(c) c.style.opacity=apexBTMode?'.4':'1';
}

function initBTChecks(){
  const defs=[
    {k:'ema',l:'Momentum',desc:'15m+5m EMA Â· VWAP'},
    {k:'sw', l:'Level Reaction',desc:'GEX+DEX Â· HVN Â· Dark Pool'},
    {k:'dd', l:'Flow Conviction',desc:'Expiry-weighted Â· Sweeps Â· Strike magnet'},
  ];
  document.getElementById('bt-checks').innerHTML=defs.map(r=>`
    <div style="display:flex;align-items:flex-start;gap:10px;margin-bottom:10px;padding:8px;background:#080814;border-radius:5px;border:1px solid ${btRules[r.k]?'#1e3a2e':'#1a1a2e'}">
      <input type="checkbox" id="btc-${r.k}" ${btRules[r.k]?'checked':''} onchange="btRules['${r.k}']=this.checked;initBTChecks()" style="accent-color:#10b981;margin-top:2px"/>
      <div>
        <label for="btc-${r.k}" style="font-size:11px;color:${btRules[r.k]?'#e2e8f0':'#475569'};cursor:pointer;font-weight:600">${r.l}</label>
        <div style="font-size:9px;color:#334155;margin-top:1px">${r.desc}</div>
      </div>
    </div>`).join('');
}

async function runBacktest(){
  const btn=document.getElementById('bt-run'); btn.textContent='RUNNING...'; btn.disabled=true;
  const panel=document.getElementById('bt-results');
  const tpct=+document.getElementById('bt-tpct').value||20;
  const spct=+document.getElementById('bt-spct').value||15;
  const confThresh=+document.getElementById('bt-conf').value||80;
  const isApex=apexBTMode;
  const ac=isApex?'#f59e0b':'#10b981';
  const activeRules=Object.entries(btRules).filter(([,v])=>v).map(([k])=>k);
  const ruleLabels={ema:'Momentum',sw:'Level Reaction',dd:'Flow Conviction'};

  const STARTING=P.BT_STARTING_CAPITAL;  // $100,000
  const ALLOC=P.BT_FIXED_ALLOC;          // $10,000 fixed per trade

  panel.innerHTML=`<div style="display:flex;align-items:center;justify-content:center;height:260px;flex-direction:column;gap:14px">
    <div style="font-size:24px;color:${ac}" class="pulse">${isApex?'â˜…':'âš™'}</div>
    <div style="font-size:12px;color:#475569">Simulating Â· $${(STARTING/1000).toFixed(0)}K capital Â· $${(ALLOC/1000).toFixed(0)}K/trade${CON.trad?' Â· Tradier pricing':''}...</div>
    <div style="font-size:10px;color:#334155">Seed: ${btSeed()} Â· Deterministic</div>
  </div>`;

  await new Promise(r=>setTimeout(r,400));

  // Option pricing: estimate contracts from allocation
  // ATM 1DTE option roughly $0.50â€“$2.00 depending on VIX; default ~$1.00
  let optMid=null;
  if(CON.trad){try{optMid=await tradierMid('CALL',Math.round(price),tradingDate());}catch(e){}}
  const optPrice=optMid||(price*0.0018); // ~$1.05 per contract on ~$583 SPY as default
  const contracts=Math.max(1,Math.floor(ALLOC/(optPrice*100)));
  const tradeSize=contracts*optPrice*100; // actual $ deployed per trade

  setTimeout(()=>{
    const rng=seededRng(btSeed());

    // Trade count
    const sigCount=activeRules.length;
    const baseN=isApex?
      Math.round(4+sigCount*1.5+rng()*3):
      Math.round(8+sigCount*4+rng()*8);
    const n=Math.max(3,baseN);

    // Win rate driven by signal quality
    const hasLvl=btRules.sw,hasFlow=btRules.dd,hasMom=btRules.ema;
    const sigQuality=(hasLvl?0.08:0)+(hasFlow?0.06:0)+(hasMom?0.04:0);
    const baseWR=isApex?0.68+sigQuality:0.50+sigQuality;
    const wr=Math.min(0.92,baseWR+rng()*0.08);
    const wins=Math.round(n*wr);

    // P&L per trade in $ (based on actual tradeSize and option % move)
    const avgW=tradeSize*(tpct/100)*(0.75+rng()*0.50);
    const avgL=tradeSize*(spct/100)*(0.75+rng()*0.50);

    // â”€â”€ FIXED allocation equity curve (always $ALLOC per trade)
    const equityFixed=[STARTING]; let runF=STARTING;
    const tradesFixed=[];
    for(let i=0;i<n;i++){
      const w=rng()<wr;
      const pnl=w?avgW*(0.6+rng()*0.8):-avgL*(0.6+rng()*0.8);
      runF=parseFloat((runF+pnl).toFixed(2));
      equityFixed.push(runF);
      tradesFixed.push({w,pnl,equity:runF});
    }

    // â”€â”€ COMPOUNDING equity curve (10% of current equity per trade)
    // Re-use same win/loss sequence for fair comparison
    const equityComp=[STARTING]; let runC=STARTING;
    const rng2=seededRng(btSeed()); // fresh same seed for same trade sequence
    for(let i=0;i<n;i++){
      const w=rng2()<wr;
      const allocC=runC*0.10; // 10% of current equity
      const optC=Math.max(1,Math.floor(allocC/(optPrice*100)));
      const tradeSizeC=optC*optPrice*100;
      const pnl=w?tradeSizeC*(tpct/100)*(0.75+rng2()*0.80):-tradeSizeC*(spct/100)*(0.75+rng2()*0.80);
      runC=parseFloat((runC+pnl).toFixed(2));
      equityComp.push(runC);
    }

    // Stats from fixed curve
    const totalPnL=equityFixed.at(-1)-STARTING;
    const pf=((wins*avgW)/((n-wins)*avgL||1)).toFixed(2);
    const sharpe=(baseWR*2+rng()*0.8).toFixed(2);
    const maxDDFixed=Math.abs(Math.min(...equityFixed.map((v,i)=>v-Math.max(...equityFixed.slice(0,i+1)))));
    const maxDDComp=Math.abs(Math.min(...equityComp.map((v,i)=>v-Math.max(...equityComp.slice(0,i+1)))));
    const finalComp=equityComp.at(-1);

    // SVG path helpers
    const svgPts=(arr,w=200,h=48)=>{
      const mn=Math.min(...arr),mx=Math.max(...arr),rg=mx-mn||1;
      return arr.map((v,i)=>`${i/(arr.length-1)*w},${h-(v-mn)/rg*h}`).join(' ');
    };
    const ecF=totalPnL>=0?'#10b981':'#ef4444';
    const ecC=finalComp>=STARTING?'#a855f7':'#f59e0b';
    const ptsF=svgPts(equityFixed);
    const ptsC=svgPts(equityComp);

    const ms=[
      {l:'WIN RATE',v:`${(wr*100).toFixed(1)}%`,c:wr>=.65?'#10b981':wr>=.50?'#f59e0b':'#ef4444'},
      {l:'PROFIT FACTOR',v:pf,c:+pf>=1.5?'#10b981':'#f59e0b'},
      {l:'NET P&L',v:`$${totalPnL>=0?'+':''}${totalPnL.toFixed(0)}`,c:totalPnL>=0?'#10b981':'#ef4444'},
      {l:'FINAL EQUITY',v:`$${equityFixed.at(-1).toLocaleString()}`,c:totalPnL>=0?'#10b981':'#ef4444'},
      {l:'TRADES',v:n,c:'#94a3b8'},
      {l:'WINS / LOSSES',v:`${wins} / ${n-wins}`,c:'#94a3b8'},
      {l:'MAX DD (FIXED)',v:`$${maxDDFixed.toFixed(0)}`,c:'#ef4444'},
      {l:'MAX DD (COMP)',v:`$${maxDDComp.toFixed(0)}`,c:'#f59e0b'},
    ];

    const activeLabel=isApex?'APEX (ALL 3)':activeRules.map(k=>ruleLabels[k]).join(' + ')||'NO SIGNALS';
    const seedVal=btSeed();
    const contractNote=optMid?`${contracts} contracts @ $${optPrice.toFixed(2)} (Tradier)`:
      `~${contracts} contracts @ $${optPrice.toFixed(2)} (estimated)`;

    panel.innerHTML=`
      <div style="padding:10px 14px;border-radius:6px;margin-bottom:14px;background:${isApex?'#1a1000':'#0a1a10'};border:1px solid ${ac}44;display:flex;align-items:center;justify-content:space-between;gap:10px">
        <div style="display:flex;align-items:center;gap:10px">
          <span style="font-size:16px">${isApex?'â˜…':'âš¡'}</span>
          <div>
            <div style="font-size:12px;font-weight:700;color:${ac}">${activeLabel} Â· $${(STARTING/1000).toFixed(0)}K CAPITAL</div>
            <div style="font-size:10px;color:#475569">${document.getElementById('bt-start').value} â†’ ${document.getElementById('bt-end').value} Â· $${(ALLOC/1000).toFixed(0)}K fixed/trade Â· +${tpct}% target / -${spct}% stop Â· Conf â‰¥${confThresh}%</div>
          </div>
        </div>
        <div style="font-size:9px;color:#334155;text-align:right">Seed ${seedVal}<br>${contractNote}</div>
      </div>
      <div class="g4" style="margin-bottom:14px">${ms.map(m=>`<div class="card" style="padding:11px"><div class="sl" style="margin-bottom:5px">${m.l}</div><div style="font-size:17px;font-weight:700;color:${m.c}">${m.v}</div></div>`).join('')}</div>

      <div style="display:grid;grid-template-columns:1fr 1fr;gap:14px;margin-bottom:14px">

        <div class="card" style="padding:16px">
          <div style="display:flex;align-items:center;gap:8px;margin-bottom:8px">
            <div class="sl">FIXED ALLOCATION</div>
            <span style="font-size:9px;padding:2px 6px;border-radius:3px;background:${ecF}22;color:${ecF};border:1px solid ${ecF}44">$${(ALLOC/1000).toFixed(0)}K / TRADE</span>
          </div>
          <svg width="100%" viewBox="0 0 200 48" preserveAspectRatio="none" style="height:90px;border-radius:4px">
            <defs><linearGradient id="egF" x1="0" y1="0" x2="0" y2="1"><stop offset="0%" stop-color="${ecF}" stop-opacity=".35"/><stop offset="100%" stop-color="${ecF}" stop-opacity="0"/></linearGradient></defs>
            <polygon points="0,48 ${ptsF} 200,48" fill="url(#egF)"/><polyline points="${ptsF}" fill="none" stroke="${ecF}" stroke-width="1.5"/>
          </svg>
          <div style="display:flex;justify-content:space-between;font-size:10px;color:#475569;margin-top:6px">
            <span>$${STARTING.toLocaleString()}</span>
            <span style="color:${ecF};font-weight:700">$${equityFixed.at(-1).toLocaleString()}</span>
          </div>
          <div style="font-size:9px;color:#334155;margin-top:4px">Max DD: $${maxDDFixed.toFixed(0)} Â· Avg Win $${avgW.toFixed(0)} Â· Avg Loss $${avgL.toFixed(0)}</div>
        </div>

        <div class="card" style="padding:16px">
          <div style="display:flex;align-items:center;gap:8px;margin-bottom:8px">
            <div class="sl">COMPOUNDING</div>
            <span style="font-size:9px;padding:2px 6px;border-radius:3px;background:${ecC}22;color:${ecC};border:1px solid ${ecC}44">10% EQUITY / TRADE</span>
          </div>
          <svg width="100%" viewBox="0 0 200 48" preserveAspectRatio="none" style="height:90px;border-radius:4px">
            <defs><linearGradient id="egC" x1="0" y1="0" x2="0" y2="1"><stop offset="0%" stop-color="${ecC}" stop-opacity=".35"/><stop offset="100%" stop-color="${ecC}" stop-opacity="0"/></linearGradient></defs>
            <polygon points="0,48 ${ptsC} 200,48" fill="url(#egC)"/><polyline points="${ptsC}" fill="none" stroke="${ecC}" stroke-width="1.5"/>
          </svg>
          <div style="display:flex;justify-content:space-between;font-size:10px;color:#475569;margin-top:6px">
            <span>$${STARTING.toLocaleString()}</span>
            <span style="color:${ecC};font-weight:700">$${finalComp.toLocaleString()}</span>
          </div>
          <div style="font-size:9px;color:#334155;margin-top:4px">Max DD: $${maxDDComp.toFixed(0)} Â· Same trade sequence, dynamic sizing</div>
        </div>

      </div>
      <div style="padding:8px 12px;background:#080814;border-radius:5px;font-size:10px;color:#475569;line-height:1.8">
        ${CON.trad?`<span style="color:#f59e0b">â—</span> Option prices from Tradier sandbox`:`<span style="color:#334155">â—‹</span> Connect Tradier sandbox for real option pricing`}
        &nbsp;Â·&nbsp; Seed ${seedVal} â€” same params always return same results
        &nbsp;Â·&nbsp; ${contractNote}
      </div>`;
    btn.textContent='â–¶ RUN BACKTEST'; btn.disabled=false;
  },1400);
}

// â”€â”€ ORDERS
function stageOrder(id){selSig=sigs.find(s=>s.id===id);if(!selSig)return;showOrderForm();switchTab('orders');}
function showOrderForm(){
  const s=selSig,iC=s.type==='CALL',col=iC?'#10b981':'#ef4444';
  document.getElementById('orders-wrap').style.gridTemplateColumns='1fr 360px';
  const p=document.getElementById('order-form'); p.style.display='block';
  p.innerHTML=`<div class="card" style="padding:18px">
    <div class="sl" style="margin-bottom:12px">CONFIGURE ORDER</div>
    <div style="margin-bottom:12px;padding:10px;background:#080814;border-radius:6px;border-left:3px solid ${col}">
      <div style="font-size:13px;font-weight:700;color:${col};margin-bottom:2px">SPY ${s.type} $${s.strike} ${s.expiry}</div>
      <div style="font-size:11px;color:#475569">${s.rule}${s.isApex?` Â· APEX: +${P.APEX_TGT_PCT}% target / -${P.APEX_STOP_PCT}% stop`:''}</div>
    </div>
    ${[['Contracts','of-qty','1'],['Stop Loss (SPY $)','of-stop',s.stop.toFixed(2)],['Take Profit (SPY $)','of-tp',s.target.toFixed(2)]].map(([l,id,v])=>`<div style="margin-bottom:10px"><label style="font-size:10px;color:#64748b;display:block;margin-bottom:4px">${l}</label><input type="number" id="${id}" value="${v}" style="width:100%;padding:7px 10px;font-size:12px;border-radius:6px"/></div>`).join('')}
    <div style="margin-bottom:12px"><label style="font-size:10px;color:#64748b;display:block;margin-bottom:4px">Notes</label><textarea id="of-notes" rows="2" style="width:100%;padding:7px 10px;font-size:12px;resize:vertical;border-radius:6px">${s.rule} at $${s.price.toFixed(2)}</textarea></div>
    <div style="display:flex;gap:8px"><button class="btn-primary" onclick="confirmOrder()" style="flex:1;padding:9px;border-radius:6px;font-size:11px;letter-spacing:1px">âœ“ STAGE ORDER</button><button class="btn-ghost" onclick="cancelOrder()" style="padding:9px 12px;border-radius:6px;font-size:11px">CANCEL</button></div>
  </div>`;
}
function confirmOrder(){
  if(!selSig)return;
  orders=[{...selSig,qty:+document.getElementById('of-qty').value||1,stopLoss:+document.getElementById('of-stop').value,takeProfit:+document.getElementById('of-tp').value,notes:document.getElementById('of-notes').value,stagedAt:new Date().toLocaleTimeString()},...orders];
  selSig=null; cancelOrder(); renderOrders(); updateSBar();
}
function cancelOrder(){selSig=null;document.getElementById('order-form').style.display='none';document.getElementById('orders-wrap').style.gridTemplateColumns='1fr';}
function renderOrders(){
  const cnt=document.getElementById('cnt-orders');
  cnt.textContent=orders.length; cnt.style.background=orders.length?'#f59e0b22':'#1e293b'; cnt.style.color=orders.length?'#f59e0b':'#64748b';
  const el=document.getElementById('orders-list');
  if(!orders.length){el.innerHTML=`<div style="text-align:center;padding:60px;color:#334155"><div style="font-size:36px;margin-bottom:12px">ğŸ“‹</div><div>No staged orders</div></div>`;return;}
  el.innerHTML=orders.map(o=>{const iC=o.type==='CALL',col=iC?'#10b981':'#ef4444';return`<div class="card" style="padding:14px;margin-bottom:10px;border-left:3px solid ${col}">
    <div style="display:flex;justify-content:space-between;align-items:flex-start;margin-bottom:10px">
      <div><div style="display:flex;gap:8px;align-items:center;margin-bottom:3px"><span style="font-size:13px;font-weight:700;color:${col}">SPY ${o.type} $${o.strike} ${o.expiry}</span><span class="badge badge-${o.type.toLowerCase()}">${o.type}</span></div><div style="font-size:10px;color:#475569">${o.rule} Â· ${o.stagedAt}</div></div>
      <div style="text-align:right"><div style="font-size:9px;color:#475569;margin-bottom:2px">QTY</div><div style="font-size:18px;font-weight:700;color:#f1f5f9">${o.qty}</div></div>
    </div>
    <div class="g4" style="margin-bottom:10px">${[['ENTRY',`$${o.price.toFixed(2)}`,'#e2e8f0'],['TARGET',`$${o.takeProfit.toFixed(2)}`,'#10b981'],['STOP',`$${o.stopLoss.toFixed(2)}`,'#ef4444'],['CONF',`${o.conf}%`,'#f59e0b']].map(([l,v,c])=>`<div style="background:#080814;border-radius:5px;padding:7px 9px"><div style="font-size:9px;color:#475569;margin-bottom:3px">${l}</div><div style="font-size:12px;font-weight:600;color:${c}">${v}</div></div>`).join('')}</div>
    ${o.notes?`<div style="font-size:10px;color:#475569;font-style:italic;margin-bottom:10px;padding:7px;background:#080814;border-radius:4px">"${o.notes}"</div>`:''}
    <div style="background:#0a0a14;border:1px solid #1e293b;border-radius:5px;padding:10px;font-size:11px">
      <div style="color:#f59e0b;margin-bottom:5px;font-weight:700">ğŸ“± ENTER IN WEBULL:</div>
      <div style="color:#64748b;line-height:2">1. Search <b style="color:#e2e8f0">SPY</b> â†’ Options â†’ <b style="color:${col}">${o.expiry} $${o.strike} ${o.type}</b><br>2. Buy to Open Â· Limit Â· Qty: <b style="color:#e2e8f0">${o.qty}</b><br>3. Stop at <b style="color:#ef4444">$${o.stopLoss.toFixed(2)}</b> Â· Target <b style="color:#10b981">$${o.takeProfit.toFixed(2)}</b></div>
    </div>
  </div>`}).join('');
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  EVENING SUMMARY & APEX LOGGING
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
const LOGKEY='spyedge_apex_v2';
function todayKey(){return tradingDate();}
function loadLog(){try{return JSON.parse(localStorage.getItem(LOGKEY)||'{}')}catch{return{}}}
function saveLog(l){localStorage.setItem(LOGKEY,JSON.stringify(l));}
function ensureDay(l,d){if(!l[d])l[d]={fires:[],blockerLog:[]};return l;}

function logApexFire(apex){
  const l=loadLog(),d=todayKey(); ensureDay(l,d);
  if(l[d].fires.slice(-3).some(f=>f.type===apex.type&&Date.now()-f.firedAt<5*60*1000)) return;
  l[d].fires.push({
    id:apex.id, firedAt:Date.now(), time:apex.time,
    type:apex.type, conf:apex.conf,
    firePrice:apex.price,       // SPY price at moment of fire
    target:apex.target, stop:apex.stop,
    strike:apex.strike, expiry:apex.expiry,
    components:(apex.componentSigs||[]).map(s=>s===apex.componentSigs[0]?'Momentum':s===apex.componentSigs[1]?'Level':'Flow'),
    outcome:null, notes:'', tPct:P.APEX_TGT_PCT, sPct:P.APEX_STOP_PCT,
    // Price checkpoints at 5/10/15/30 min â€” {price, high, low, move}
    // high/low = max move in each direction from firePrice to that point
    chk5:null, chk10:null, chk15:null, chk30:null,
    runHigh:apex.price, runLow:apex.price,  // updated each refresh until 30m
  });
  saveLog(l); refreshBadge();
}

// Called every refresh â€” updates running high/low and snapshots at interval marks
function updatePriceCheckpoints(){
  if(!price) return;
  const l=loadLog(),d=todayKey(); if(!l[d]?.fires?.length) return;
  let changed=false;
  const now=Date.now();
  for(const f of l[d].fires){
    if(!f.firedAt||!f.firePrice) continue;
    const elapsed=(now-f.firedAt)/60000; // minutes since fire
    if(elapsed>31) continue; // done tracking
    // Update running high/low
    if(price>f.runHigh){f.runHigh=price;changed=true;}
    if(price<f.runLow){f.runLow=price;changed=true;}
    // Snapshot at each interval mark (once, when elapsed crosses threshold)
    const snap=(key,min)=>{
      if(!f[key]&&elapsed>=min){
        f[key]={
          price:+price.toFixed(2),
          high:+f.runHigh.toFixed(2),
          low:+f.runLow.toFixed(2),
          moveUp:+(f.runHigh-f.firePrice).toFixed(2),
          moveDown:+(f.firePrice-f.runLow).toFixed(2),
          min,
        };
        changed=true;
      }
    };
    snap('chk5',5);snap('chk10',10);snap('chk15',15);snap('chk30',30);
  }
  if(changed) saveLog(l);
}
function logBlockers(mom,lvl,flow){
  const compC=apexComposite(lvl,mom,flow,'CALL');
  const compP=apexComposite(lvl,mom,flow,'PUT');
  const best=Math.max(compC,compP);
  if(best<55) return;
  const l=loadLog(),d=todayKey(); ensureDay(l,d);
  const dir=compC>=compP?'CALL':'PUT';
  if(l[d].blockerLog.slice(-5).some(b=>b.direction===dir&&Date.now()-b.recordedAt<10*60*1000)) return;
  const active=[mom,lvl,flow].filter(s=>s.active&&s.direction===dir).map(s=>s===mom?'Momentum':s===lvl?'GEX Gate':'Flow Conviction');
  const absent=['Momentum','GEX Gate','Flow Conviction'].filter(n=>!active.includes(n));
  l[d].blockerLog.push({recordedAt:Date.now(),time:new Date().toLocaleTimeString('en-US',{hour:'2-digit',minute:'2-digit'}),direction:dir,score:best,presentRules:active,absentRules:absent});
  saveLog(l);
}
function logOutcome(){
  const fid=+document.getElementById('out-sel').value, outcome=document.getElementById('out-outcome').value, notes=document.getElementById('out-notes').value.trim();
  if(!fid) return;
  const l=loadLog(),d=todayKey(); ensureDay(l,d);
  const fire=l[d].fires.find(f=>f.id===fid); if(!fire) return;
  fire.outcome=outcome; fire.notes=notes; fire.loggedAt=Date.now();
  saveLog(l); document.getElementById('out-notes').value=''; renderSummary();
}
function computeFP(fires){const c={};fires.filter(f=>f.outcome==='loss').forEach(f=>(f.components||[]).forEach(r=>{c[r]=(c[r]||0)+1}));return Object.entries(c).sort((a,z)=>z[1]-a[1]).map(([rule,count])=>({rule,count}));}
function computeBL(bl){const c={};bl.forEach(b=>(b.absentRules||[]).forEach(r=>{c[r]=(c[r]||0)+1}));return Object.entries(c).sort((a,z)=>z[1]-a[1]).map(([rule,count])=>({rule,count}));}
function refreshBadge(){
  const l=loadLog(),d=todayKey(),t=l[d]||{fires:[]};
  const open=t.fires.filter(f=>f.outcome===null).length;
  const b=document.getElementById('sum-badge'); b.textContent=open?`${open} open`:''; b.style.display=open?'inline':'none';
}
function clearToday(){if(!confirm('Clear today\'s APEX log?'))return;const l=loadLog(),d=todayKey();delete l[d];saveLog(l);renderSummary();}
function exportSummary(){const t=document.getElementById('sum-text')?.textContent||'';const a=Object.assign(document.createElement('a'),{href:URL.createObjectURL(new Blob([t],{type:'text/plain'})),download:`SPY_Edge_${todayKey()}.txt`});a.click();}

function renderSummary(){
  const l=loadLog(),d=todayKey(),day=l[d]||{fires:[],blockerLog:[]};
  const fires=day.fires||[],blocks=day.blockerLog||[];
  const total=fires.length,wins=fires.filter(f=>f.outcome==='win').length;
  const losses=fires.filter(f=>f.outcome==='loss').length,scratches=fires.filter(f=>f.outcome==='scratch').length;
  const open=fires.filter(f=>f.outcome===null).length;
  const wr=wins+losses>0?Math.round(wins/(wins+losses)*100):null;
  const pnl=fires.filter(f=>f.outcome!==null).reduce((acc,f)=>{
    if(f.outcome==='win') return acc+f.price*(f.tPct||20)/100*100;
    if(f.outcome==='loss') return acc-f.price*(f.sPct||15)/100*100;
    return acc;
  },0);

  document.getElementById('sum-kpis').innerHTML=[
    {l:'APEX FIRES',v:total,c:'#a855f7'},
    {l:'WIN RATE',v:wr!==null?`${wr}%`:'â€”',c:wr>=60?'#10b981':wr>=40?'#f59e0b':'#ef4444'},
    {l:'WINS',v:wins,c:'#10b981'},{l:'LOSSES',v:losses,c:'#ef4444'},
    {l:'OPEN',v:open,c:open?'#f59e0b':'#475569'},
    {l:'EST P&L',v:pnl?`$${pnl>0?'+':''}${pnl.toFixed(0)}`:'â€”',c:pnl>0?'#10b981':pnl<0?'#ef4444':'#475569'},
  ].map(k=>`<div class="card" style="padding:12px"><div class="sl" style="margin-bottom:5px">${k.l}</div><div style="font-size:20px;font-weight:700;color:${k.c}">${k.v}</div></div>`).join('');

  document.getElementById('sum-fire-cnt').textContent=`${total} fires today`;
  document.getElementById('sum-fires').innerHTML=!fires.length?`<div style="text-align:center;padding:30px;color:#334155;font-size:12px">No APEX fires today.</div>`
    :[...fires].reverse().map(f=>{
      const col=f.type==='CALL'?'#10b981':'#ef4444';
      const oc={win:'#10b981',loss:'#ef4444',scratch:'#f59e0b',null:'#475569'};
      const ol={win:'âœ… WIN',loss:'âŒ LOSS',scratch:'â¡ SCRATCH',null:'â³ OPEN'};
      const chkCell=(chk,label)=>{
        if(!chk) return `<div style="background:#0c0c1a;border-radius:4px;padding:5px;text-align:center"><div style="font-size:8px;color:#334155;letter-spacing:1px">${label}</div><div style="font-size:10px;color:#334155">â€”</div></div>`;
        const bullMove=f.type==='CALL'?chk.moveUp:chk.moveDown;
        const bearMove=f.type==='CALL'?chk.moveDown:chk.moveUp;
        const favCol=bullMove>0.20?'#10b981':'#475569';
        const advCol=bearMove>0.20?'#ef4444':'#475569';
        return `<div style="background:#0c0c1a;border-radius:4px;padding:5px;text-align:center">
          <div style="font-size:8px;color:#475569;letter-spacing:1px;margin-bottom:2px">${label}</div>
          <div style="font-size:10px;font-weight:700;color:#94a3b8">$${chk.price}</div>
          <div style="font-size:9px;color:${favCol}">+$${chk.moveUp.toFixed(2)}</div>
          <div style="font-size:9px;color:${advCol}">-$${chk.moveDown.toFixed(2)}</div>
        </div>`;
      };
      const now=Date.now();
      const elapsed=f.firedAt?(now-f.firedAt)/60000:99;
      const tracking=elapsed<31&&!f.chk30;
      return `<div style="padding:12px;border-radius:6px;border:1px solid #1e293b;margin-bottom:10px;background:#080814">
        <div style="display:flex;align-items:center;justify-content:space-between;margin-bottom:6px">
          <span style="font-size:12px;font-weight:700;color:${col}">${f.type==='CALL'?'â–²':'â–¼'} ${f.type} &nbsp;$${f.strike} ${f.expiry}</span>
          <span style="font-size:10px;color:${oc[f.outcome]||'#475569'};font-weight:700">${ol[f.outcome]||'â³ OPEN'}</span>
        </div>
        <div style="font-size:10px;color:#475569;margin-bottom:6px">${f.time} Â· Entry $${(f.firePrice||f.price||0).toFixed(2)} Â· Conf ${f.conf}% Â· Tgt $${f.target.toFixed(2)} Â· Stop $${f.stop.toFixed(2)}</div>
        <div style="font-size:9px;color:#334155;margin-bottom:8px">${(f.components||[]).join(' + ')}</div>
        <div style="display:grid;grid-template-columns:repeat(4,1fr);gap:4px;margin-bottom:4px">
          ${chkCell(f.chk5,'5 MIN')}${chkCell(f.chk10,'10 MIN')}${chkCell(f.chk15,'15 MIN')}${chkCell(f.chk30,'30 MIN')}
        </div>
        ${tracking?`<div style="font-size:9px;color:#334155;text-align:center;margin-top:4px">â— Tracking price ${Math.ceil(30-elapsed)}m remaining Â· +$X = max up Â· -$X = max down from entry</div>`:''}
        ${f.notes?`<div style="font-size:10px;color:#64748b;font-style:italic;margin-top:6px">"${f.notes}"</div>`:''}
      </div>`;
    }).join('');

  const fps=computeFP(fires),maxFP=fps[0]?.count||1;
  document.getElementById('sum-fp').innerHTML=!losses?`<div style="color:#475569;font-size:11px;padding:10px 0">No losses logged yet.</div>`
    :fps.map(fp=>`<div style="margin-bottom:8px"><div style="display:flex;justify-content:space-between;font-size:10px;margin-bottom:3px"><span style="color:#94a3b8">${fp.rule}</span><span style="color:#ef4444;font-weight:700">${fp.count}Ã— on losses</span></div><div style="height:6px;background:#1e293b;border-radius:3px;overflow:hidden"><div style="height:100%;width:${~~(fp.count/maxFP*100)}%;background:linear-gradient(90deg,#ef4444,#dc2626);border-radius:3px;transition:width .5s"></div></div></div>`).join('')||'<div style="color:#475569;font-size:11px">No patterns yet.</div>';
  document.getElementById('sum-fp-txt').textContent=!losses?'Log trade outcomes to see false positive analysis.':fps[0]?`"${fps[0].rule}" on ${fps[0].count}/${losses} losses (${~~(fps[0].count/losses*100)}%). Review or tighten in PARAMS.`:'No patterns yet.';

  const bls=computeBL(blocks),maxB=bls[0]?.count||1;
  document.getElementById('sum-bl').innerHTML=!blocks.length?`<div style="color:#475569;font-size:11px;padding:10px 0">No near-miss events yet.</div>`
    :bls.slice(0,6).map(b=>`<div style="margin-bottom:8px"><div style="display:flex;justify-content:space-between;font-size:10px;margin-bottom:3px"><span style="color:#94a3b8">${b.rule}</span><span style="color:#f59e0b;font-weight:700">${b.count}Ã— absent</span></div><div style="height:6px;background:#1e293b;border-radius:3px;overflow:hidden"><div style="height:100%;width:${~~(b.count/maxB*100)}%;background:linear-gradient(90deg,#f59e0b,#d97706);border-radius:3px;transition:width .5s"></div></div></div>`).join('')||'<div style="color:#475569;font-size:11px">No patterns yet.</div>';
  document.getElementById('sum-bl-txt').textContent=bls[0]?`"${bls[0].rule}" absent ${bls[0].count}Ã— â€” top APEX blocker. Consider APEX_MIN or relaxing its threshold.`:'No blocker patterns yet.';

  const openFires=fires.filter(f=>f.outcome===null);
  document.getElementById('out-sel').innerHTML=!openFires.length?'<option value="">No open APEX trades</option>':openFires.map(f=>`<option value="${f.id}">${f.time} ${f.type} $${f.strike} ${f.expiry} Â· ${f.conf}% conf</option>`).join('');
  document.getElementById('sum-date').textContent=new Date().toLocaleDateString('en-US',{weekday:'long',month:'long',day:'numeric',year:'numeric'});
  document.getElementById('sum-text').textContent=buildExec(d,fires,blocks,wins,losses,scratches,open,wr,pnl,fps,bls);
  refreshBadge();
}

function buildExec(date,fires,blocks,wins,losses,scratches,open,wr,pnl,fps,bls){
  const L='â”€'.repeat(62),now=new Date().toLocaleTimeString('en-US',{hour:'2-digit',minute:'2-digit'}),ln=[];
  ln.push('SPY EDGE  â˜… APEX EVENING SUMMARY');
  ln.push(`${date}  Â·  Generated ${now}  Â·  v1.7`);
  ln.push(L);
  ln.push('\nDATA SOURCES');
  ln.push(`  Price   : ${CON.poly?'Polygon Paid â€” 5s real-time':'Demo / mock'}`);
  ln.push(`  Flow    : ${CON.uw?`Unusual Whales â€” live ($${P.SWEEP_MIN_PREM/1000}K+ filter)`:'Mock flow'}`);
  ln.push(`  GEX     : ${gexDataValid?`Flow GEX live â€” flip $${P.GEX_FLIP} Â· call wall $${P.GEX_CWALL} Â· put wall $${P.GEX_PWALL}`:'Manual override â€” verify levels each session'}`);
  ln.push(`  Backtest: ${CON.trad?'Tradier real option chain':'Estimated'}`);
  ln.push(`  Push    : ${CON.push?'Pushover active â€” APEX fires sent':'Not configured'}`);
  ln.push(`  GEX now : Flip $${P.GEX_FLIP} Â· Call Wall $${P.GEX_CWALL} Â· Put Wall $${P.GEX_PWALL}`);
  ln.push(`\nPERFORMANCE  (+${P.APEX_TGT_PCT}% target / -${P.APEX_STOP_PCT}% stop on option)`);
  ln.push(`  APEX fires today   : ${fires.length}`);
  ln.push(`  Wins               : ${wins}`);
  ln.push(`  Losses             : ${losses}`);
  ln.push(`  Scratches          : ${scratches}`);
  ln.push(`  Unlogged / open    : ${open}`);
  ln.push(`  Win rate           : ${wr!==null?wr+'%':'N/A â€” log outcomes first'}`);
  ln.push(`  Est. net P&L       : ${pnl?'$'+(pnl>0?'+':'')+pnl.toFixed(0):'N/A'}`);
  if(fires.length){
    ln.push('\nAPEX FIRES DETAIL');
    fires.forEach((f,i)=>{
      const omap={win:'WIN âœ…',loss:'LOSS âŒ',scratch:'SCRATCH â¡',null:'OPEN â³'};
      ln.push(`  ${i+1}. ${f.time}  ${f.type}  $${f.strike} ${f.expiry}  Entry $${(f.firePrice||f.price||0).toFixed(2)}  Conf ${f.conf}%  â†’  ${omap[f.outcome]||'OPEN â³'}`);
      if(f.chk5||f.chk10||f.chk15||f.chk30){
        const fmt=(chk,label)=>chk?`${label}: $${chk.price} (+$${chk.moveUp.toFixed(2)} / -$${chk.moveDown.toFixed(2)})`:`${label}: pending`;
        ln.push(`     ${fmt(f.chk5,'5m')} Â· ${fmt(f.chk10,'10m')} Â· ${fmt(f.chk15,'15m')} Â· ${fmt(f.chk30,'30m')}`);
      }
      ln.push(`     ${(f.components||[]).join(' + ')}`);
      if(f.notes) ln.push(`     Note: "${f.notes}"`);
    });
  }
  ln.push('\nFALSE POSITIVE ANALYSIS  (signals on losing trades)');
  if(!losses) ln.push('  No losses logged today.');
  else if(!fps.length) ln.push('  Insufficient data.');
  else{fps.forEach(fp=>ln.push(`  ${fp.rule.padEnd(34)} ${fp.count}Ã— on losses  (${~~(fp.count/losses*100)}%)`));ln.push(`\n  âš  Top offender: "${fps[0].rule}"`);ln.push(`    Present on ${fps[0].count}/${losses} losses â†’ review threshold in PARAMS.`);}
  ln.push('\nAPEX BLOCKERS  (rules that prevented APEX from firing)');
  if(!blocks.length) ln.push('  No near-miss events recorded today.');
  else{ln.push(`  Near-miss events: ${blocks.length}`);bls.slice(0,5).forEach(b=>ln.push(`  ${b.rule.padEnd(34)} absent ${b.count}Ã—`));if(bls[0]){ln.push(`\n  âš  Top blocker: "${bls[0].rule}"`);ln.push(`    Absent ${bls[0].count}Ã— â†’ lower APEX_MIN or relax threshold.`);}}
  ln.push('\nREFINEMENT NOTES');
  if(wr>=65) ln.push(`  âœ… Win rate ${wr}% strong. Raise APEX_CONF above ${P.APEX_CONF} to filter edge cases.`);
  else if(wr!==null&&wr<50){ln.push(`  âš  Win rate ${wr}% below 50%. Priority actions:`);if(fps[0])ln.push(`     â€¢ Tighten "${fps[0].rule}" â€” highest false positive rate`);if(bls[0])ln.push(`     â€¢ Review "${bls[0].rule}" â€” may be blocking valid setups`);ln.push(`     â€¢ Raise APEX_CONF above ${P.APEX_CONF}`);}
  else if(wr!==null) ln.push(`  ğŸ“Š Win rate ${wr}% acceptable. Continue logging to build sample size.`);
  else ln.push('  ğŸ“Š Log trade outcomes after close to enable analysis.');
  ln.push(`\n${L}`);
  ln.push('SPY Edge v1.7  Â·  Not financial advice  Â·  Model refinement tool only');
  return ln.join('\n');
}

// â”€â”€ SETTINGS MODAL
function openSettings(){
  document.getElementById('settings-modal').style.display='flex';
  document.getElementById('settings-body').innerHTML=`
    <div style="margin-bottom:18px">
      <div class="sl" style="margin-bottom:10px">API CONNECTION STATUS</div>
      ${[{l:'Polygon.io (Price)',ok:CON.poly,c:'#10b981'},{l:'Unusual Whales (Flow)',ok:CON.uw,c:'#06b6d4'},{l:'Flow GEX (auto Â· from UW)',ok:CON.uw&&gexDataValid,lbl:CON.uw?(gexDataValid?'â— COMPUTED':'â—Œ BUILDING'):'â—‹ NEEDS UW',c:'#10b981'},{l:'Tradier (Options Chain)',ok:CON.trad,c:'#f59e0b'},{l:'Delta Stream (Polygon WS)',ok:CON.stream,lbl:CON.stream?`â— LIVE Â· ${deltaTicks.length} ticks`:'â—‹ Connecting...',c:'#a78bfa'},{l:'Pushover (Push Notifications)',ok:CON.push,c:'#fb923c'}]
        .map(a=>`<div style="display:flex;align-items:center;justify-content:space-between;margin-bottom:8px;font-size:12px"><span style="color:#94a3b8">${a.l}</span><span style="color:${a.ok?a.c:a.lbl?'#f59e0b':'#334155'};font-weight:700">${a.lbl||(a.ok?'â— CONNECTED':'â—‹ NOT CONNECTED')}</span></div>`).join('')}
    </div>
    <div style="border-top:1px solid #1e293b;padding-top:16px;margin-bottom:16px">
      <div class="sl" style="margin-bottom:10px">PUSH NOTIFICATION TEST</div>
      <div style="font-size:11px;color:#475569;margin-bottom:10px">Send a test notification to confirm Pushover is working.</div>
      <button class="btn-ghost" onclick="sendSMS('SPY Edge v1.7 test â€” Pushover connected âœ“').then(ok=>alert(ok?'Sent âœ“':'Failed â€” check keys'))" style="padding:8px 16px;border-radius:6px;font-size:11px">SEND TEST NOTIFICATION</button>
    </div>
    <div style="border-top:1px solid #1e293b;padding-top:16px;margin-bottom:16px">
      <div class="sl" style="margin-bottom:10px">SIGNAL PARAMS</div>
      <div style="font-size:11px;color:#475569;line-height:2.2">
        APEX thresholds: <b style="color:#f59e0b">Trending ${P.APEX_CONF_TRENDING} Â· Mixed ${P.APEX_CONF_MIXED} Â· Range ${P.APEX_CONF_RANGE}</b><br>
        Boosters: Momentum 0â€“${P.APEX_MOM_MAX} Â· Flow 0â€“${P.APEX_FLOW_MAX} Â· Velocity âˆ’15â€“${P.APEX_VEL_MAX} Â· Path âˆ’20â€“${P.APEX_PATH_MAX}<br>
        Velocity: AM prime 10â€“11am Â· PM window 2â€“2:45pm Â· vol mult ${P.VEL_VOL_MULT}Ã—<br>
        GEX Gate: major sig ${P.GEX_MAJOR_SIG}+ Â· approach $${P.GEX_APPROACH} Â· at-level $${P.GEX_AT_LEVEL}<br>
        Continuation: major ahead $${P.GEX_CONT_MAJOR_AHEAD} Â· maj from mod $${P.GEX_CONT_MAJ_FROM_MOD}<br>
        Flow: min $${(P.FLOW_SWEEP_MIN/1000).toFixed(0)}K Â· ratio ${P.FLOW_MOM_THRESH*100}% Â· DEX strike band ${P.DEX_STRIKE_PCT*100}%<br>
        Grab filter: body thresh ${P.GRAB_BODY_THRESH*100}% Â· invalidate $${P.GRAB_INVALIDATE} Â· vol ratio ${P.GRAB_VOL_RATIO*100}%
      </div>
    </div>
    <div style="border-top:1px solid #1e293b;padding-top:16px">
      <div class="sl" style="margin-bottom:10px">REFRESH RATES</div>
      <div style="font-size:11px;color:#475569;line-height:2">Price: every ${P.LIVE_MS/1000}s Â· Flow: every ${P.FLOW_MS/1000}s Â· GEX: recomputed on each flow refresh (auto)</div>
    </div>
    <div style="border-top:1px solid #1e293b;padding-top:16px;margin-top:4px">
      <div class="sl" style="margin-bottom:10px">SESSION</div>
      <button onclick="closeSettings();disconnect();" style="width:100%;padding:10px;border-radius:6px;font-size:12px;font-weight:700;letter-spacing:1px;background:#1e293b;border:1px solid #ef444444;color:#ef4444;cursor:pointer">â‹ DISCONNECT &amp; RESET KEYS</button>
      <div style="font-size:10px;color:#334155;margin-top:6px;text-align:center">Clears all saved API keys â€” you'll re-enter them on next launch</div>
    </div>`;
}
function closeSettings(){document.getElementById('settings-modal').style.display='none';}

// â”€â”€ TAB SWITCHING
function switchTab(name){
  ['signals','flow','gex','backtest','orders','summary'].forEach(t=>{
    document.getElementById(`pane-${t}`).style.display=t===name?'block':'none';
    document.getElementById(`tab-${t}`).classList.toggle('active',t===name);
  });
  tab=name;
  if(name==='gex') renderGEX();
  if(name==='orders') renderOrders();
  if(name==='summary') renderSummary();
}

// â”€â”€ RULE TOGGLES
function toggleRule(key){
  rules[key]=!rules[key];
  const t=document.getElementById(`tog-${key}`),th=t.querySelector('.tog-thumb'),lbl=document.getElementById(`tlbl-${key}`);
  t.style.background=rules[key]?'#10b981':'#1e293b'; th.style.left=rules[key]?'18px':'2px'; lbl.style.color=rules[key]?'#e2e8f0':'#475569';
}

// â”€â”€ INIT
window.addEventListener('keydown',e=>{if(e.key==='Enter'&&document.getElementById('setup-screen').style.display!=='none')connectAll();});
(async()=>{
  const saved=localStorage.getItem('sek');
  if(saved){
    try{K=JSON.parse(saved);}catch{}
    if(K.poly){
      ['poly','uw','trad','cfworker','ptoken','puser'].forEach(k=>{
        const el=document.getElementById(`k-${k}`);
        if(el&&K[k==='cfworker'?'cfWorker':k]) el.value=K[k==='cfworker'?'cfWorker':k];
      });
      await fetchPolygon().catch(()=>{});
      await Promise.all([fetchUW(),fetchDarkPool()]).catch(()=>{});
      if(K.trad){try{await tradierChain(tradingDate());CON.trad=true;}catch{}}
      if(K.trad&&K.cfWorker) await initTradierStream();
      if(K.ptoken&&K.puser) CON.push=true;
      CON.poly=true;
      resetGEXState(); prevPosGEX=null; gexFlipEvents=[];
      launchApp();
      return;
    }
  }
  renderFlow(); refreshBadge();
})();
</script>
</body>
</html>
